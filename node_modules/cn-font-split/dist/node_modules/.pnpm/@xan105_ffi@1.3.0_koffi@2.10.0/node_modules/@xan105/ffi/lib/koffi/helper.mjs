import { randomUUID as n } from "node:crypto";
import t from "koffi";
import { isFunction as m } from "../../../../../../@xan105_is@2.10.1/node_modules/@xan105/is/lib/is/type/obj.mjs";
import { shouldObj as u } from "../../../../../../@xan105_is@2.10.1/node_modules/@xan105/is/lib/assert/type/obj.mjs";
import "../../../../../../@xan105_is@2.10.1/node_modules/@xan105/is/lib/is/file/binary.mjs";
import { asArray as h } from "../../../../../../@xan105_is@2.10.1/node_modules/@xan105/is/lib/opt/array.mjs";
import "./util/win32.mjs";
import { conventions as p } from "./util/abi.mjs";
class _ {
  #t = null;
  #r = null;
  constructor(r, s = null) {
    u(r);
    const i = h(r.parameters) ?? [], o = r.result || "void", e = p.includes(r.abi) ? r.abi : "cdecl", l = t.proto("__" + e, n(), o, i);
    this.#t = t.pointer(l), m(s) && this.register(s);
  }
  register(r = () => {
  }) {
    this.#t && this.#r && this.close(), this.#r = t.register(r, this.#t);
  }
  get type() {
    return this.#t;
  }
  get pointer() {
    return this.#r;
  }
  get address() {
    return this.#r ? t.address(this.#r) : null;
  }
  close() {
    this.#r && t.unregister(this.#r), this.#r = null, this.#t = null;
  }
}
export {
  _ as Callback
};
//# sourceMappingURL=helper.mjs.map
