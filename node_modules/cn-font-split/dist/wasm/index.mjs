import * as R from "google-protobuf";
import { Buffer as bs } from "buffer";
import ol from "path";
var Rt;
((e) => {
  ((c) => {
    c[c.UNSPECIFIED = 0] = "UNSPECIFIED", c[c.OUTPUT_DATA = 1] = "OUTPUT_DATA", c[c.END = 2] = "END";
  })(e.EventName || (e.EventName = {}));
  class t extends R.Message {
    #e = [[2], [5], [6], [9], [10], [11], [13], [14], [15], [18], [20], [8], [21], [22], [23], [24], [25]];
    constructor(n) {
      super(), R.Message.initialize(this, Array.isArray(n) ? n : [], 0, -1, [7], this.#e), !Array.isArray(n) && typeof n == "object" && ("input" in n && n.input != null && (this.input = n.input), "outDir" in n && n.outDir != null && (this.outDir = n.outDir), "css" in n && n.css != null && (this.css = n.css), "targetType" in n && n.targetType != null && (this.targetType = n.targetType), "subsets" in n && n.subsets != null && (this.subsets = n.subsets), "chunkSize" in n && n.chunkSize != null && (this.chunkSize = n.chunkSize), "chunkSizeTolerance" in n && n.chunkSizeTolerance != null && (this.chunkSizeTolerance = n.chunkSizeTolerance), "maxAllowSubsetsCount" in n && n.maxAllowSubsetsCount != null && (this.maxAllowSubsetsCount = n.maxAllowSubsetsCount), "testHtml" in n && n.testHtml != null && (this.testHtml = n.testHtml), "reporter" in n && n.reporter != null && (this.reporter = n.reporter), "previewImage" in n && n.previewImage != null && (this.previewImage = n.previewImage), "renameOutputFont" in n && n.renameOutputFont != null && (this.renameOutputFont = n.renameOutputFont), "buildMode" in n && n.buildMode != null && (this.buildMode = n.buildMode), "languageAreas" in n && n.languageAreas != null && (this.languageAreas = n.languageAreas), "multiThreads" in n && n.multiThreads != null && (this.multiThreads = n.multiThreads), "fontFeature" in n && n.fontFeature != null && (this.fontFeature = n.fontFeature), "reduceMins" in n && n.reduceMins != null && (this.reduceMins = n.reduceMins), "autoSubset" in n && n.autoSubset != null && (this.autoSubset = n.autoSubset), "subsetRemainChars" in n && n.subsetRemainChars != null && (this.subsetRemainChars = n.subsetRemainChars));
    }
    get input() {
      return R.Message.getFieldWithDefault(this, 1, new Uint8Array(0));
    }
    set input(n) {
      R.Message.setField(this, 1, n);
    }
    get outDir() {
      return R.Message.getFieldWithDefault(this, 2, "");
    }
    set outDir(n) {
      R.Message.setOneofField(this, 2, this.#e[0], n);
    }
    get hasOutDir() {
      return R.Message.getField(this, 2) != null;
    }
    get css() {
      return R.Message.getWrapperField(this, t.CssProperties, 5);
    }
    set css(n) {
      R.Message.setOneofWrapperField(this, 5, this.#e[1], n);
    }
    get hasCss() {
      return R.Message.getField(this, 5) != null;
    }
    get targetType() {
      return R.Message.getFieldWithDefault(this, 6, "");
    }
    set targetType(n) {
      R.Message.setOneofField(this, 6, this.#e[2], n);
    }
    get hasTargetType() {
      return R.Message.getField(this, 6) != null;
    }
    get subsets() {
      return R.Message.getFieldWithDefault(this, 7, []);
    }
    set subsets(n) {
      R.Message.setField(this, 7, n);
    }
    get chunkSize() {
      return R.Message.getFieldWithDefault(this, 9, 0);
    }
    set chunkSize(n) {
      R.Message.setOneofField(this, 9, this.#e[3], n);
    }
    get hasChunkSize() {
      return R.Message.getField(this, 9) != null;
    }
    get chunkSizeTolerance() {
      return R.Message.getFieldWithDefault(this, 10, 0);
    }
    set chunkSizeTolerance(n) {
      R.Message.setOneofField(this, 10, this.#e[4], n);
    }
    get hasChunkSizeTolerance() {
      return R.Message.getField(this, 10) != null;
    }
    get maxAllowSubsetsCount() {
      return R.Message.getFieldWithDefault(this, 11, 0);
    }
    set maxAllowSubsetsCount(n) {
      R.Message.setOneofField(this, 11, this.#e[5], n);
    }
    get hasMaxAllowSubsetsCount() {
      return R.Message.getField(this, 11) != null;
    }
    get testHtml() {
      return R.Message.getFieldWithDefault(this, 13, !1);
    }
    set testHtml(n) {
      R.Message.setOneofField(this, 13, this.#e[6], n);
    }
    get hasTestHtml() {
      return R.Message.getField(this, 13) != null;
    }
    get reporter() {
      return R.Message.getFieldWithDefault(this, 14, !1);
    }
    set reporter(n) {
      R.Message.setOneofField(this, 14, this.#e[7], n);
    }
    get hasReporter() {
      return R.Message.getField(this, 14) != null;
    }
    get previewImage() {
      return R.Message.getWrapperField(this, t.PreviewImage, 15);
    }
    set previewImage(n) {
      R.Message.setOneofWrapperField(this, 15, this.#e[8], n);
    }
    get hasPreviewImage() {
      return R.Message.getField(this, 15) != null;
    }
    get renameOutputFont() {
      return R.Message.getFieldWithDefault(this, 18, "");
    }
    set renameOutputFont(n) {
      R.Message.setOneofField(this, 18, this.#e[9], n);
    }
    get hasRenameOutputFont() {
      return R.Message.getField(this, 18) != null;
    }
    get buildMode() {
      return R.Message.getFieldWithDefault(this, 20, "");
    }
    set buildMode(n) {
      R.Message.setOneofField(this, 20, this.#e[10], n);
    }
    get hasBuildMode() {
      return R.Message.getField(this, 20) != null;
    }
    get languageAreas() {
      return R.Message.getFieldWithDefault(this, 8, !1);
    }
    set languageAreas(n) {
      R.Message.setOneofField(this, 8, this.#e[11], n);
    }
    get hasLanguageAreas() {
      return R.Message.getField(this, 8) != null;
    }
    get multiThreads() {
      return R.Message.getFieldWithDefault(this, 21, !1);
    }
    set multiThreads(n) {
      R.Message.setOneofField(this, 21, this.#e[12], n);
    }
    get hasMultiThreads() {
      return R.Message.getField(this, 21) != null;
    }
    get fontFeature() {
      return R.Message.getFieldWithDefault(this, 22, !1);
    }
    set fontFeature(n) {
      R.Message.setOneofField(this, 22, this.#e[13], n);
    }
    get hasFontFeature() {
      return R.Message.getField(this, 22) != null;
    }
    get reduceMins() {
      return R.Message.getFieldWithDefault(this, 23, !1);
    }
    set reduceMins(n) {
      R.Message.setOneofField(this, 23, this.#e[14], n);
    }
    get hasReduceMins() {
      return R.Message.getField(this, 23) != null;
    }
    get autoSubset() {
      return R.Message.getFieldWithDefault(this, 24, !1);
    }
    set autoSubset(n) {
      R.Message.setOneofField(this, 24, this.#e[15], n);
    }
    get hasAutoSubset() {
      return R.Message.getField(this, 24) != null;
    }
    get subsetRemainChars() {
      return R.Message.getFieldWithDefault(this, 25, !1);
    }
    set subsetRemainChars(n) {
      R.Message.setOneofField(this, 25, this.#e[16], n);
    }
    get hasSubsetRemainChars() {
      return R.Message.getField(this, 25) != null;
    }
    get _out_dir() {
      return {
        0: "none",
        2: "outDir"
      }[R.Message.computeOneofCase(this, [2])];
    }
    get _css() {
      return {
        0: "none",
        5: "css"
      }[R.Message.computeOneofCase(this, [5])];
    }
    get _target_type() {
      return {
        0: "none",
        6: "targetType"
      }[R.Message.computeOneofCase(this, [6])];
    }
    get _chunk_size() {
      return {
        0: "none",
        9: "chunkSize"
      }[R.Message.computeOneofCase(this, [9])];
    }
    get _chunk_size_tolerance() {
      return {
        0: "none",
        10: "chunkSizeTolerance"
      }[R.Message.computeOneofCase(this, [10])];
    }
    get _max_allow_subsets_count() {
      return {
        0: "none",
        11: "maxAllowSubsetsCount"
      }[R.Message.computeOneofCase(this, [11])];
    }
    get _test_html() {
      return {
        0: "none",
        13: "testHtml"
      }[R.Message.computeOneofCase(this, [13])];
    }
    get _reporter() {
      return {
        0: "none",
        14: "reporter"
      }[R.Message.computeOneofCase(this, [14])];
    }
    get _preview_image() {
      return {
        0: "none",
        15: "previewImage"
      }[R.Message.computeOneofCase(this, [15])];
    }
    get _rename_output_font() {
      return {
        0: "none",
        18: "renameOutputFont"
      }[R.Message.computeOneofCase(this, [18])];
    }
    get _build_mode() {
      return {
        0: "none",
        20: "buildMode"
      }[R.Message.computeOneofCase(this, [20])];
    }
    get _language_areas() {
      return {
        0: "none",
        8: "languageAreas"
      }[R.Message.computeOneofCase(this, [8])];
    }
    get _multi_threads() {
      return {
        0: "none",
        21: "multiThreads"
      }[R.Message.computeOneofCase(this, [21])];
    }
    get _font_feature() {
      return {
        0: "none",
        22: "fontFeature"
      }[R.Message.computeOneofCase(this, [22])];
    }
    get _reduce_mins() {
      return {
        0: "none",
        23: "reduceMins"
      }[R.Message.computeOneofCase(this, [23])];
    }
    get _auto_subset() {
      return {
        0: "none",
        24: "autoSubset"
      }[R.Message.computeOneofCase(this, [24])];
    }
    get _subset_remain_chars() {
      return {
        0: "none",
        25: "subsetRemainChars"
      }[R.Message.computeOneofCase(this, [25])];
    }
    static fromObject(n) {
      const u = new t({});
      return n.input != null && (u.input = n.input), n.outDir != null && (u.outDir = n.outDir), n.css != null && (u.css = t.CssProperties.fromObject(n.css)), n.targetType != null && (u.targetType = n.targetType), n.subsets != null && (u.subsets = n.subsets), n.chunkSize != null && (u.chunkSize = n.chunkSize), n.chunkSizeTolerance != null && (u.chunkSizeTolerance = n.chunkSizeTolerance), n.maxAllowSubsetsCount != null && (u.maxAllowSubsetsCount = n.maxAllowSubsetsCount), n.testHtml != null && (u.testHtml = n.testHtml), n.reporter != null && (u.reporter = n.reporter), n.previewImage != null && (u.previewImage = t.PreviewImage.fromObject(n.previewImage)), n.renameOutputFont != null && (u.renameOutputFont = n.renameOutputFont), n.buildMode != null && (u.buildMode = n.buildMode), n.languageAreas != null && (u.languageAreas = n.languageAreas), n.multiThreads != null && (u.multiThreads = n.multiThreads), n.fontFeature != null && (u.fontFeature = n.fontFeature), n.reduceMins != null && (u.reduceMins = n.reduceMins), n.autoSubset != null && (u.autoSubset = n.autoSubset), n.subsetRemainChars != null && (u.subsetRemainChars = n.subsetRemainChars), u;
    }
    toObject() {
      const n = {};
      return this.input != null && (n.input = this.input), this.outDir != null && (n.outDir = this.outDir), this.css != null && (n.css = this.css.toObject()), this.targetType != null && (n.targetType = this.targetType), this.subsets != null && (n.subsets = this.subsets), this.chunkSize != null && (n.chunkSize = this.chunkSize), this.chunkSizeTolerance != null && (n.chunkSizeTolerance = this.chunkSizeTolerance), this.maxAllowSubsetsCount != null && (n.maxAllowSubsetsCount = this.maxAllowSubsetsCount), this.testHtml != null && (n.testHtml = this.testHtml), this.reporter != null && (n.reporter = this.reporter), this.previewImage != null && (n.previewImage = this.previewImage.toObject()), this.renameOutputFont != null && (n.renameOutputFont = this.renameOutputFont), this.buildMode != null && (n.buildMode = this.buildMode), this.languageAreas != null && (n.languageAreas = this.languageAreas), this.multiThreads != null && (n.multiThreads = this.multiThreads), this.fontFeature != null && (n.fontFeature = this.fontFeature), this.reduceMins != null && (n.reduceMins = this.reduceMins), this.autoSubset != null && (n.autoSubset = this.autoSubset), this.subsetRemainChars != null && (n.subsetRemainChars = this.subsetRemainChars), n;
    }
    serialize(n) {
      const u = n || new R.BinaryWriter();
      if (this.input.length && u.writeBytes(1, this.input), this.hasOutDir && u.writeString(2, this.outDir), this.hasCss && u.writeMessage(5, this.css, () => this.css.serialize(u)), this.hasTargetType && u.writeString(6, this.targetType), this.subsets.length && u.writeRepeatedBytes(7, this.subsets), this.hasChunkSize && u.writeInt32(9, this.chunkSize), this.hasChunkSizeTolerance && u.writeFloat(10, this.chunkSizeTolerance), this.hasMaxAllowSubsetsCount && u.writeInt32(11, this.maxAllowSubsetsCount), this.hasTestHtml && u.writeBool(13, this.testHtml), this.hasReporter && u.writeBool(14, this.reporter), this.hasPreviewImage && u.writeMessage(15, this.previewImage, () => this.previewImage.serialize(u)), this.hasRenameOutputFont && u.writeString(18, this.renameOutputFont), this.hasBuildMode && u.writeString(20, this.buildMode), this.hasLanguageAreas && u.writeBool(8, this.languageAreas), this.hasMultiThreads && u.writeBool(21, this.multiThreads), this.hasFontFeature && u.writeBool(22, this.fontFeature), this.hasReduceMins && u.writeBool(23, this.reduceMins), this.hasAutoSubset && u.writeBool(24, this.autoSubset), this.hasSubsetRemainChars && u.writeBool(25, this.subsetRemainChars), !n)
        return u.getResultBuffer();
    }
    static deserialize(n) {
      const u = n instanceof R.BinaryReader ? n : new R.BinaryReader(n), _ = new t();
      for (; u.nextField() && !u.isEndGroup(); )
        switch (u.getFieldNumber()) {
          case 1:
            _.input = u.readBytes();
            break;
          case 2:
            _.outDir = u.readString();
            break;
          case 5:
            u.readMessage(_.css, () => _.css = t.CssProperties.deserialize(u));
            break;
          case 6:
            _.targetType = u.readString();
            break;
          case 7:
            R.Message.addToRepeatedField(_, 7, u.readBytes());
            break;
          case 9:
            _.chunkSize = u.readInt32();
            break;
          case 10:
            _.chunkSizeTolerance = u.readFloat();
            break;
          case 11:
            _.maxAllowSubsetsCount = u.readInt32();
            break;
          case 13:
            _.testHtml = u.readBool();
            break;
          case 14:
            _.reporter = u.readBool();
            break;
          case 15:
            u.readMessage(_.previewImage, () => _.previewImage = t.PreviewImage.deserialize(u));
            break;
          case 18:
            _.renameOutputFont = u.readString();
            break;
          case 20:
            _.buildMode = u.readString();
            break;
          case 8:
            _.languageAreas = u.readBool();
            break;
          case 21:
            _.multiThreads = u.readBool();
            break;
          case 22:
            _.fontFeature = u.readBool();
            break;
          case 23:
            _.reduceMins = u.readBool();
            break;
          case 24:
            _.autoSubset = u.readBool();
            break;
          case 25:
            _.subsetRemainChars = u.readBool();
            break;
          default:
            u.skipField();
        }
      return _;
    }
    serializeBinary() {
      return this.serialize();
    }
    static deserializeBinary(n) {
      return t.deserialize(n);
    }
  }
  e.InputTemplate = t, ((c) => {
    class n extends R.Message {
      #e = [[1], [2], [3], [4], [11], [12], [13], [8], [9]];
      constructor(d) {
        super(), R.Message.initialize(this, Array.isArray(d) ? d : [], 0, -1, [5, 6], this.#e), !Array.isArray(d) && typeof d == "object" && ("fontFamily" in d && d.fontFamily != null && (this.fontFamily = d.fontFamily), "fontWeight" in d && d.fontWeight != null && (this.fontWeight = d.fontWeight), "fontStyle" in d && d.fontStyle != null && (this.fontStyle = d.fontStyle), "fontDisplay" in d && d.fontDisplay != null && (this.fontDisplay = d.fontDisplay), "localFamily" in d && d.localFamily != null && (this.localFamily = d.localFamily), "polyfill" in d && d.polyfill != null && (this.polyfill = d.polyfill), "commentBase" in d && d.commentBase != null && (this.commentBase = d.commentBase), "commentNameTable" in d && d.commentNameTable != null && (this.commentNameTable = d.commentNameTable), "commentUnicodes" in d && d.commentUnicodes != null && (this.commentUnicodes = d.commentUnicodes), "compress" in d && d.compress != null && (this.compress = d.compress), "fileName" in d && d.fileName != null && (this.fileName = d.fileName));
      }
      get fontFamily() {
        return R.Message.getFieldWithDefault(this, 1, "");
      }
      set fontFamily(d) {
        R.Message.setOneofField(this, 1, this.#e[0], d);
      }
      get hasFontFamily() {
        return R.Message.getField(this, 1) != null;
      }
      get fontWeight() {
        return R.Message.getFieldWithDefault(this, 2, "");
      }
      set fontWeight(d) {
        R.Message.setOneofField(this, 2, this.#e[1], d);
      }
      get hasFontWeight() {
        return R.Message.getField(this, 2) != null;
      }
      get fontStyle() {
        return R.Message.getFieldWithDefault(this, 3, "");
      }
      set fontStyle(d) {
        R.Message.setOneofField(this, 3, this.#e[2], d);
      }
      get hasFontStyle() {
        return R.Message.getField(this, 3) != null;
      }
      get fontDisplay() {
        return R.Message.getFieldWithDefault(this, 4, "");
      }
      set fontDisplay(d) {
        R.Message.setOneofField(this, 4, this.#e[3], d);
      }
      get hasFontDisplay() {
        return R.Message.getField(this, 4) != null;
      }
      get localFamily() {
        return R.Message.getFieldWithDefault(this, 5, []);
      }
      set localFamily(d) {
        R.Message.setField(this, 5, d);
      }
      get polyfill() {
        return R.Message.getRepeatedWrapperField(this, c.PolyfillType, 6);
      }
      set polyfill(d) {
        R.Message.setRepeatedWrapperField(this, 6, d);
      }
      get commentBase() {
        return R.Message.getFieldWithDefault(this, 11, !1);
      }
      set commentBase(d) {
        R.Message.setOneofField(this, 11, this.#e[4], d);
      }
      get hasCommentBase() {
        return R.Message.getField(this, 11) != null;
      }
      get commentNameTable() {
        return R.Message.getFieldWithDefault(this, 12, !1);
      }
      set commentNameTable(d) {
        R.Message.setOneofField(this, 12, this.#e[5], d);
      }
      get hasCommentNameTable() {
        return R.Message.getField(this, 12) != null;
      }
      get commentUnicodes() {
        return R.Message.getFieldWithDefault(this, 13, !1);
      }
      set commentUnicodes(d) {
        R.Message.setOneofField(this, 13, this.#e[6], d);
      }
      get hasCommentUnicodes() {
        return R.Message.getField(this, 13) != null;
      }
      get compress() {
        return R.Message.getFieldWithDefault(this, 8, !1);
      }
      set compress(d) {
        R.Message.setOneofField(this, 8, this.#e[7], d);
      }
      get hasCompress() {
        return R.Message.getField(this, 8) != null;
      }
      get fileName() {
        return R.Message.getFieldWithDefault(this, 9, "");
      }
      set fileName(d) {
        R.Message.setOneofField(this, 9, this.#e[8], d);
      }
      get hasFileName() {
        return R.Message.getField(this, 9) != null;
      }
      get _font_family() {
        return {
          0: "none",
          1: "fontFamily"
        }[R.Message.computeOneofCase(this, [1])];
      }
      get _font_weight() {
        return {
          0: "none",
          2: "fontWeight"
        }[R.Message.computeOneofCase(this, [2])];
      }
      get _font_style() {
        return {
          0: "none",
          3: "fontStyle"
        }[R.Message.computeOneofCase(this, [3])];
      }
      get _font_display() {
        return {
          0: "none",
          4: "fontDisplay"
        }[R.Message.computeOneofCase(this, [4])];
      }
      get _comment_base() {
        return {
          0: "none",
          11: "commentBase"
        }[R.Message.computeOneofCase(this, [11])];
      }
      get _comment_name_table() {
        return {
          0: "none",
          12: "commentNameTable"
        }[R.Message.computeOneofCase(this, [12])];
      }
      get _comment_unicodes() {
        return {
          0: "none",
          13: "commentUnicodes"
        }[R.Message.computeOneofCase(this, [13])];
      }
      get _compress() {
        return {
          0: "none",
          8: "compress"
        }[R.Message.computeOneofCase(this, [8])];
      }
      get _file_name() {
        return {
          0: "none",
          9: "fileName"
        }[R.Message.computeOneofCase(this, [9])];
      }
      static fromObject(d) {
        const s = new n({});
        return d.fontFamily != null && (s.fontFamily = d.fontFamily), d.fontWeight != null && (s.fontWeight = d.fontWeight), d.fontStyle != null && (s.fontStyle = d.fontStyle), d.fontDisplay != null && (s.fontDisplay = d.fontDisplay), d.localFamily != null && (s.localFamily = d.localFamily), d.polyfill != null && (s.polyfill = d.polyfill.map((l) => c.PolyfillType.fromObject(l))), d.commentBase != null && (s.commentBase = d.commentBase), d.commentNameTable != null && (s.commentNameTable = d.commentNameTable), d.commentUnicodes != null && (s.commentUnicodes = d.commentUnicodes), d.compress != null && (s.compress = d.compress), d.fileName != null && (s.fileName = d.fileName), s;
      }
      toObject() {
        const d = {};
        return this.fontFamily != null && (d.fontFamily = this.fontFamily), this.fontWeight != null && (d.fontWeight = this.fontWeight), this.fontStyle != null && (d.fontStyle = this.fontStyle), this.fontDisplay != null && (d.fontDisplay = this.fontDisplay), this.localFamily != null && (d.localFamily = this.localFamily), this.polyfill != null && (d.polyfill = this.polyfill.map((s) => s.toObject())), this.commentBase != null && (d.commentBase = this.commentBase), this.commentNameTable != null && (d.commentNameTable = this.commentNameTable), this.commentUnicodes != null && (d.commentUnicodes = this.commentUnicodes), this.compress != null && (d.compress = this.compress), this.fileName != null && (d.fileName = this.fileName), d;
      }
      serialize(d) {
        const s = d || new R.BinaryWriter();
        if (this.hasFontFamily && s.writeString(1, this.fontFamily), this.hasFontWeight && s.writeString(2, this.fontWeight), this.hasFontStyle && s.writeString(3, this.fontStyle), this.hasFontDisplay && s.writeString(4, this.fontDisplay), this.localFamily.length && s.writeRepeatedString(5, this.localFamily), this.polyfill.length && s.writeRepeatedMessage(6, this.polyfill, (l) => l.serialize(s)), this.hasCommentBase && s.writeBool(11, this.commentBase), this.hasCommentNameTable && s.writeBool(12, this.commentNameTable), this.hasCommentUnicodes && s.writeBool(13, this.commentUnicodes), this.hasCompress && s.writeBool(8, this.compress), this.hasFileName && s.writeString(9, this.fileName), !d)
          return s.getResultBuffer();
      }
      static deserialize(d) {
        const s = d instanceof R.BinaryReader ? d : new R.BinaryReader(d), l = new n();
        for (; s.nextField() && !s.isEndGroup(); )
          switch (s.getFieldNumber()) {
            case 1:
              l.fontFamily = s.readString();
              break;
            case 2:
              l.fontWeight = s.readString();
              break;
            case 3:
              l.fontStyle = s.readString();
              break;
            case 4:
              l.fontDisplay = s.readString();
              break;
            case 5:
              R.Message.addToRepeatedField(l, 5, s.readString());
              break;
            case 6:
              s.readMessage(l.polyfill, () => R.Message.addToRepeatedWrapperField(l, 6, c.PolyfillType.deserialize(s), c.PolyfillType));
              break;
            case 11:
              l.commentBase = s.readBool();
              break;
            case 12:
              l.commentNameTable = s.readBool();
              break;
            case 13:
              l.commentUnicodes = s.readBool();
              break;
            case 8:
              l.compress = s.readBool();
              break;
            case 9:
              l.fileName = s.readString();
              break;
            default:
              s.skipField();
          }
        return l;
      }
      serializeBinary() {
        return this.serialize();
      }
      static deserializeBinary(d) {
        return n.deserialize(d);
      }
    }
    c.CssProperties = n;
    class u extends R.Message {
      #e = [];
      constructor(d) {
        super(), R.Message.initialize(this, Array.isArray(d) ? d : [], 0, -1, [], this.#e), !Array.isArray(d) && typeof d == "object" && ("name" in d && d.name != null && (this.name = d.name), "format" in d && d.format != null && (this.format = d.format));
      }
      get name() {
        return R.Message.getFieldWithDefault(this, 1, "");
      }
      set name(d) {
        R.Message.setField(this, 1, d);
      }
      get format() {
        return R.Message.getFieldWithDefault(this, 2, "");
      }
      set format(d) {
        R.Message.setField(this, 2, d);
      }
      static fromObject(d) {
        const s = new u({});
        return d.name != null && (s.name = d.name), d.format != null && (s.format = d.format), s;
      }
      toObject() {
        const d = {};
        return this.name != null && (d.name = this.name), this.format != null && (d.format = this.format), d;
      }
      serialize(d) {
        const s = d || new R.BinaryWriter();
        if (this.name.length && s.writeString(1, this.name), this.format.length && s.writeString(2, this.format), !d)
          return s.getResultBuffer();
      }
      static deserialize(d) {
        const s = d instanceof R.BinaryReader ? d : new R.BinaryReader(d), l = new u();
        for (; s.nextField() && !s.isEndGroup(); )
          switch (s.getFieldNumber()) {
            case 1:
              l.name = s.readString();
              break;
            case 2:
              l.format = s.readString();
              break;
            default:
              s.skipField();
          }
        return l;
      }
      serializeBinary() {
        return this.serialize();
      }
      static deserializeBinary(d) {
        return u.deserialize(d);
      }
    }
    c.PolyfillType = u;
    class _ extends R.Message {
      #e = [];
      constructor(d) {
        super(), R.Message.initialize(this, Array.isArray(d) ? d : [], 0, -1, [], this.#e), !Array.isArray(d) && typeof d == "object" && ("text" in d && d.text != null && (this.text = d.text), "name" in d && d.name != null && (this.name = d.name));
      }
      get text() {
        return R.Message.getFieldWithDefault(this, 1, "");
      }
      set text(d) {
        R.Message.setField(this, 1, d);
      }
      get name() {
        return R.Message.getFieldWithDefault(this, 2, "");
      }
      set name(d) {
        R.Message.setField(this, 2, d);
      }
      static fromObject(d) {
        const s = new _({});
        return d.text != null && (s.text = d.text), d.name != null && (s.name = d.name), s;
      }
      toObject() {
        const d = {};
        return this.text != null && (d.text = this.text), this.name != null && (d.name = this.name), d;
      }
      serialize(d) {
        const s = d || new R.BinaryWriter();
        if (this.text.length && s.writeString(1, this.text), this.name.length && s.writeString(2, this.name), !d)
          return s.getResultBuffer();
      }
      static deserialize(d) {
        const s = d instanceof R.BinaryReader ? d : new R.BinaryReader(d), l = new _();
        for (; s.nextField() && !s.isEndGroup(); )
          switch (s.getFieldNumber()) {
            case 1:
              l.text = s.readString();
              break;
            case 2:
              l.name = s.readString();
              break;
            default:
              s.skipField();
          }
        return l;
      }
      serializeBinary() {
        return this.serialize();
      }
      static deserializeBinary(d) {
        return _.deserialize(d);
      }
    }
    c.PreviewImage = _;
  })(t = e.InputTemplate || (e.InputTemplate = {}));
  class r extends R.Message {
    #e = [[3]];
    constructor(n) {
      super(), R.Message.initialize(this, Array.isArray(n) ? n : [], 0, -1, [], this.#e), !Array.isArray(n) && typeof n == "object" && ("event" in n && n.event != null && (this.event = n.event), "message" in n && n.message != null && (this.message = n.message), "data" in n && n.data != null && (this.data = n.data));
    }
    get event() {
      return R.Message.getFieldWithDefault(
        this,
        1,
        0
        /* UNSPECIFIED */
      );
    }
    set event(n) {
      R.Message.setField(this, 1, n);
    }
    get message() {
      return R.Message.getFieldWithDefault(this, 2, "");
    }
    set message(n) {
      R.Message.setField(this, 2, n);
    }
    get data() {
      return R.Message.getFieldWithDefault(this, 3, new Uint8Array(0));
    }
    set data(n) {
      R.Message.setOneofField(this, 3, this.#e[0], n);
    }
    get hasData() {
      return R.Message.getField(this, 3) != null;
    }
    get _data() {
      return {
        0: "none",
        3: "data"
      }[R.Message.computeOneofCase(this, [3])];
    }
    static fromObject(n) {
      const u = new r({});
      return n.event != null && (u.event = n.event), n.message != null && (u.message = n.message), n.data != null && (u.data = n.data), u;
    }
    toObject() {
      const n = {};
      return this.event != null && (n.event = this.event), this.message != null && (n.message = this.message), this.data != null && (n.data = this.data), n;
    }
    serialize(n) {
      const u = n || new R.BinaryWriter();
      if (this.event != 0 && u.writeEnum(1, this.event), this.message.length && u.writeString(2, this.message), this.hasData && u.writeBytes(3, this.data), !n)
        return u.getResultBuffer();
    }
    static deserialize(n) {
      const u = n instanceof R.BinaryReader ? n : new R.BinaryReader(n), _ = new r();
      for (; u.nextField() && !u.isEndGroup(); )
        switch (u.getFieldNumber()) {
          case 1:
            _.event = u.readEnum();
            break;
          case 2:
            _.message = u.readString();
            break;
          case 3:
            _.data = u.readBytes();
            break;
          default:
            u.skipField();
        }
      return _;
    }
    serializeBinary() {
      return this.serialize();
    }
    static deserializeBinary(n) {
      return r.deserialize(n);
    }
  }
  e.EventMessage = r;
  class i extends R.Message {
    #e = [];
    constructor(n) {
      super(), R.Message.initialize(this, Array.isArray(n) ? n : [], 0, -1, [1], this.#e), !Array.isArray(n) && typeof n == "object" && "messages" in n && n.messages != null && (this.messages = n.messages);
    }
    get messages() {
      return R.Message.getRepeatedWrapperField(this, r, 1);
    }
    set messages(n) {
      R.Message.setRepeatedWrapperField(this, 1, n);
    }
    static fromObject(n) {
      const u = new i({});
      return n.messages != null && (u.messages = n.messages.map((_) => r.fromObject(_))), u;
    }
    toObject() {
      const n = {};
      return this.messages != null && (n.messages = this.messages.map((u) => u.toObject())), n;
    }
    serialize(n) {
      const u = n || new R.BinaryWriter();
      if (this.messages.length && u.writeRepeatedMessage(1, this.messages, (_) => _.serialize(u)), !n)
        return u.getResultBuffer();
    }
    static deserialize(n) {
      const u = n instanceof R.BinaryReader ? n : new R.BinaryReader(n), _ = new i();
      for (; u.nextField() && !u.isEndGroup(); )
        switch (u.getFieldNumber()) {
          case 1:
            u.readMessage(_.messages, () => R.Message.addToRepeatedWrapperField(_, 1, r.deserialize(u), r));
            break;
          default:
            u.skipField();
        }
      return _;
    }
    serializeBinary() {
      return this.serialize();
    }
    static deserializeBinary(n) {
      return i.deserialize(n);
    }
  }
  e.MultiMessages = i;
  class o extends R.Message {
    #e = [];
    constructor(n) {
      super(), R.Message.initialize(this, Array.isArray(n) ? n : [], 0, -1, [25, 26], this.#e), !Array.isArray(n) && typeof n == "object" && ("version" in n && n.version != null && (this.version = n.version), "css" in n && n.css != null && (this.css = n.css), "platform" in n && n.platform != null && (this.platform = n.platform), "bundleMessage" in n && n.bundleMessage != null && (this.bundleMessage = n.bundleMessage), "nameTable" in n && n.nameTable != null && (this.nameTable = n.nameTable), "subsetDetail" in n && n.subsetDetail != null && (this.subsetDetail = n.subsetDetail));
    }
    get version() {
      return R.Message.getFieldWithDefault(this, 1, "");
    }
    set version(n) {
      R.Message.setField(this, 1, n);
    }
    get css() {
      return R.Message.getWrapperField(this, o.Css, 2);
    }
    set css(n) {
      R.Message.setWrapperField(this, 2, n);
    }
    get hasCss() {
      return R.Message.getField(this, 2) != null;
    }
    get platform() {
      return R.Message.getFieldWithDefault(this, 3, "");
    }
    set platform(n) {
      R.Message.setField(this, 3, n);
    }
    get bundleMessage() {
      return R.Message.getWrapperField(this, o.BundleMessage, 24);
    }
    set bundleMessage(n) {
      R.Message.setWrapperField(this, 24, n);
    }
    get hasBundleMessage() {
      return R.Message.getField(this, 24) != null;
    }
    get nameTable() {
      return R.Message.getRepeatedWrapperField(this, o.NameTable, 25);
    }
    set nameTable(n) {
      R.Message.setRepeatedWrapperField(this, 25, n);
    }
    get subsetDetail() {
      return R.Message.getRepeatedWrapperField(this, o.SubsetDetail, 26);
    }
    set subsetDetail(n) {
      R.Message.setRepeatedWrapperField(this, 26, n);
    }
    static fromObject(n) {
      const u = new o({});
      return n.version != null && (u.version = n.version), n.css != null && (u.css = o.Css.fromObject(n.css)), n.platform != null && (u.platform = n.platform), n.bundleMessage != null && (u.bundleMessage = o.BundleMessage.fromObject(n.bundleMessage)), n.nameTable != null && (u.nameTable = n.nameTable.map((_) => o.NameTable.fromObject(_))), n.subsetDetail != null && (u.subsetDetail = n.subsetDetail.map((_) => o.SubsetDetail.fromObject(_))), u;
    }
    toObject() {
      const n = {};
      return this.version != null && (n.version = this.version), this.css != null && (n.css = this.css.toObject()), this.platform != null && (n.platform = this.platform), this.bundleMessage != null && (n.bundleMessage = this.bundleMessage.toObject()), this.nameTable != null && (n.nameTable = this.nameTable.map((u) => u.toObject())), this.subsetDetail != null && (n.subsetDetail = this.subsetDetail.map((u) => u.toObject())), n;
    }
    serialize(n) {
      const u = n || new R.BinaryWriter();
      if (this.version.length && u.writeString(1, this.version), this.hasCss && u.writeMessage(2, this.css, () => this.css.serialize(u)), this.platform.length && u.writeString(3, this.platform), this.hasBundleMessage && u.writeMessage(24, this.bundleMessage, () => this.bundleMessage.serialize(u)), this.nameTable.length && u.writeRepeatedMessage(25, this.nameTable, (_) => _.serialize(u)), this.subsetDetail.length && u.writeRepeatedMessage(26, this.subsetDetail, (_) => _.serialize(u)), !n)
        return u.getResultBuffer();
    }
    static deserialize(n) {
      const u = n instanceof R.BinaryReader ? n : new R.BinaryReader(n), _ = new o();
      for (; u.nextField() && !u.isEndGroup(); )
        switch (u.getFieldNumber()) {
          case 1:
            _.version = u.readString();
            break;
          case 2:
            u.readMessage(_.css, () => _.css = o.Css.deserialize(u));
            break;
          case 3:
            _.platform = u.readString();
            break;
          case 24:
            u.readMessage(_.bundleMessage, () => _.bundleMessage = o.BundleMessage.deserialize(u));
            break;
          case 25:
            u.readMessage(_.nameTable, () => R.Message.addToRepeatedWrapperField(_, 25, o.NameTable.deserialize(u), o.NameTable));
            break;
          case 26:
            u.readMessage(_.subsetDetail, () => R.Message.addToRepeatedWrapperField(_, 26, o.SubsetDetail.deserialize(u), o.SubsetDetail));
            break;
          default:
            u.skipField();
        }
      return _;
    }
    serializeBinary() {
      return this.serialize();
    }
    static deserializeBinary(n) {
      return o.deserialize(n);
    }
  }
  e.OutputReport = o, ((c) => {
    class n extends R.Message {
      #e = [];
      constructor(s) {
        super(), R.Message.initialize(this, Array.isArray(s) ? s : [], 0, -1, [], this.#e), !Array.isArray(s) && typeof s == "object" && ("platform" in s && s.platform != null && (this.platform = s.platform), "language" in s && s.language != null && (this.language = s.language), "name" in s && s.name != null && (this.name = s.name), "value" in s && s.value != null && (this.value = s.value));
      }
      get platform() {
        return R.Message.getFieldWithDefault(this, 1, "");
      }
      set platform(s) {
        R.Message.setField(this, 1, s);
      }
      get language() {
        return R.Message.getFieldWithDefault(this, 2, "");
      }
      set language(s) {
        R.Message.setField(this, 2, s);
      }
      get name() {
        return R.Message.getFieldWithDefault(this, 3, "");
      }
      set name(s) {
        R.Message.setField(this, 3, s);
      }
      get value() {
        return R.Message.getFieldWithDefault(this, 4, "");
      }
      set value(s) {
        R.Message.setField(this, 4, s);
      }
      static fromObject(s) {
        const l = new n({});
        return s.platform != null && (l.platform = s.platform), s.language != null && (l.language = s.language), s.name != null && (l.name = s.name), s.value != null && (l.value = s.value), l;
      }
      toObject() {
        const s = {};
        return this.platform != null && (s.platform = this.platform), this.language != null && (s.language = this.language), this.name != null && (s.name = this.name), this.value != null && (s.value = this.value), s;
      }
      serialize(s) {
        const l = s || new R.BinaryWriter();
        if (this.platform.length && l.writeString(1, this.platform), this.language.length && l.writeString(2, this.language), this.name.length && l.writeString(3, this.name), this.value.length && l.writeString(4, this.value), !s)
          return l.getResultBuffer();
      }
      static deserialize(s) {
        const l = s instanceof R.BinaryReader ? s : new R.BinaryReader(s), h = new n();
        for (; l.nextField() && !l.isEndGroup(); )
          switch (l.getFieldNumber()) {
            case 1:
              h.platform = l.readString();
              break;
            case 2:
              h.language = l.readString();
              break;
            case 3:
              h.name = l.readString();
              break;
            case 4:
              h.value = l.readString();
              break;
            default:
              l.skipField();
          }
        return h;
      }
      serializeBinary() {
        return this.serialize();
      }
      static deserializeBinary(s) {
        return n.deserialize(s);
      }
    }
    c.NameTable = n;
    class u extends R.Message {
      #e = [];
      constructor(s) {
        super(), R.Message.initialize(this, Array.isArray(s) ? s : [], 0, -1, [4], this.#e), !Array.isArray(s) && typeof s == "object" && ("id" in s && s.id != null && (this.id = s.id), "hash" in s && s.hash != null && (this.hash = s.hash), "fileName" in s && s.fileName != null && (this.fileName = s.fileName), "bytes" in s && s.bytes != null && (this.bytes = s.bytes), "chars" in s && s.chars != null && (this.chars = s.chars), "duration" in s && s.duration != null && (this.duration = s.duration));
      }
      get id() {
        return R.Message.getFieldWithDefault(this, 1, 0);
      }
      set id(s) {
        R.Message.setField(this, 1, s);
      }
      get hash() {
        return R.Message.getFieldWithDefault(this, 2, "");
      }
      set hash(s) {
        R.Message.setField(this, 2, s);
      }
      get fileName() {
        return R.Message.getFieldWithDefault(this, 6, "");
      }
      set fileName(s) {
        R.Message.setField(this, 6, s);
      }
      get bytes() {
        return R.Message.getFieldWithDefault(this, 3, 0);
      }
      set bytes(s) {
        R.Message.setField(this, 3, s);
      }
      get chars() {
        return R.Message.getFieldWithDefault(this, 4, []);
      }
      set chars(s) {
        R.Message.setField(this, 4, s);
      }
      get duration() {
        return R.Message.getFieldWithDefault(this, 5, 0);
      }
      set duration(s) {
        R.Message.setField(this, 5, s);
      }
      static fromObject(s) {
        const l = new u({});
        return s.id != null && (l.id = s.id), s.hash != null && (l.hash = s.hash), s.fileName != null && (l.fileName = s.fileName), s.bytes != null && (l.bytes = s.bytes), s.chars != null && (l.chars = s.chars), s.duration != null && (l.duration = s.duration), l;
      }
      toObject() {
        const s = {};
        return this.id != null && (s.id = this.id), this.hash != null && (s.hash = this.hash), this.fileName != null && (s.fileName = this.fileName), this.bytes != null && (s.bytes = this.bytes), this.chars != null && (s.chars = this.chars), this.duration != null && (s.duration = this.duration), s;
      }
      serialize(s) {
        const l = s || new R.BinaryWriter();
        if (this.id != 0 && l.writeUint32(1, this.id), this.hash.length && l.writeString(2, this.hash), this.fileName.length && l.writeString(6, this.fileName), this.bytes != 0 && l.writeUint32(3, this.bytes), this.chars.length && l.writePackedUint32(4, this.chars), this.duration != 0 && l.writeUint32(5, this.duration), !s)
          return l.getResultBuffer();
      }
      static deserialize(s) {
        const l = s instanceof R.BinaryReader ? s : new R.BinaryReader(s), h = new u();
        for (; l.nextField() && !l.isEndGroup(); )
          switch (l.getFieldNumber()) {
            case 1:
              h.id = l.readUint32();
              break;
            case 2:
              h.hash = l.readString();
              break;
            case 6:
              h.fileName = l.readString();
              break;
            case 3:
              h.bytes = l.readUint32();
              break;
            case 4:
              h.chars = l.readPackedUint32();
              break;
            case 5:
              h.duration = l.readUint32();
              break;
            default:
              l.skipField();
          }
        return h;
      }
      serializeBinary() {
        return this.serialize();
      }
      static deserializeBinary(s) {
        return u.deserialize(s);
      }
    }
    c.SubsetDetail = u;
    class _ extends R.Message {
      #e = [];
      constructor(s) {
        super(), R.Message.initialize(this, Array.isArray(s) ? s : [], 0, -1, [], this.#e), !Array.isArray(s) && typeof s == "object" && ("originSize" in s && s.originSize != null && (this.originSize = s.originSize), "bundledSize" in s && s.bundledSize != null && (this.bundledSize = s.bundledSize), "originBytes" in s && s.originBytes != null && (this.originBytes = s.originBytes), "bundledBytes" in s && s.bundledBytes != null && (this.bundledBytes = s.bundledBytes));
      }
      get originSize() {
        return R.Message.getFieldWithDefault(this, 1, 0);
      }
      set originSize(s) {
        R.Message.setField(this, 1, s);
      }
      get bundledSize() {
        return R.Message.getFieldWithDefault(this, 2, 0);
      }
      set bundledSize(s) {
        R.Message.setField(this, 2, s);
      }
      get originBytes() {
        return R.Message.getFieldWithDefault(this, 3, 0);
      }
      set originBytes(s) {
        R.Message.setField(this, 3, s);
      }
      get bundledBytes() {
        return R.Message.getFieldWithDefault(this, 4, 0);
      }
      set bundledBytes(s) {
        R.Message.setField(this, 4, s);
      }
      static fromObject(s) {
        const l = new _({});
        return s.originSize != null && (l.originSize = s.originSize), s.bundledSize != null && (l.bundledSize = s.bundledSize), s.originBytes != null && (l.originBytes = s.originBytes), s.bundledBytes != null && (l.bundledBytes = s.bundledBytes), l;
      }
      toObject() {
        const s = {};
        return this.originSize != null && (s.originSize = this.originSize), this.bundledSize != null && (s.bundledSize = this.bundledSize), this.originBytes != null && (s.originBytes = this.originBytes), this.bundledBytes != null && (s.bundledBytes = this.bundledBytes), s;
      }
      serialize(s) {
        const l = s || new R.BinaryWriter();
        if (this.originSize != 0 && l.writeUint32(1, this.originSize), this.bundledSize != 0 && l.writeUint32(2, this.bundledSize), this.originBytes != 0 && l.writeUint32(3, this.originBytes), this.bundledBytes != 0 && l.writeUint32(4, this.bundledBytes), !s)
          return l.getResultBuffer();
      }
      static deserialize(s) {
        const l = s instanceof R.BinaryReader ? s : new R.BinaryReader(s), h = new _();
        for (; l.nextField() && !l.isEndGroup(); )
          switch (l.getFieldNumber()) {
            case 1:
              h.originSize = l.readUint32();
              break;
            case 2:
              h.bundledSize = l.readUint32();
              break;
            case 3:
              h.originBytes = l.readUint32();
              break;
            case 4:
              h.bundledBytes = l.readUint32();
              break;
            default:
              l.skipField();
          }
        return h;
      }
      serializeBinary() {
        return this.serialize();
      }
      static deserializeBinary(s) {
        return _.deserialize(s);
      }
    }
    c.BundleMessage = _;
    class F extends R.Message {
      #e = [];
      constructor(s) {
        super(), R.Message.initialize(this, Array.isArray(s) ? s : [], 0, -1, [], this.#e), !Array.isArray(s) && typeof s == "object" && ("family" in s && s.family != null && (this.family = s.family), "style" in s && s.style != null && (this.style = s.style), "weight" in s && s.weight != null && (this.weight = s.weight), "display" in s && s.display != null && (this.display = s.display));
      }
      get family() {
        return R.Message.getFieldWithDefault(this, 1, "");
      }
      set family(s) {
        R.Message.setField(this, 1, s);
      }
      get style() {
        return R.Message.getFieldWithDefault(this, 2, "");
      }
      set style(s) {
        R.Message.setField(this, 2, s);
      }
      get weight() {
        return R.Message.getFieldWithDefault(this, 3, "");
      }
      set weight(s) {
        R.Message.setField(this, 3, s);
      }
      get display() {
        return R.Message.getFieldWithDefault(this, 4, "");
      }
      set display(s) {
        R.Message.setField(this, 4, s);
      }
      static fromObject(s) {
        const l = new F({});
        return s.family != null && (l.family = s.family), s.style != null && (l.style = s.style), s.weight != null && (l.weight = s.weight), s.display != null && (l.display = s.display), l;
      }
      toObject() {
        const s = {};
        return this.family != null && (s.family = this.family), this.style != null && (s.style = this.style), this.weight != null && (s.weight = this.weight), this.display != null && (s.display = this.display), s;
      }
      serialize(s) {
        const l = s || new R.BinaryWriter();
        if (this.family.length && l.writeString(1, this.family), this.style.length && l.writeString(2, this.style), this.weight.length && l.writeString(3, this.weight), this.display.length && l.writeString(4, this.display), !s)
          return l.getResultBuffer();
      }
      static deserialize(s) {
        const l = s instanceof R.BinaryReader ? s : new R.BinaryReader(s), h = new F();
        for (; l.nextField() && !l.isEndGroup(); )
          switch (l.getFieldNumber()) {
            case 1:
              h.family = l.readString();
              break;
            case 2:
              h.style = l.readString();
              break;
            case 3:
              h.weight = l.readString();
              break;
            case 4:
              h.display = l.readString();
              break;
            default:
              l.skipField();
          }
        return h;
      }
      serializeBinary() {
        return this.serialize();
      }
      static deserializeBinary(s) {
        return F.deserialize(s);
      }
    }
    c.Css = F;
  })(o = e.OutputReport || (e.OutputReport = {}));
})(Rt || (Rt = {}));
var Ce = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function al(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Si = { exports: {} }, Ht = {}, Ft = {};
Object.defineProperty(Ft, "__esModule", { value: !0 });
Ft.constants = void 0;
Ft.constants = {
  O_RDONLY: 0,
  O_WRONLY: 1,
  O_RDWR: 2,
  S_IFMT: 61440,
  S_IFREG: 32768,
  S_IFDIR: 16384,
  S_IFCHR: 8192,
  S_IFBLK: 24576,
  S_IFIFO: 4096,
  S_IFLNK: 40960,
  S_IFSOCK: 49152,
  O_CREAT: 64,
  O_EXCL: 128,
  O_NOCTTY: 256,
  O_TRUNC: 512,
  O_APPEND: 1024,
  O_DIRECTORY: 65536,
  O_NOATIME: 262144,
  O_NOFOLLOW: 131072,
  O_SYNC: 1052672,
  O_DIRECT: 16384,
  O_NONBLOCK: 2048,
  S_IRWXU: 448,
  S_IRUSR: 256,
  S_IWUSR: 128,
  S_IXUSR: 64,
  S_IRWXG: 56,
  S_IRGRP: 32,
  S_IWGRP: 16,
  S_IXGRP: 8,
  S_IRWXO: 7,
  S_IROTH: 4,
  S_IWOTH: 2,
  S_IXOTH: 1,
  F_OK: 0,
  R_OK: 4,
  W_OK: 2,
  X_OK: 1,
  UV_FS_SYMLINK_DIR: 1,
  UV_FS_SYMLINK_JUNCTION: 2,
  UV_FS_COPYFILE_EXCL: 1,
  UV_FS_COPYFILE_FICLONE: 2,
  UV_FS_COPYFILE_FICLONE_FORCE: 4,
  COPYFILE_EXCL: 1,
  COPYFILE_FICLONE: 2,
  COPYFILE_FICLONE_FORCE: 4
};
var vi = {};
typeof BigInt == "function" ? vi.default = BigInt : vi.default = function() {
  throw new Error("BigInt is not supported in this environment.");
};
Object.defineProperty(Ht, "__esModule", { value: !0 });
Ht.Stats = void 0;
var Nt = Ft, ll = vi, fl = Nt.constants.S_IFMT, ul = Nt.constants.S_IFDIR, cl = Nt.constants.S_IFREG, dl = Nt.constants.S_IFBLK, hl = Nt.constants.S_IFCHR, yl = Nt.constants.S_IFLNK, pl = Nt.constants.S_IFIFO, gl = Nt.constants.S_IFSOCK, Oo = (
  /** @class */
  function() {
    function e() {
    }
    return e.build = function(t, r) {
      r === void 0 && (r = !1);
      var i = new e(), o = t.uid, c = t.gid, n = t.atime, u = t.mtime, _ = t.ctime, F = r ? ll.default : function(s) {
        return s;
      };
      i.uid = F(o), i.gid = F(c), i.rdev = F(0), i.blksize = F(4096), i.ino = F(t.ino), i.size = F(t.getSize()), i.blocks = F(1), i.atime = n, i.mtime = u, i.ctime = _, i.birthtime = _, i.atimeMs = F(n.getTime()), i.mtimeMs = F(u.getTime());
      var d = F(_.getTime());
      return i.ctimeMs = d, i.birthtimeMs = d, i.dev = F(0), i.mode = F(t.mode), i.nlink = F(t.nlink), i;
    }, e.prototype._checkModeProperty = function(t) {
      return (Number(this.mode) & fl) === t;
    }, e.prototype.isDirectory = function() {
      return this._checkModeProperty(ul);
    }, e.prototype.isFile = function() {
      return this._checkModeProperty(cl);
    }, e.prototype.isBlockDevice = function() {
      return this._checkModeProperty(dl);
    }, e.prototype.isCharacterDevice = function() {
      return this._checkModeProperty(hl);
    }, e.prototype.isSymbolicLink = function() {
      return this._checkModeProperty(yl);
    }, e.prototype.isFIFO = function() {
      return this._checkModeProperty(pl);
    }, e.prototype.isSocket = function() {
      return this._checkModeProperty(gl);
    }, e;
  }()
);
Ht.Stats = Oo;
Ht.default = Oo;
var yr = {}, zi = {}, Tn = {}, yt = {}, ml = typeof bs == "function" ? bs : /* @__PURE__ */ function() {
  if (typeof __webpack_public_path__ < "u")
    try {
      return __non_webpack_require__("buffer").Buffer;
    } catch {
      throw new Error('The current runtime does not support "Buffer". Consider using buffer polyfill to make sure `globalThis.Buffer` is defined.');
    }
  else
    try {
      return require("buffer").Buffer;
    } catch {
      throw new Error('The current runtime does not support "Buffer". Consider using buffer polyfill to make sure `globalThis.Buffer` is defined.');
    }
}();
yt.Buffer = ml;
(function(e) {
  var t = Ce && Ce.__spreadArray || function(n, u, _) {
    if (_ || arguments.length === 2) for (var F = 0, d = u.length, s; F < d; F++)
      (s || !(F in u)) && (s || (s = Array.prototype.slice.call(u, 0, F)), s[F] = u[F]);
    return n.concat(s || Array.prototype.slice.call(u));
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.bufferFrom = e.bufferAllocUnsafe = e.Buffer = void 0;
  var r = yt;
  Object.defineProperty(e, "Buffer", { enumerable: !0, get: function() {
    return r.Buffer;
  } });
  function i(n) {
    for (var u = [], _ = 1; _ < arguments.length; _++)
      u[_ - 1] = arguments[_];
    return new (r.Buffer.bind.apply(r.Buffer, t([void 0, n], u, !1)))();
  }
  var o = r.Buffer.allocUnsafe || i;
  e.bufferAllocUnsafe = o;
  var c = r.Buffer.from || i;
  e.bufferFrom = c;
})(Tn);
var Vi = {};
function Do(e, t) {
  if (!e)
    throw new Error(t || "AssertionError");
}
Do.strictEqual = function(e, t, r) {
  if (!Object.is(e, t))
    throw new Error(r || "AssertionError");
};
var bl = Do, Bo = { exports: {} }, Le = Bo.exports = {}, ut, ct;
function Ei() {
  throw new Error("setTimeout has not been defined");
}
function Ai() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? ut = setTimeout : ut = Ei;
  } catch {
    ut = Ei;
  }
  try {
    typeof clearTimeout == "function" ? ct = clearTimeout : ct = Ai;
  } catch {
    ct = Ai;
  }
})();
function Po(e) {
  if (ut === setTimeout)
    return setTimeout(e, 0);
  if ((ut === Ei || !ut) && setTimeout)
    return ut = setTimeout, setTimeout(e, 0);
  try {
    return ut(e, 0);
  } catch {
    try {
      return ut.call(null, e, 0);
    } catch {
      return ut.call(this, e, 0);
    }
  }
}
function wl(e) {
  if (ct === clearTimeout)
    return clearTimeout(e);
  if ((ct === Ai || !ct) && clearTimeout)
    return ct = clearTimeout, clearTimeout(e);
  try {
    return ct(e);
  } catch {
    try {
      return ct.call(null, e);
    } catch {
      return ct.call(this, e);
    }
  }
}
var gt = [], sr = !1, Wt, ln = -1;
function _l() {
  !sr || !Wt || (sr = !1, Wt.length ? gt = Wt.concat(gt) : ln = -1, gt.length && ko());
}
function ko() {
  if (!sr) {
    var e = Po(_l);
    sr = !0;
    for (var t = gt.length; t; ) {
      for (Wt = gt, gt = []; ++ln < t; )
        Wt && Wt[ln].run();
      ln = -1, t = gt.length;
    }
    Wt = null, sr = !1, wl(e);
  }
}
Le.nextTick = function(e) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var r = 1; r < arguments.length; r++)
      t[r - 1] = arguments[r];
  gt.push(new Mo(e, t)), gt.length === 1 && !sr && Po(ko);
};
function Mo(e, t) {
  this.fun = e, this.array = t;
}
Mo.prototype.run = function() {
  this.fun.apply(null, this.array);
};
Le.title = "browser";
Le.browser = !0;
Le.env = {};
Le.argv = [];
Le.version = "";
Le.versions = {};
function wt() {
}
Le.on = wt;
Le.addListener = wt;
Le.once = wt;
Le.off = wt;
Le.removeListener = wt;
Le.removeAllListeners = wt;
Le.emit = wt;
Le.prependListener = wt;
Le.prependOnceListener = wt;
Le.listeners = function(e) {
  return [];
};
Le.binding = function(e) {
  throw new Error("process.binding is not supported");
};
Le.cwd = function() {
  return "/";
};
Le.chdir = function(e) {
  throw new Error("process.chdir is not supported");
};
Le.umask = function() {
  return 0;
};
var _t = Bo.exports, tt = /* @__PURE__ */ al(_t), Gi = {}, Co = {}, Lo = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var t = {}, r = Symbol("test"), i = Object(r);
  if (typeof r == "string" || Object.prototype.toString.call(r) !== "[object Symbol]" || Object.prototype.toString.call(i) !== "[object Symbol]")
    return !1;
  var o = 42;
  t[r] = o;
  for (r in t)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
    return !1;
  var c = Object.getOwnPropertySymbols(t);
  if (c.length !== 1 || c[0] !== r || !Object.prototype.propertyIsEnumerable.call(t, r))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var n = Object.getOwnPropertyDescriptor(t, r);
    if (n.value !== o || n.enumerable !== !0)
      return !1;
  }
  return !0;
}, Sl = Lo, Ki = function() {
  return Sl() && !!Symbol.toStringTag;
}, ws = typeof Symbol < "u" && Symbol, vl = Lo, El = function() {
  return typeof ws != "function" || typeof Symbol != "function" || typeof ws("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : vl();
}, _s = {
  foo: {}
}, Al = Object, Tl = function() {
  return { __proto__: _s }.foo === _s.foo && !({ __proto__: null } instanceof Al);
}, Rl = "Function.prototype.bind called on incompatible ", Il = Object.prototype.toString, Fl = Math.max, Nl = "[object Function]", Ss = function(t, r) {
  for (var i = [], o = 0; o < t.length; o += 1)
    i[o] = t[o];
  for (var c = 0; c < r.length; c += 1)
    i[c + t.length] = r[c];
  return i;
}, Ol = function(t, r) {
  for (var i = [], o = r, c = 0; o < t.length; o += 1, c += 1)
    i[c] = t[o];
  return i;
}, Dl = function(e, t) {
  for (var r = "", i = 0; i < e.length; i += 1)
    r += e[i], i + 1 < e.length && (r += t);
  return r;
}, Bl = function(t) {
  var r = this;
  if (typeof r != "function" || Il.apply(r) !== Nl)
    throw new TypeError(Rl + r);
  for (var i = Ol(arguments, 1), o, c = function() {
    if (this instanceof o) {
      var d = r.apply(
        this,
        Ss(i, arguments)
      );
      return Object(d) === d ? d : this;
    }
    return r.apply(
      t,
      Ss(i, arguments)
    );
  }, n = Fl(0, r.length - i.length), u = [], _ = 0; _ < n; _++)
    u[_] = "$" + _;
  if (o = Function("binder", "return function (" + Dl(u, ",") + "){ return binder.apply(this,arguments); }")(c), r.prototype) {
    var F = function() {
    };
    F.prototype = r.prototype, o.prototype = new F(), F.prototype = null;
  }
  return o;
}, Pl = Bl, Yi = Function.prototype.bind || Pl, kl = Function.prototype.call, Ml = Object.prototype.hasOwnProperty, Cl = Yi, Ll = Cl.call(kl, Ml), Ee, cr = SyntaxError, Uo = Function, or = TypeError, Vn = function(e) {
  try {
    return Uo('"use strict"; return (' + e + ").constructor;")();
  } catch {
  }
}, jt = Object.getOwnPropertyDescriptor;
if (jt)
  try {
    jt({}, "");
  } catch {
    jt = null;
  }
var Gn = function() {
  throw new or();
}, Ul = jt ? function() {
  try {
    return arguments.callee, Gn;
  } catch {
    try {
      return jt(arguments, "callee").get;
    } catch {
      return Gn;
    }
  }
}() : Gn, Xt = El(), Wl = Tl(), je = Object.getPrototypeOf || (Wl ? function(e) {
  return e.__proto__;
} : null), er = {}, jl = typeof Uint8Array > "u" || !je ? Ee : je(Uint8Array), $t = {
  "%AggregateError%": typeof AggregateError > "u" ? Ee : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? Ee : ArrayBuffer,
  "%ArrayIteratorPrototype%": Xt && je ? je([][Symbol.iterator]()) : Ee,
  "%AsyncFromSyncIteratorPrototype%": Ee,
  "%AsyncFunction%": er,
  "%AsyncGenerator%": er,
  "%AsyncGeneratorFunction%": er,
  "%AsyncIteratorPrototype%": er,
  "%Atomics%": typeof Atomics > "u" ? Ee : Atomics,
  "%BigInt%": typeof BigInt > "u" ? Ee : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? Ee : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? Ee : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? Ee : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? Ee : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? Ee : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? Ee : FinalizationRegistry,
  "%Function%": Uo,
  "%GeneratorFunction%": er,
  "%Int8Array%": typeof Int8Array > "u" ? Ee : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? Ee : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? Ee : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": Xt && je ? je(je([][Symbol.iterator]())) : Ee,
  "%JSON%": typeof JSON == "object" ? JSON : Ee,
  "%Map%": typeof Map > "u" ? Ee : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !Xt || !je ? Ee : je((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? Ee : Promise,
  "%Proxy%": typeof Proxy > "u" ? Ee : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? Ee : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? Ee : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !Xt || !je ? Ee : je((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? Ee : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": Xt && je ? je(""[Symbol.iterator]()) : Ee,
  "%Symbol%": Xt ? Symbol : Ee,
  "%SyntaxError%": cr,
  "%ThrowTypeError%": Ul,
  "%TypedArray%": jl,
  "%TypeError%": or,
  "%Uint8Array%": typeof Uint8Array > "u" ? Ee : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? Ee : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? Ee : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? Ee : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap > "u" ? Ee : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? Ee : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? Ee : WeakSet
};
if (je)
  try {
    null.error;
  } catch (e) {
    var $l = je(je(e));
    $t["%Error.prototype%"] = $l;
  }
var xl = function e(t) {
  var r;
  if (t === "%AsyncFunction%")
    r = Vn("async function () {}");
  else if (t === "%GeneratorFunction%")
    r = Vn("function* () {}");
  else if (t === "%AsyncGeneratorFunction%")
    r = Vn("async function* () {}");
  else if (t === "%AsyncGenerator%") {
    var i = e("%AsyncGeneratorFunction%");
    i && (r = i.prototype);
  } else if (t === "%AsyncIteratorPrototype%") {
    var o = e("%AsyncGenerator%");
    o && je && (r = je(o.prototype));
  }
  return $t[t] = r, r;
}, vs = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, Lr = Yi, gn = Ll, Hl = Lr.call(Function.call, Array.prototype.concat), zl = Lr.call(Function.apply, Array.prototype.splice), Es = Lr.call(Function.call, String.prototype.replace), mn = Lr.call(Function.call, String.prototype.slice), Vl = Lr.call(Function.call, RegExp.prototype.exec), Gl = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, Kl = /\\(\\)?/g, Yl = function(t) {
  var r = mn(t, 0, 1), i = mn(t, -1);
  if (r === "%" && i !== "%")
    throw new cr("invalid intrinsic syntax, expected closing `%`");
  if (i === "%" && r !== "%")
    throw new cr("invalid intrinsic syntax, expected opening `%`");
  var o = [];
  return Es(t, Gl, function(c, n, u, _) {
    o[o.length] = u ? Es(_, Kl, "$1") : n || c;
  }), o;
}, ql = function(t, r) {
  var i = t, o;
  if (gn(vs, i) && (o = vs[i], i = "%" + o[0] + "%"), gn($t, i)) {
    var c = $t[i];
    if (c === er && (c = xl(i)), typeof c > "u" && !r)
      throw new or("intrinsic " + t + " exists, but is not available. Please file an issue!");
    return {
      alias: o,
      name: i,
      value: c
    };
  }
  throw new cr("intrinsic " + t + " does not exist!");
}, pr = function(t, r) {
  if (typeof t != "string" || t.length === 0)
    throw new or("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof r != "boolean")
    throw new or('"allowMissing" argument must be a boolean');
  if (Vl(/^%?[^%]*%?$/, t) === null)
    throw new cr("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var i = Yl(t), o = i.length > 0 ? i[0] : "", c = ql("%" + o + "%", r), n = c.name, u = c.value, _ = !1, F = c.alias;
  F && (o = F[0], zl(i, Hl([0, 1], F)));
  for (var d = 1, s = !0; d < i.length; d += 1) {
    var l = i[d], h = mn(l, 0, 1), b = mn(l, -1);
    if ((h === '"' || h === "'" || h === "`" || b === '"' || b === "'" || b === "`") && h !== b)
      throw new cr("property names with quotes must have matching quotes");
    if ((l === "constructor" || !s) && (_ = !0), o += "." + l, n = "%" + o + "%", gn($t, n))
      u = $t[n];
    else if (u != null) {
      if (!(l in u)) {
        if (!r)
          throw new or("base intrinsic for " + t + " exists, but the property is not available.");
        return;
      }
      if (jt && d + 1 >= i.length) {
        var p = jt(u, l);
        s = !!p, s && "get" in p && !("originalValue" in p.get) ? u = p.get : u = u[l];
      } else
        s = gn(u, l), u = u[l];
      s && !_ && ($t[n] = u);
    }
  }
  return u;
}, Wo = { exports: {} }, Jl = pr, Ti = Jl("%Object.defineProperty%", !0), Ri = function() {
  if (Ti)
    try {
      return Ti({}, "a", { value: 1 }), !0;
    } catch {
      return !1;
    }
  return !1;
};
Ri.hasArrayLengthDefineBug = function() {
  if (!Ri())
    return null;
  try {
    return Ti([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var jo = Ri, Xl = pr, fn = Xl("%Object.getOwnPropertyDescriptor%", !0);
if (fn)
  try {
    fn([], "length");
  } catch {
    fn = null;
  }
var qi = fn, Zl = jo(), Ji = pr, Pr = Zl && Ji("%Object.defineProperty%", !0);
if (Pr)
  try {
    Pr({}, "a", { value: 1 });
  } catch {
    Pr = !1;
  }
var Ql = Ji("%SyntaxError%"), Zt = Ji("%TypeError%"), As = qi, ef = function(t, r, i) {
  if (!t || typeof t != "object" && typeof t != "function")
    throw new Zt("`obj` must be an object or a function`");
  if (typeof r != "string" && typeof r != "symbol")
    throw new Zt("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new Zt("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new Zt("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new Zt("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new Zt("`loose`, if provided, must be a boolean");
  var o = arguments.length > 3 ? arguments[3] : null, c = arguments.length > 4 ? arguments[4] : null, n = arguments.length > 5 ? arguments[5] : null, u = arguments.length > 6 ? arguments[6] : !1, _ = !!As && As(t, r);
  if (Pr)
    Pr(t, r, {
      configurable: n === null && _ ? _.configurable : !n,
      enumerable: o === null && _ ? _.enumerable : !o,
      value: i,
      writable: c === null && _ ? _.writable : !c
    });
  else if (u || !o && !c && !n)
    t[r] = i;
  else
    throw new Ql("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, $o = pr, Ts = ef, tf = jo(), Rs = qi, Is = $o("%TypeError%"), rf = $o("%Math.floor%"), nf = function(t, r) {
  if (typeof t != "function")
    throw new Is("`fn` is not a function");
  if (typeof r != "number" || r < 0 || r > 4294967295 || rf(r) !== r)
    throw new Is("`length` must be a positive 32-bit integer");
  var i = arguments.length > 2 && !!arguments[2], o = !0, c = !0;
  if ("length" in t && Rs) {
    var n = Rs(t, "length");
    n && !n.configurable && (o = !1), n && !n.writable && (c = !1);
  }
  return (o || c || !i) && (tf ? Ts(t, "length", r, !0, !0) : Ts(t, "length", r)), t;
};
(function(e) {
  var t = Yi, r = pr, i = nf, o = r("%TypeError%"), c = r("%Function.prototype.apply%"), n = r("%Function.prototype.call%"), u = r("%Reflect.apply%", !0) || t.call(n, c), _ = r("%Object.defineProperty%", !0), F = r("%Math.max%");
  if (_)
    try {
      _({}, "a", { value: 1 });
    } catch {
      _ = null;
    }
  e.exports = function(l) {
    if (typeof l != "function")
      throw new o("a function is required");
    var h = u(t, n, arguments);
    return i(
      h,
      1 + F(0, l.length - (arguments.length - 1)),
      !0
    );
  };
  var d = function() {
    return u(t, c, arguments);
  };
  _ ? _(e.exports, "apply", { value: d }) : e.exports.apply = d;
})(Wo);
var xo = Wo.exports, Ho = pr, zo = xo, sf = zo(Ho("String.prototype.indexOf")), Vo = function(t, r) {
  var i = Ho(t, !!r);
  return typeof i == "function" && sf(t, ".prototype.") > -1 ? zo(i) : i;
}, of = Ki(), af = Vo, Ii = af("Object.prototype.toString"), Rn = function(t) {
  return of && t && typeof t == "object" && Symbol.toStringTag in t ? !1 : Ii(t) === "[object Arguments]";
}, Go = function(t) {
  return Rn(t) ? !0 : t !== null && typeof t == "object" && typeof t.length == "number" && t.length >= 0 && Ii(t) !== "[object Array]" && Ii(t.callee) === "[object Function]";
}, lf = function() {
  return Rn(arguments);
}();
Rn.isLegacyArguments = Go;
var ff = lf ? Rn : Go, uf = Object.prototype.toString, cf = Function.prototype.toString, df = /^\s*(?:function)?\*/, Ko = Ki(), Kn = Object.getPrototypeOf, hf = function() {
  if (!Ko)
    return !1;
  try {
    return Function("return function*() {}")();
  } catch {
  }
}, Yn, yf = function(t) {
  if (typeof t != "function")
    return !1;
  if (df.test(cf.call(t)))
    return !0;
  if (!Ko) {
    var r = uf.call(t);
    return r === "[object GeneratorFunction]";
  }
  if (!Kn)
    return !1;
  if (typeof Yn > "u") {
    var i = hf();
    Yn = i ? Kn(i) : !1;
  }
  return Kn(t) === Yn;
}, Yo = Function.prototype.toString, nr = typeof Reflect == "object" && Reflect !== null && Reflect.apply, Fi, un;
if (typeof nr == "function" && typeof Object.defineProperty == "function")
  try {
    Fi = Object.defineProperty({}, "length", {
      get: function() {
        throw un;
      }
    }), un = {}, nr(function() {
      throw 42;
    }, null, Fi);
  } catch (e) {
    e !== un && (nr = null);
  }
else
  nr = null;
var pf = /^\s*class\b/, Ni = function(t) {
  try {
    var r = Yo.call(t);
    return pf.test(r);
  } catch {
    return !1;
  }
}, qn = function(t) {
  try {
    return Ni(t) ? !1 : (Yo.call(t), !0);
  } catch {
    return !1;
  }
}, cn = Object.prototype.toString, gf = "[object Object]", mf = "[object Function]", bf = "[object GeneratorFunction]", wf = "[object HTMLAllCollection]", _f = "[object HTML document.all class]", Sf = "[object HTMLCollection]", vf = typeof Symbol == "function" && !!Symbol.toStringTag, Ef = !(0 in [,]), Oi = function() {
  return !1;
};
if (typeof document == "object") {
  var Af = document.all;
  cn.call(Af) === cn.call(document.all) && (Oi = function(t) {
    if ((Ef || !t) && (typeof t > "u" || typeof t == "object"))
      try {
        var r = cn.call(t);
        return (r === wf || r === _f || r === Sf || r === gf) && t("") == null;
      } catch {
      }
    return !1;
  });
}
var Tf = nr ? function(t) {
  if (Oi(t))
    return !0;
  if (!t || typeof t != "function" && typeof t != "object")
    return !1;
  try {
    nr(t, null, Fi);
  } catch (r) {
    if (r !== un)
      return !1;
  }
  return !Ni(t) && qn(t);
} : function(t) {
  if (Oi(t))
    return !0;
  if (!t || typeof t != "function" && typeof t != "object")
    return !1;
  if (vf)
    return qn(t);
  if (Ni(t))
    return !1;
  var r = cn.call(t);
  return r !== mf && r !== bf && !/^\[object HTML/.test(r) ? !1 : qn(t);
}, Rf = Tf, If = Object.prototype.toString, qo = Object.prototype.hasOwnProperty, Ff = function(t, r, i) {
  for (var o = 0, c = t.length; o < c; o++)
    qo.call(t, o) && (i == null ? r(t[o], o, t) : r.call(i, t[o], o, t));
}, Nf = function(t, r, i) {
  for (var o = 0, c = t.length; o < c; o++)
    i == null ? r(t.charAt(o), o, t) : r.call(i, t.charAt(o), o, t);
}, Of = function(t, r, i) {
  for (var o in t)
    qo.call(t, o) && (i == null ? r(t[o], o, t) : r.call(i, t[o], o, t));
}, Df = function(t, r, i) {
  if (!Rf(r))
    throw new TypeError("iterator must be a function");
  var o;
  arguments.length >= 3 && (o = i), If.call(t) === "[object Array]" ? Ff(t, r, o) : typeof t == "string" ? Nf(t, r, o) : Of(t, r, o);
}, Bf = Df, Jn = [
  "BigInt64Array",
  "BigUint64Array",
  "Float32Array",
  "Float64Array",
  "Int16Array",
  "Int32Array",
  "Int8Array",
  "Uint16Array",
  "Uint32Array",
  "Uint8Array",
  "Uint8ClampedArray"
], Pf = typeof globalThis > "u" ? Ce : globalThis, kf = function() {
  for (var t = [], r = 0; r < Jn.length; r++)
    typeof Pf[Jn[r]] == "function" && (t[t.length] = Jn[r]);
  return t;
}, bn = Bf, Mf = kf, Fs = xo, Xi = Vo, dn = qi, Cf = Xi("Object.prototype.toString"), Jo = Ki(), Ns = typeof globalThis > "u" ? Ce : globalThis, Di = Mf(), Zi = Xi("String.prototype.slice"), Xn = Object.getPrototypeOf, Lf = Xi("Array.prototype.indexOf", !0) || function(t, r) {
  for (var i = 0; i < t.length; i += 1)
    if (t[i] === r)
      return i;
  return -1;
}, wn = { __proto__: null };
Jo && dn && Xn ? bn(Di, function(e) {
  var t = new Ns[e]();
  if (Symbol.toStringTag in t) {
    var r = Xn(t), i = dn(r, Symbol.toStringTag);
    if (!i) {
      var o = Xn(r);
      i = dn(o, Symbol.toStringTag);
    }
    wn["$" + e] = Fs(i.get);
  }
}) : bn(Di, function(e) {
  var t = new Ns[e](), r = t.slice || t.set;
  r && (wn["$" + e] = Fs(r));
});
var Uf = function(t) {
  var r = !1;
  return bn(wn, function(i, o) {
    if (!r)
      try {
        "$" + i(t) === o && (r = Zi(o, 1));
      } catch {
      }
  }), r;
}, Wf = function(t) {
  var r = !1;
  return bn(wn, function(i, o) {
    if (!r)
      try {
        i(t), r = Zi(o, 1);
      } catch {
      }
  }), r;
}, Xo = function(t) {
  if (!t || typeof t != "object")
    return !1;
  if (!Jo) {
    var r = Zi(Cf(t), 8, -1);
    return Lf(Di, r) > -1 ? r : r !== "Object" ? !1 : Wf(t);
  }
  return dn ? Uf(t) : null;
}, jf = Xo, $f = function(t) {
  return !!jf(t);
};
(function(e) {
  var t = ff, r = yf, i = Xo, o = $f;
  function c(L) {
    return L.call.bind(L);
  }
  var n = typeof BigInt < "u", u = typeof Symbol < "u", _ = c(Object.prototype.toString), F = c(Number.prototype.valueOf), d = c(String.prototype.valueOf), s = c(Boolean.prototype.valueOf);
  if (n)
    var l = c(BigInt.prototype.valueOf);
  if (u)
    var h = c(Symbol.prototype.valueOf);
  function b(L, Se) {
    if (typeof L != "object")
      return !1;
    try {
      return Se(L), !0;
    } catch {
      return !1;
    }
  }
  e.isArgumentsObject = t, e.isGeneratorFunction = r, e.isTypedArray = o;
  function p(L) {
    return typeof Promise < "u" && L instanceof Promise || L !== null && typeof L == "object" && typeof L.then == "function" && typeof L.catch == "function";
  }
  e.isPromise = p;
  function S(L) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(L) : o(L) || U(L);
  }
  e.isArrayBufferView = S;
  function E(L) {
    return i(L) === "Uint8Array";
  }
  e.isUint8Array = E;
  function v(L) {
    return i(L) === "Uint8ClampedArray";
  }
  e.isUint8ClampedArray = v;
  function m(L) {
    return i(L) === "Uint16Array";
  }
  e.isUint16Array = m;
  function N(L) {
    return i(L) === "Uint32Array";
  }
  e.isUint32Array = N;
  function I(L) {
    return i(L) === "Int8Array";
  }
  e.isInt8Array = I;
  function M(L) {
    return i(L) === "Int16Array";
  }
  e.isInt16Array = M;
  function H(L) {
    return i(L) === "Int32Array";
  }
  e.isInt32Array = H;
  function x(L) {
    return i(L) === "Float32Array";
  }
  e.isFloat32Array = x;
  function Y(L) {
    return i(L) === "Float64Array";
  }
  e.isFloat64Array = Y;
  function X(L) {
    return i(L) === "BigInt64Array";
  }
  e.isBigInt64Array = X;
  function oe(L) {
    return i(L) === "BigUint64Array";
  }
  e.isBigUint64Array = oe;
  function Z(L) {
    return _(L) === "[object Map]";
  }
  Z.working = typeof Map < "u" && Z(/* @__PURE__ */ new Map());
  function W(L) {
    return typeof Map > "u" ? !1 : Z.working ? Z(L) : L instanceof Map;
  }
  e.isMap = W;
  function ae(L) {
    return _(L) === "[object Set]";
  }
  ae.working = typeof Set < "u" && ae(/* @__PURE__ */ new Set());
  function ie(L) {
    return typeof Set > "u" ? !1 : ae.working ? ae(L) : L instanceof Set;
  }
  e.isSet = ie;
  function ne(L) {
    return _(L) === "[object WeakMap]";
  }
  ne.working = typeof WeakMap < "u" && ne(/* @__PURE__ */ new WeakMap());
  function we(L) {
    return typeof WeakMap > "u" ? !1 : ne.working ? ne(L) : L instanceof WeakMap;
  }
  e.isWeakMap = we;
  function me(L) {
    return _(L) === "[object WeakSet]";
  }
  me.working = typeof WeakSet < "u" && me(/* @__PURE__ */ new WeakSet());
  function _e(L) {
    return me(L);
  }
  e.isWeakSet = _e;
  function pe(L) {
    return _(L) === "[object ArrayBuffer]";
  }
  pe.working = typeof ArrayBuffer < "u" && pe(new ArrayBuffer());
  function B(L) {
    return typeof ArrayBuffer > "u" ? !1 : pe.working ? pe(L) : L instanceof ArrayBuffer;
  }
  e.isArrayBuffer = B;
  function j(L) {
    return _(L) === "[object DataView]";
  }
  j.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && j(new DataView(new ArrayBuffer(1), 0, 1));
  function U(L) {
    return typeof DataView > "u" ? !1 : j.working ? j(L) : L instanceof DataView;
  }
  e.isDataView = U;
  var q = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
  function fe(L) {
    return _(L) === "[object SharedArrayBuffer]";
  }
  function ge(L) {
    return typeof q > "u" ? !1 : (typeof fe.working > "u" && (fe.working = fe(new q())), fe.working ? fe(L) : L instanceof q);
  }
  e.isSharedArrayBuffer = ge;
  function de(L) {
    return _(L) === "[object AsyncFunction]";
  }
  e.isAsyncFunction = de;
  function he(L) {
    return _(L) === "[object Map Iterator]";
  }
  e.isMapIterator = he;
  function ye(L) {
    return _(L) === "[object Set Iterator]";
  }
  e.isSetIterator = ye;
  function Fe(L) {
    return _(L) === "[object Generator]";
  }
  e.isGeneratorObject = Fe;
  function ze(L) {
    return _(L) === "[object WebAssembly.Module]";
  }
  e.isWebAssemblyCompiledModule = ze;
  function Ge(L) {
    return b(L, F);
  }
  e.isNumberObject = Ge;
  function D(L) {
    return b(L, d);
  }
  e.isStringObject = D;
  function k(L) {
    return b(L, s);
  }
  e.isBooleanObject = k;
  function V(L) {
    return n && b(L, l);
  }
  e.isBigIntObject = V;
  function te(L) {
    return u && b(L, h);
  }
  e.isSymbolObject = te;
  function re(L) {
    return Ge(L) || D(L) || k(L) || V(L) || te(L);
  }
  e.isBoxedPrimitive = re;
  function Q(L) {
    return typeof Uint8Array < "u" && (B(L) || ge(L));
  }
  e.isAnyArrayBuffer = Q, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(L) {
    Object.defineProperty(e, L, {
      enumerable: !1,
      value: function() {
        throw new Error(L + " is not supported in userland");
      }
    });
  });
})(Co);
var xf = function(t) {
  return t && typeof t == "object" && typeof t.copy == "function" && typeof t.fill == "function" && typeof t.readUInt8 == "function";
}, Bi = { exports: {} };
typeof Object.create == "function" ? Bi.exports = function(t, r) {
  r && (t.super_ = r, t.prototype = Object.create(r.prototype, {
    constructor: {
      value: t,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : Bi.exports = function(t, r) {
  if (r) {
    t.super_ = r;
    var i = function() {
    };
    i.prototype = r.prototype, t.prototype = new i(), t.prototype.constructor = t;
  }
};
var Hf = Bi.exports;
(function(e) {
  var t = Object.getOwnPropertyDescriptors || function(j) {
    for (var U = Object.keys(j), q = {}, fe = 0; fe < U.length; fe++)
      q[U[fe]] = Object.getOwnPropertyDescriptor(j, U[fe]);
    return q;
  }, r = /%[sdj%]/g;
  e.format = function(B) {
    if (!N(B)) {
      for (var j = [], U = 0; U < arguments.length; U++)
        j.push(c(arguments[U]));
      return j.join(" ");
    }
    for (var U = 1, q = arguments, fe = q.length, ge = String(B).replace(r, function(he) {
      if (he === "%%") return "%";
      if (U >= fe) return he;
      switch (he) {
        case "%s":
          return String(q[U++]);
        case "%d":
          return Number(q[U++]);
        case "%j":
          try {
            return JSON.stringify(q[U++]);
          } catch {
            return "[Circular]";
          }
        default:
          return he;
      }
    }), de = q[U]; U < fe; de = q[++U])
      E(de) || !x(de) ? ge += " " + de : ge += " " + c(de);
    return ge;
  }, e.deprecate = function(B, j) {
    if (typeof tt < "u" && tt.noDeprecation === !0)
      return B;
    if (typeof tt > "u")
      return function() {
        return e.deprecate(B, j).apply(this, arguments);
      };
    var U = !1;
    function q() {
      if (!U) {
        if (tt.throwDeprecation)
          throw new Error(j);
        tt.traceDeprecation ? console.trace(j) : console.error(j), U = !0;
      }
      return B.apply(this, arguments);
    }
    return q;
  };
  var i = {}, o = /^$/;
  e.debuglog = function(B) {
    if (B = B.toUpperCase(), !i[B])
      if (o.test(B)) {
        var j = tt.pid;
        i[B] = function() {
          var U = e.format.apply(e, arguments);
          console.error("%s %d: %s", B, j, U);
        };
      } else
        i[B] = function() {
        };
    return i[B];
  };
  function c(B, j) {
    var U = {
      seen: [],
      stylize: u
    };
    return arguments.length >= 3 && (U.depth = arguments[2]), arguments.length >= 4 && (U.colors = arguments[3]), S(j) ? U.showHidden = j : j && e._extend(U, j), M(U.showHidden) && (U.showHidden = !1), M(U.depth) && (U.depth = 2), M(U.colors) && (U.colors = !1), M(U.customInspect) && (U.customInspect = !0), U.colors && (U.stylize = n), F(U, B, U.depth);
  }
  e.inspect = c, c.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  }, c.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    // "name": intentionally not styling
    regexp: "red"
  };
  function n(B, j) {
    var U = c.styles[j];
    return U ? "\x1B[" + c.colors[U][0] + "m" + B + "\x1B[" + c.colors[U][1] + "m" : B;
  }
  function u(B, j) {
    return B;
  }
  function _(B) {
    var j = {};
    return B.forEach(function(U, q) {
      j[U] = !0;
    }), j;
  }
  function F(B, j, U) {
    if (B.customInspect && j && oe(j.inspect) && // Filter out the util module, it's inspect function is special
    j.inspect !== e.inspect && // Also filter out any prototype objects using the circular check.
    !(j.constructor && j.constructor.prototype === j)) {
      var q = j.inspect(U, B);
      return N(q) || (q = F(B, q, U)), q;
    }
    var fe = d(B, j);
    if (fe)
      return fe;
    var ge = Object.keys(j), de = _(ge);
    if (B.showHidden && (ge = Object.getOwnPropertyNames(j)), X(j) && (ge.indexOf("message") >= 0 || ge.indexOf("description") >= 0))
      return s(j);
    if (ge.length === 0) {
      if (oe(j)) {
        var he = j.name ? ": " + j.name : "";
        return B.stylize("[Function" + he + "]", "special");
      }
      if (H(j))
        return B.stylize(RegExp.prototype.toString.call(j), "regexp");
      if (Y(j))
        return B.stylize(Date.prototype.toString.call(j), "date");
      if (X(j))
        return s(j);
    }
    var ye = "", Fe = !1, ze = ["{", "}"];
    if (p(j) && (Fe = !0, ze = ["[", "]"]), oe(j)) {
      var Ge = j.name ? ": " + j.name : "";
      ye = " [Function" + Ge + "]";
    }
    if (H(j) && (ye = " " + RegExp.prototype.toString.call(j)), Y(j) && (ye = " " + Date.prototype.toUTCString.call(j)), X(j) && (ye = " " + s(j)), ge.length === 0 && (!Fe || j.length == 0))
      return ze[0] + ye + ze[1];
    if (U < 0)
      return H(j) ? B.stylize(RegExp.prototype.toString.call(j), "regexp") : B.stylize("[Object]", "special");
    B.seen.push(j);
    var D;
    return Fe ? D = l(B, j, U, de, ge) : D = ge.map(function(k) {
      return h(B, j, U, de, k, Fe);
    }), B.seen.pop(), b(D, ye, ze);
  }
  function d(B, j) {
    if (M(j))
      return B.stylize("undefined", "undefined");
    if (N(j)) {
      var U = "'" + JSON.stringify(j).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return B.stylize(U, "string");
    }
    if (m(j))
      return B.stylize("" + j, "number");
    if (S(j))
      return B.stylize("" + j, "boolean");
    if (E(j))
      return B.stylize("null", "null");
  }
  function s(B) {
    return "[" + Error.prototype.toString.call(B) + "]";
  }
  function l(B, j, U, q, fe) {
    for (var ge = [], de = 0, he = j.length; de < he; ++de)
      we(j, String(de)) ? ge.push(h(
        B,
        j,
        U,
        q,
        String(de),
        !0
      )) : ge.push("");
    return fe.forEach(function(ye) {
      ye.match(/^\d+$/) || ge.push(h(
        B,
        j,
        U,
        q,
        ye,
        !0
      ));
    }), ge;
  }
  function h(B, j, U, q, fe, ge) {
    var de, he, ye;
    if (ye = Object.getOwnPropertyDescriptor(j, fe) || { value: j[fe] }, ye.get ? ye.set ? he = B.stylize("[Getter/Setter]", "special") : he = B.stylize("[Getter]", "special") : ye.set && (he = B.stylize("[Setter]", "special")), we(q, fe) || (de = "[" + fe + "]"), he || (B.seen.indexOf(ye.value) < 0 ? (E(U) ? he = F(B, ye.value, null) : he = F(B, ye.value, U - 1), he.indexOf(`
`) > -1 && (ge ? he = he.split(`
`).map(function(Fe) {
      return "  " + Fe;
    }).join(`
`).slice(2) : he = `
` + he.split(`
`).map(function(Fe) {
      return "   " + Fe;
    }).join(`
`))) : he = B.stylize("[Circular]", "special")), M(de)) {
      if (ge && fe.match(/^\d+$/))
        return he;
      de = JSON.stringify("" + fe), de.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (de = de.slice(1, -1), de = B.stylize(de, "name")) : (de = de.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), de = B.stylize(de, "string"));
    }
    return de + ": " + he;
  }
  function b(B, j, U) {
    var q = B.reduce(function(fe, ge) {
      return ge.indexOf(`
`) >= 0, fe + ge.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return q > 60 ? U[0] + (j === "" ? "" : j + `
 `) + " " + B.join(`,
  `) + " " + U[1] : U[0] + j + " " + B.join(", ") + " " + U[1];
  }
  e.types = Co;
  function p(B) {
    return Array.isArray(B);
  }
  e.isArray = p;
  function S(B) {
    return typeof B == "boolean";
  }
  e.isBoolean = S;
  function E(B) {
    return B === null;
  }
  e.isNull = E;
  function v(B) {
    return B == null;
  }
  e.isNullOrUndefined = v;
  function m(B) {
    return typeof B == "number";
  }
  e.isNumber = m;
  function N(B) {
    return typeof B == "string";
  }
  e.isString = N;
  function I(B) {
    return typeof B == "symbol";
  }
  e.isSymbol = I;
  function M(B) {
    return B === void 0;
  }
  e.isUndefined = M;
  function H(B) {
    return x(B) && W(B) === "[object RegExp]";
  }
  e.isRegExp = H, e.types.isRegExp = H;
  function x(B) {
    return typeof B == "object" && B !== null;
  }
  e.isObject = x;
  function Y(B) {
    return x(B) && W(B) === "[object Date]";
  }
  e.isDate = Y, e.types.isDate = Y;
  function X(B) {
    return x(B) && (W(B) === "[object Error]" || B instanceof Error);
  }
  e.isError = X, e.types.isNativeError = X;
  function oe(B) {
    return typeof B == "function";
  }
  e.isFunction = oe;
  function Z(B) {
    return B === null || typeof B == "boolean" || typeof B == "number" || typeof B == "string" || typeof B == "symbol" || // ES6 symbol
    typeof B > "u";
  }
  e.isPrimitive = Z, e.isBuffer = xf;
  function W(B) {
    return Object.prototype.toString.call(B);
  }
  function ae(B) {
    return B < 10 ? "0" + B.toString(10) : B.toString(10);
  }
  var ie = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function ne() {
    var B = /* @__PURE__ */ new Date(), j = [
      ae(B.getHours()),
      ae(B.getMinutes()),
      ae(B.getSeconds())
    ].join(":");
    return [B.getDate(), ie[B.getMonth()], j].join(" ");
  }
  e.log = function() {
    console.log("%s - %s", ne(), e.format.apply(e, arguments));
  }, e.inherits = Hf, e._extend = function(B, j) {
    if (!j || !x(j)) return B;
    for (var U = Object.keys(j), q = U.length; q--; )
      B[U[q]] = j[U[q]];
    return B;
  };
  function we(B, j) {
    return Object.prototype.hasOwnProperty.call(B, j);
  }
  var me = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
  e.promisify = function(j) {
    if (typeof j != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (me && j[me]) {
      var U = j[me];
      if (typeof U != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(U, me, {
        value: U,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), U;
    }
    function U() {
      for (var q, fe, ge = new Promise(function(ye, Fe) {
        q = ye, fe = Fe;
      }), de = [], he = 0; he < arguments.length; he++)
        de.push(arguments[he]);
      de.push(function(ye, Fe) {
        ye ? fe(ye) : q(Fe);
      });
      try {
        j.apply(this, de);
      } catch (ye) {
        fe(ye);
      }
      return ge;
    }
    return Object.setPrototypeOf(U, Object.getPrototypeOf(j)), me && Object.defineProperty(U, me, {
      value: U,
      enumerable: !1,
      writable: !1,
      configurable: !0
    }), Object.defineProperties(
      U,
      t(j)
    );
  }, e.promisify.custom = me;
  function _e(B, j) {
    if (!B) {
      var U = new Error("Promise was rejected with a falsy value");
      U.reason = B, B = U;
    }
    return j(B);
  }
  function pe(B) {
    if (typeof B != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function j() {
      for (var U = [], q = 0; q < arguments.length; q++)
        U.push(arguments[q]);
      var fe = U.pop();
      if (typeof fe != "function")
        throw new TypeError("The last argument must be of type Function");
      var ge = this, de = function() {
        return fe.apply(ge, arguments);
      };
      B.apply(this, U).then(
        function(he) {
          tt.nextTick(de.bind(null, null, he));
        },
        function(he) {
          tt.nextTick(_e.bind(null, he, de));
        }
      );
    }
    return Object.setPrototypeOf(j, Object.getPrototypeOf(B)), Object.defineProperties(
      j,
      t(B)
    ), j;
  }
  e.callbackify = pe;
})(Gi);
(function(e) {
  var t = Ce && Ce.__extends || /* @__PURE__ */ function() {
    var p = function(S, E) {
      return p = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(v, m) {
        v.__proto__ = m;
      } || function(v, m) {
        for (var N in m) Object.prototype.hasOwnProperty.call(m, N) && (v[N] = m[N]);
      }, p(S, E);
    };
    return function(S, E) {
      if (typeof E != "function" && E !== null)
        throw new TypeError("Class extends value " + String(E) + " is not a constructor or null");
      p(S, E);
      function v() {
        this.constructor = S;
      }
      S.prototype = E === null ? Object.create(E) : (v.prototype = E.prototype, new v());
    };
  }();
  Object.defineProperty(e, "__esModule", { value: !0 }), e.E = e.AssertionError = e.message = e.RangeError = e.TypeError = e.Error = void 0;
  var r = bl, i = Gi, o = typeof Symbol > "u" ? "_kCode" : Symbol("code"), c = {};
  function n(p) {
    return (
      /** @class */
      function(S) {
        t(E, S);
        function E(v) {
          for (var m = [], N = 1; N < arguments.length; N++)
            m[N - 1] = arguments[N];
          var I = S.call(this, F(v, m)) || this;
          return I.code = v, I[o] = v, I.name = "".concat(S.prototype.name, " [").concat(I[o], "]"), I;
        }
        return E;
      }(p)
    );
  }
  var u = typeof globalThis < "u" ? globalThis : Ce, _ = (
    /** @class */
    function(p) {
      t(S, p);
      function S(E) {
        var v = this;
        if (typeof E != "object" || E === null)
          throw new e.TypeError("ERR_INVALID_ARG_TYPE", "options", "object");
        return E.message ? v = p.call(this, E.message) || this : v = p.call(this, "".concat(i.inspect(E.actual).slice(0, 128), " ") + "".concat(E.operator, " ").concat(i.inspect(E.expected).slice(0, 128))) || this, v.generatedMessage = !E.message, v.name = "AssertionError [ERR_ASSERTION]", v.code = "ERR_ASSERTION", v.actual = E.actual, v.expected = E.expected, v.operator = E.operator, e.Error.captureStackTrace(v, E.stackStartFunction), v;
      }
      return S;
    }(u.Error)
  );
  e.AssertionError = _;
  function F(p, S) {
    r.strictEqual(typeof p, "string");
    var E = c[p];
    r(E, "An invalid error message key was used: ".concat(p, "."));
    var v;
    if (typeof E == "function")
      v = E;
    else {
      if (v = i.format, S === void 0 || S.length === 0)
        return E;
      S.unshift(E);
    }
    return String(v.apply(null, S));
  }
  e.message = F;
  function d(p, S) {
    c[p] = typeof S == "function" ? S : String(S);
  }
  e.E = d, e.Error = n(u.Error), e.TypeError = n(u.TypeError), e.RangeError = n(u.RangeError), d("ERR_ARG_NOT_ITERABLE", "%s must be iterable"), d("ERR_ASSERTION", "%s"), d("ERR_BUFFER_OUT_OF_BOUNDS", b), d("ERR_CHILD_CLOSED_BEFORE_REPLY", "Child closed before reply received"), d("ERR_CONSOLE_WRITABLE_STREAM", "Console expects a writable stream instance for %s"), d("ERR_CPU_USAGE", "Unable to obtain cpu usage %s"), d("ERR_DNS_SET_SERVERS_FAILED", function(p, S) {
    return 'c-ares failed to set servers: "'.concat(p, '" [').concat(S, "]");
  }), d("ERR_FALSY_VALUE_REJECTION", "Promise was rejected with falsy value"), d("ERR_ENCODING_NOT_SUPPORTED", function(p) {
    return 'The "'.concat(p, '" encoding is not supported');
  }), d("ERR_ENCODING_INVALID_ENCODED_DATA", function(p) {
    return "The encoded data was not valid for encoding ".concat(p);
  }), d("ERR_HTTP_HEADERS_SENT", "Cannot render headers after they are sent to the client"), d("ERR_HTTP_INVALID_STATUS_CODE", "Invalid status code: %s"), d("ERR_HTTP_TRAILER_INVALID", "Trailers are invalid with this transfer encoding"), d("ERR_INDEX_OUT_OF_RANGE", "Index out of range"), d("ERR_INVALID_ARG_TYPE", s), d("ERR_INVALID_ARRAY_LENGTH", function(p, S, E) {
    return r.strictEqual(typeof E, "number"), 'The array "'.concat(p, '" (length ').concat(E, ") must be of length ").concat(S, ".");
  }), d("ERR_INVALID_BUFFER_SIZE", "Buffer size must be a multiple of %s"), d("ERR_INVALID_CALLBACK", "Callback must be a function"), d("ERR_INVALID_CHAR", "Invalid character in %s"), d("ERR_INVALID_CURSOR_POS", "Cannot set cursor row without setting its column"), d("ERR_INVALID_FD", '"fd" must be a positive integer: %s'), d("ERR_INVALID_FILE_URL_HOST", 'File URL host must be "localhost" or empty on %s'), d("ERR_INVALID_FILE_URL_PATH", "File URL path %s"), d("ERR_INVALID_HANDLE_TYPE", "This handle type cannot be sent"), d("ERR_INVALID_IP_ADDRESS", "Invalid IP address: %s"), d("ERR_INVALID_OPT_VALUE", function(p, S) {
    return 'The value "'.concat(String(S), '" is invalid for option "').concat(p, '"');
  }), d("ERR_INVALID_OPT_VALUE_ENCODING", function(p) {
    return 'The value "'.concat(String(p), '" is invalid for option "encoding"');
  }), d("ERR_INVALID_REPL_EVAL_CONFIG", 'Cannot specify both "breakEvalOnSigint" and "eval" for REPL'), d("ERR_INVALID_SYNC_FORK_INPUT", "Asynchronous forks do not support Buffer, Uint8Array or string input: %s"), d("ERR_INVALID_THIS", 'Value of "this" must be of type %s'), d("ERR_INVALID_TUPLE", "%s must be an iterable %s tuple"), d("ERR_INVALID_URL", "Invalid URL: %s"), d("ERR_INVALID_URL_SCHEME", function(p) {
    return "The URL must be ".concat(h(p, "scheme"));
  }), d("ERR_IPC_CHANNEL_CLOSED", "Channel closed"), d("ERR_IPC_DISCONNECTED", "IPC channel is already disconnected"), d("ERR_IPC_ONE_PIPE", "Child process can have only one IPC pipe"), d("ERR_IPC_SYNC_FORK", "IPC cannot be used with synchronous forks"), d("ERR_MISSING_ARGS", l), d("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), d("ERR_NAPI_CONS_FUNCTION", "Constructor must be a function"), d("ERR_NAPI_CONS_PROTOTYPE_OBJECT", "Constructor.prototype must be an object"), d("ERR_NO_CRYPTO", "Node.js is not compiled with OpenSSL crypto support"), d("ERR_NO_LONGER_SUPPORTED", "%s is no longer supported"), d("ERR_PARSE_HISTORY_DATA", "Could not parse history data in %s"), d("ERR_SOCKET_ALREADY_BOUND", "Socket is already bound"), d("ERR_SOCKET_BAD_PORT", "Port should be > 0 and < 65536"), d("ERR_SOCKET_BAD_TYPE", "Bad socket type specified. Valid types are: udp4, udp6"), d("ERR_SOCKET_CANNOT_SEND", "Unable to send data"), d("ERR_SOCKET_CLOSED", "Socket is closed"), d("ERR_SOCKET_DGRAM_NOT_RUNNING", "Not running"), d("ERR_STDERR_CLOSE", "process.stderr cannot be closed"), d("ERR_STDOUT_CLOSE", "process.stdout cannot be closed"), d("ERR_STREAM_WRAP", "Stream has StringDecoder set or is in objectMode"), d("ERR_TLS_CERT_ALTNAME_INVALID", "Hostname/IP does not match certificate's altnames: %s"), d("ERR_TLS_DH_PARAM_SIZE", function(p) {
    return "DH parameter size ".concat(p, " is less than 2048");
  }), d("ERR_TLS_HANDSHAKE_TIMEOUT", "TLS handshake timeout"), d("ERR_TLS_RENEGOTIATION_FAILED", "Failed to renegotiate"), d("ERR_TLS_REQUIRED_SERVER_NAME", '"servername" is required parameter for Server.addContext'), d("ERR_TLS_SESSION_ATTACK", "TSL session renegotiation attack detected"), d("ERR_TRANSFORM_ALREADY_TRANSFORMING", "Calling transform done when still transforming"), d("ERR_TRANSFORM_WITH_LENGTH_0", "Calling transform done when writableState.length != 0"), d("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s"), d("ERR_UNKNOWN_SIGNAL", "Unknown signal: %s"), d("ERR_UNKNOWN_STDIN_TYPE", "Unknown stdin file type"), d("ERR_UNKNOWN_STREAM_TYPE", "Unknown stream file type"), d("ERR_V8BREAKITERATOR", "Full ICU data not installed. See https://github.com/nodejs/node/wiki/Intl");
  function s(p, S, E) {
    r(p, "name is required");
    var v;
    S.includes("not ") ? (v = "must not be", S = S.split("not ")[1]) : v = "must be";
    var m;
    if (Array.isArray(p)) {
      var N = p.map(function(M) {
        return '"'.concat(M, '"');
      }).join(", ");
      m = "The ".concat(N, " arguments ").concat(v, " ").concat(h(S, "type"));
    } else if (p.includes(" argument"))
      m = "The ".concat(p, " ").concat(v, " ").concat(h(S, "type"));
    else {
      var I = p.includes(".") ? "property" : "argument";
      m = 'The "'.concat(p, '" ').concat(I, " ").concat(v, " ").concat(h(S, "type"));
    }
    return arguments.length >= 3 && (m += ". Received type ".concat(E !== null ? typeof E : "null")), m;
  }
  function l() {
    for (var p = [], S = 0; S < arguments.length; S++)
      p[S] = arguments[S];
    r(p.length > 0, "At least one arg needs to be specified");
    var E = "The ", v = p.length;
    switch (p = p.map(function(m) {
      return '"'.concat(m, '"');
    }), v) {
      case 1:
        E += "".concat(p[0], " argument");
        break;
      case 2:
        E += "".concat(p[0], " and ").concat(p[1], " arguments");
        break;
      default:
        E += p.slice(0, v - 1).join(", "), E += ", and ".concat(p[v - 1], " arguments");
        break;
    }
    return "".concat(E, " must be specified");
  }
  function h(p, S) {
    if (r(p, "expected is required"), r(typeof S == "string", "thing is required"), Array.isArray(p)) {
      var E = p.length;
      return r(E > 0, "At least one expected value needs to be specified"), p = p.map(function(v) {
        return String(v);
      }), E > 2 ? "one of ".concat(S, " ").concat(p.slice(0, E - 1).join(", "), ", or ") + p[E - 1] : E === 2 ? "one of ".concat(S, " ").concat(p[0], " or ").concat(p[1]) : "of ".concat(S, " ").concat(p[0]);
    } else
      return "of ".concat(S, " ").concat(String(p));
  }
  function b(p, S) {
    return S ? "Attempt to write outside buffer bounds" : '"'.concat(p, '" is outside of buffer bounds');
  }
})(Vi);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.strToEncoding = e.assertEncoding = e.ENCODING_UTF8 = void 0;
  var t = Tn, r = Vi;
  e.ENCODING_UTF8 = "utf8";
  function i(c) {
    if (c && !t.Buffer.isEncoding(c))
      throw new r.TypeError("ERR_INVALID_OPT_VALUE_ENCODING", c);
  }
  e.assertEncoding = i;
  function o(c, n) {
    return !n || n === e.ENCODING_UTF8 ? c : n === "buffer" ? new t.Buffer(c) : new t.Buffer(c).toString(n);
  }
  e.strToEncoding = o;
})(zi);
Object.defineProperty(yr, "__esModule", { value: !0 });
yr.Dirent = void 0;
var Ot = Ft, zf = zi, Vf = Ot.constants.S_IFMT, Gf = Ot.constants.S_IFDIR, Kf = Ot.constants.S_IFREG, Yf = Ot.constants.S_IFBLK, qf = Ot.constants.S_IFCHR, Jf = Ot.constants.S_IFLNK, Xf = Ot.constants.S_IFIFO, Zf = Ot.constants.S_IFSOCK, Zo = (
  /** @class */
  function() {
    function e() {
      this.name = "", this.mode = 0;
    }
    return e.build = function(t, r) {
      var i = new e(), o = t.getNode().mode;
      return i.name = (0, zf.strToEncoding)(t.getName(), r), i.mode = o, i;
    }, e.prototype._checkModeProperty = function(t) {
      return (this.mode & Vf) === t;
    }, e.prototype.isDirectory = function() {
      return this._checkModeProperty(Gf);
    }, e.prototype.isFile = function() {
      return this._checkModeProperty(Kf);
    }, e.prototype.isBlockDevice = function() {
      return this._checkModeProperty(Yf);
    }, e.prototype.isCharacterDevice = function() {
      return this._checkModeProperty(qf);
    }, e.prototype.isSymbolicLink = function() {
      return this._checkModeProperty(Jf);
    }, e.prototype.isFIFO = function() {
      return this._checkModeProperty(Xf);
    }, e.prototype.isSocket = function() {
      return this._checkModeProperty(Zf);
    }, e;
  }()
);
yr.Dirent = Zo;
yr.default = Zo;
var Qo = {};
function lt(e) {
  if (typeof e != "string")
    throw new TypeError("Path must be a string. Received " + JSON.stringify(e));
}
function Os(e, t) {
  for (var r = "", i = 0, o = -1, c = 0, n, u = 0; u <= e.length; ++u) {
    if (u < e.length)
      n = e.charCodeAt(u);
    else {
      if (n === 47)
        break;
      n = 47;
    }
    if (n === 47) {
      if (!(o === u - 1 || c === 1)) if (o !== u - 1 && c === 2) {
        if (r.length < 2 || i !== 2 || r.charCodeAt(r.length - 1) !== 46 || r.charCodeAt(r.length - 2) !== 46) {
          if (r.length > 2) {
            var _ = r.lastIndexOf("/");
            if (_ !== r.length - 1) {
              _ === -1 ? (r = "", i = 0) : (r = r.slice(0, _), i = r.length - 1 - r.lastIndexOf("/")), o = u, c = 0;
              continue;
            }
          } else if (r.length === 2 || r.length === 1) {
            r = "", i = 0, o = u, c = 0;
            continue;
          }
        }
        t && (r.length > 0 ? r += "/.." : r = "..", i = 2);
      } else
        r.length > 0 ? r += "/" + e.slice(o + 1, u) : r = e.slice(o + 1, u), i = u - o - 1;
      o = u, c = 0;
    } else n === 46 && c !== -1 ? ++c : c = -1;
  }
  return r;
}
function Qf(e, t) {
  var r = t.dir || t.root, i = t.base || (t.name || "") + (t.ext || "");
  return r ? r === t.root ? r + i : r + e + i : i;
}
var ar = {
  // path.resolve([from ...], to)
  resolve: function() {
    for (var t = "", r = !1, i, o = arguments.length - 1; o >= -1 && !r; o--) {
      var c;
      o >= 0 ? c = arguments[o] : (i === void 0 && (i = tt.cwd()), c = i), lt(c), c.length !== 0 && (t = c + "/" + t, r = c.charCodeAt(0) === 47);
    }
    return t = Os(t, !r), r ? t.length > 0 ? "/" + t : "/" : t.length > 0 ? t : ".";
  },
  normalize: function(t) {
    if (lt(t), t.length === 0) return ".";
    var r = t.charCodeAt(0) === 47, i = t.charCodeAt(t.length - 1) === 47;
    return t = Os(t, !r), t.length === 0 && !r && (t = "."), t.length > 0 && i && (t += "/"), r ? "/" + t : t;
  },
  isAbsolute: function(t) {
    return lt(t), t.length > 0 && t.charCodeAt(0) === 47;
  },
  join: function() {
    if (arguments.length === 0)
      return ".";
    for (var t, r = 0; r < arguments.length; ++r) {
      var i = arguments[r];
      lt(i), i.length > 0 && (t === void 0 ? t = i : t += "/" + i);
    }
    return t === void 0 ? "." : ar.normalize(t);
  },
  relative: function(t, r) {
    if (lt(t), lt(r), t === r || (t = ar.resolve(t), r = ar.resolve(r), t === r)) return "";
    for (var i = 1; i < t.length && t.charCodeAt(i) === 47; ++i)
      ;
    for (var o = t.length, c = o - i, n = 1; n < r.length && r.charCodeAt(n) === 47; ++n)
      ;
    for (var u = r.length, _ = u - n, F = c < _ ? c : _, d = -1, s = 0; s <= F; ++s) {
      if (s === F) {
        if (_ > F) {
          if (r.charCodeAt(n + s) === 47)
            return r.slice(n + s + 1);
          if (s === 0)
            return r.slice(n + s);
        } else c > F && (t.charCodeAt(i + s) === 47 ? d = s : s === 0 && (d = 0));
        break;
      }
      var l = t.charCodeAt(i + s), h = r.charCodeAt(n + s);
      if (l !== h)
        break;
      l === 47 && (d = s);
    }
    var b = "";
    for (s = i + d + 1; s <= o; ++s)
      (s === o || t.charCodeAt(s) === 47) && (b.length === 0 ? b += ".." : b += "/..");
    return b.length > 0 ? b + r.slice(n + d) : (n += d, r.charCodeAt(n) === 47 && ++n, r.slice(n));
  },
  _makeLong: function(t) {
    return t;
  },
  dirname: function(t) {
    if (lt(t), t.length === 0) return ".";
    for (var r = t.charCodeAt(0), i = r === 47, o = -1, c = !0, n = t.length - 1; n >= 1; --n)
      if (r = t.charCodeAt(n), r === 47) {
        if (!c) {
          o = n;
          break;
        }
      } else
        c = !1;
    return o === -1 ? i ? "/" : "." : i && o === 1 ? "//" : t.slice(0, o);
  },
  basename: function(t, r) {
    if (r !== void 0 && typeof r != "string") throw new TypeError('"ext" argument must be a string');
    lt(t);
    var i = 0, o = -1, c = !0, n;
    if (r !== void 0 && r.length > 0 && r.length <= t.length) {
      if (r.length === t.length && r === t) return "";
      var u = r.length - 1, _ = -1;
      for (n = t.length - 1; n >= 0; --n) {
        var F = t.charCodeAt(n);
        if (F === 47) {
          if (!c) {
            i = n + 1;
            break;
          }
        } else
          _ === -1 && (c = !1, _ = n + 1), u >= 0 && (F === r.charCodeAt(u) ? --u === -1 && (o = n) : (u = -1, o = _));
      }
      return i === o ? o = _ : o === -1 && (o = t.length), t.slice(i, o);
    } else {
      for (n = t.length - 1; n >= 0; --n)
        if (t.charCodeAt(n) === 47) {
          if (!c) {
            i = n + 1;
            break;
          }
        } else o === -1 && (c = !1, o = n + 1);
      return o === -1 ? "" : t.slice(i, o);
    }
  },
  extname: function(t) {
    lt(t);
    for (var r = -1, i = 0, o = -1, c = !0, n = 0, u = t.length - 1; u >= 0; --u) {
      var _ = t.charCodeAt(u);
      if (_ === 47) {
        if (!c) {
          i = u + 1;
          break;
        }
        continue;
      }
      o === -1 && (c = !1, o = u + 1), _ === 46 ? r === -1 ? r = u : n !== 1 && (n = 1) : r !== -1 && (n = -1);
    }
    return r === -1 || o === -1 || // We saw a non-dot character immediately before the dot
    n === 0 || // The (right-most) trimmed path component is exactly '..'
    n === 1 && r === o - 1 && r === i + 1 ? "" : t.slice(r, o);
  },
  format: function(t) {
    if (t === null || typeof t != "object")
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t);
    return Qf("/", t);
  },
  parse: function(t) {
    lt(t);
    var r = { root: "", dir: "", base: "", ext: "", name: "" };
    if (t.length === 0) return r;
    var i = t.charCodeAt(0), o = i === 47, c;
    o ? (r.root = "/", c = 1) : c = 0;
    for (var n = -1, u = 0, _ = -1, F = !0, d = t.length - 1, s = 0; d >= c; --d) {
      if (i = t.charCodeAt(d), i === 47) {
        if (!F) {
          u = d + 1;
          break;
        }
        continue;
      }
      _ === -1 && (F = !1, _ = d + 1), i === 46 ? n === -1 ? n = d : s !== 1 && (s = 1) : n !== -1 && (s = -1);
    }
    return n === -1 || _ === -1 || // We saw a non-dot character immediately before the dot
    s === 0 || // The (right-most) trimmed path component is exactly '..'
    s === 1 && n === _ - 1 && n === u + 1 ? _ !== -1 && (u === 0 && o ? r.base = r.name = t.slice(1, _) : r.base = r.name = t.slice(u, _)) : (u === 0 && o ? (r.name = t.slice(1, n), r.base = t.slice(1, _)) : (r.name = t.slice(u, n), r.base = t.slice(u, _)), r.ext = t.slice(n, _)), u > 0 ? r.dir = t.slice(0, u - 1) : o && (r.dir = "/"), r;
  },
  sep: "/",
  delimiter: ":",
  win32: null,
  posix: null
};
ar.posix = ar;
var eu = ar, ea = {}, gr = {}, In = {};
Object.defineProperty(In, "__esModule", { value: !0 });
var Pi;
typeof setImmediate == "function" ? Pi = setImmediate.bind(typeof globalThis < "u" ? globalThis : Ce) : Pi = setTimeout.bind(typeof globalThis < "u" ? globalThis : Ce);
In.default = Pi;
Object.defineProperty(gr, "__esModule", { value: !0 });
gr.createProcess = void 0;
var tu = function() {
  if (typeof tt < "u")
    return tt;
  try {
    return _t;
  } catch {
    return;
  }
};
function ta() {
  var e = tu() || {};
  return e.cwd || (e.cwd = function() {
    return "/";
  }), e.nextTick || (e.nextTick = In.default), e.emitWarning || (e.emitWarning = function(t, r) {
    console.warn("".concat(r).concat(r ? ": " : "").concat(t));
  }), e.env || (e.env = {}), e;
}
gr.createProcess = ta;
gr.default = ta();
var Qi = { exports: {} }, lr = typeof Reflect == "object" ? Reflect : null, Ds = lr && typeof lr.apply == "function" ? lr.apply : function(t, r, i) {
  return Function.prototype.apply.call(t, r, i);
}, hn;
lr && typeof lr.ownKeys == "function" ? hn = lr.ownKeys : Object.getOwnPropertySymbols ? hn = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : hn = function(t) {
  return Object.getOwnPropertyNames(t);
};
function ru(e) {
  console && console.warn && console.warn(e);
}
var ra = Number.isNaN || function(t) {
  return t !== t;
};
function Re() {
  Re.init.call(this);
}
Qi.exports = Re;
Qi.exports.once = ou;
Re.EventEmitter = Re;
Re.prototype._events = void 0;
Re.prototype._eventsCount = 0;
Re.prototype._maxListeners = void 0;
var Bs = 10;
function Fn(e) {
  if (typeof e != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
}
Object.defineProperty(Re, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return Bs;
  },
  set: function(e) {
    if (typeof e != "number" || e < 0 || ra(e))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
    Bs = e;
  }
});
Re.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
Re.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || ra(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function na(e) {
  return e._maxListeners === void 0 ? Re.defaultMaxListeners : e._maxListeners;
}
Re.prototype.getMaxListeners = function() {
  return na(this);
};
Re.prototype.emit = function(t) {
  for (var r = [], i = 1; i < arguments.length; i++) r.push(arguments[i]);
  var o = t === "error", c = this._events;
  if (c !== void 0)
    o = o && c.error === void 0;
  else if (!o)
    return !1;
  if (o) {
    var n;
    if (r.length > 0 && (n = r[0]), n instanceof Error)
      throw n;
    var u = new Error("Unhandled error." + (n ? " (" + n.message + ")" : ""));
    throw u.context = n, u;
  }
  var _ = c[t];
  if (_ === void 0)
    return !1;
  if (typeof _ == "function")
    Ds(_, this, r);
  else
    for (var F = _.length, d = la(_, F), i = 0; i < F; ++i)
      Ds(d[i], this, r);
  return !0;
};
function ia(e, t, r, i) {
  var o, c, n;
  if (Fn(r), c = e._events, c === void 0 ? (c = e._events = /* @__PURE__ */ Object.create(null), e._eventsCount = 0) : (c.newListener !== void 0 && (e.emit(
    "newListener",
    t,
    r.listener ? r.listener : r
  ), c = e._events), n = c[t]), n === void 0)
    n = c[t] = r, ++e._eventsCount;
  else if (typeof n == "function" ? n = c[t] = i ? [r, n] : [n, r] : i ? n.unshift(r) : n.push(r), o = na(e), o > 0 && n.length > o && !n.warned) {
    n.warned = !0;
    var u = new Error("Possible EventEmitter memory leak detected. " + n.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    u.name = "MaxListenersExceededWarning", u.emitter = e, u.type = t, u.count = n.length, ru(u);
  }
  return e;
}
Re.prototype.addListener = function(t, r) {
  return ia(this, t, r, !1);
};
Re.prototype.on = Re.prototype.addListener;
Re.prototype.prependListener = function(t, r) {
  return ia(this, t, r, !0);
};
function nu() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function sa(e, t, r) {
  var i = { fired: !1, wrapFn: void 0, target: e, type: t, listener: r }, o = nu.bind(i);
  return o.listener = r, i.wrapFn = o, o;
}
Re.prototype.once = function(t, r) {
  return Fn(r), this.on(t, sa(this, t, r)), this;
};
Re.prototype.prependOnceListener = function(t, r) {
  return Fn(r), this.prependListener(t, sa(this, t, r)), this;
};
Re.prototype.removeListener = function(t, r) {
  var i, o, c, n, u;
  if (Fn(r), o = this._events, o === void 0)
    return this;
  if (i = o[t], i === void 0)
    return this;
  if (i === r || i.listener === r)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete o[t], o.removeListener && this.emit("removeListener", t, i.listener || r));
  else if (typeof i != "function") {
    for (c = -1, n = i.length - 1; n >= 0; n--)
      if (i[n] === r || i[n].listener === r) {
        u = i[n].listener, c = n;
        break;
      }
    if (c < 0)
      return this;
    c === 0 ? i.shift() : iu(i, c), i.length === 1 && (o[t] = i[0]), o.removeListener !== void 0 && this.emit("removeListener", t, u || r);
  }
  return this;
};
Re.prototype.off = Re.prototype.removeListener;
Re.prototype.removeAllListeners = function(t) {
  var r, i, o;
  if (i = this._events, i === void 0)
    return this;
  if (i.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : i[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete i[t]), this;
  if (arguments.length === 0) {
    var c = Object.keys(i), n;
    for (o = 0; o < c.length; ++o)
      n = c[o], n !== "removeListener" && this.removeAllListeners(n);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (r = i[t], typeof r == "function")
    this.removeListener(t, r);
  else if (r !== void 0)
    for (o = r.length - 1; o >= 0; o--)
      this.removeListener(t, r[o]);
  return this;
};
function oa(e, t, r) {
  var i = e._events;
  if (i === void 0)
    return [];
  var o = i[t];
  return o === void 0 ? [] : typeof o == "function" ? r ? [o.listener || o] : [o] : r ? su(o) : la(o, o.length);
}
Re.prototype.listeners = function(t) {
  return oa(this, t, !0);
};
Re.prototype.rawListeners = function(t) {
  return oa(this, t, !1);
};
Re.listenerCount = function(e, t) {
  return typeof e.listenerCount == "function" ? e.listenerCount(t) : aa.call(e, t);
};
Re.prototype.listenerCount = aa;
function aa(e) {
  var t = this._events;
  if (t !== void 0) {
    var r = t[e];
    if (typeof r == "function")
      return 1;
    if (r !== void 0)
      return r.length;
  }
  return 0;
}
Re.prototype.eventNames = function() {
  return this._eventsCount > 0 ? hn(this._events) : [];
};
function la(e, t) {
  for (var r = new Array(t), i = 0; i < t; ++i)
    r[i] = e[i];
  return r;
}
function iu(e, t) {
  for (; t + 1 < e.length; t++)
    e[t] = e[t + 1];
  e.pop();
}
function su(e) {
  for (var t = new Array(e.length), r = 0; r < t.length; ++r)
    t[r] = e[r].listener || e[r];
  return t;
}
function ou(e, t) {
  return new Promise(function(r, i) {
    function o(n) {
      e.removeListener(t, c), i(n);
    }
    function c() {
      typeof e.removeListener == "function" && e.removeListener("error", o), r([].slice.call(arguments));
    }
    fa(e, t, c, { once: !0 }), t !== "error" && au(e, o, { once: !0 });
  });
}
function au(e, t, r) {
  typeof e.on == "function" && fa(e, "error", t, r);
}
function fa(e, t, r, i) {
  if (typeof e.on == "function")
    i.once ? e.once(t, r) : e.on(t, r);
  else if (typeof e.addEventListener == "function")
    e.addEventListener(t, function o(c) {
      i.once && e.removeEventListener(t, o), r(c);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
}
var mr = Qi.exports;
(function(e) {
  var t = Ce && Ce.__extends || /* @__PURE__ */ function() {
    var E = function(v, m) {
      return E = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(N, I) {
        N.__proto__ = I;
      } || function(N, I) {
        for (var M in I) Object.prototype.hasOwnProperty.call(I, M) && (N[M] = I[M]);
      }, E(v, m);
    };
    return function(v, m) {
      if (typeof m != "function" && m !== null)
        throw new TypeError("Class extends value " + String(m) + " is not a constructor or null");
      E(v, m);
      function N() {
        this.constructor = v;
      }
      v.prototype = m === null ? Object.create(m) : (N.prototype = m.prototype, new N());
    };
  }();
  Object.defineProperty(e, "__esModule", { value: !0 }), e.File = e.Link = e.Node = e.SEP = void 0;
  var r = gr, i = Tn, o = Ft, c = mr, n = Ht, u = o.constants.S_IFMT, _ = o.constants.S_IFDIR, F = o.constants.S_IFREG, d = o.constants.S_IFLNK, s = o.constants.O_APPEND, l = function() {
    var E, v;
    return (v = (E = r.default.getuid) === null || E === void 0 ? void 0 : E.call(r.default)) !== null && v !== void 0 ? v : 0;
  }, h = function() {
    var E, v;
    return (v = (E = r.default.getgid) === null || E === void 0 ? void 0 : E.call(r.default)) !== null && v !== void 0 ? v : 0;
  };
  e.SEP = "/";
  var b = (
    /** @class */
    function(E) {
      t(v, E);
      function v(m, N) {
        N === void 0 && (N = 438);
        var I = E.call(this) || this;
        return I._uid = l(), I._gid = h(), I._atime = /* @__PURE__ */ new Date(), I._mtime = /* @__PURE__ */ new Date(), I._ctime = /* @__PURE__ */ new Date(), I._perm = 438, I.mode = F, I._nlink = 1, I._perm = N, I.mode |= N, I.ino = m, I;
      }
      return Object.defineProperty(v.prototype, "ctime", {
        get: function() {
          return this._ctime;
        },
        set: function(m) {
          this._ctime = m;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(v.prototype, "uid", {
        get: function() {
          return this._uid;
        },
        set: function(m) {
          this._uid = m, this.ctime = /* @__PURE__ */ new Date();
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(v.prototype, "gid", {
        get: function() {
          return this._gid;
        },
        set: function(m) {
          this._gid = m, this.ctime = /* @__PURE__ */ new Date();
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(v.prototype, "atime", {
        get: function() {
          return this._atime;
        },
        set: function(m) {
          this._atime = m, this.ctime = /* @__PURE__ */ new Date();
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(v.prototype, "mtime", {
        get: function() {
          return this._mtime;
        },
        set: function(m) {
          this._mtime = m, this.ctime = /* @__PURE__ */ new Date();
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(v.prototype, "perm", {
        get: function() {
          return this._perm;
        },
        set: function(m) {
          this._perm = m, this.ctime = /* @__PURE__ */ new Date();
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(v.prototype, "nlink", {
        get: function() {
          return this._nlink;
        },
        set: function(m) {
          this._nlink = m, this.ctime = /* @__PURE__ */ new Date();
        },
        enumerable: !1,
        configurable: !0
      }), v.prototype.getString = function(m) {
        return m === void 0 && (m = "utf8"), this.atime = /* @__PURE__ */ new Date(), this.getBuffer().toString(m);
      }, v.prototype.setString = function(m) {
        this.buf = (0, i.bufferFrom)(m, "utf8"), this.touch();
      }, v.prototype.getBuffer = function() {
        return this.atime = /* @__PURE__ */ new Date(), this.buf || this.setBuffer((0, i.bufferAllocUnsafe)(0)), (0, i.bufferFrom)(this.buf);
      }, v.prototype.setBuffer = function(m) {
        this.buf = (0, i.bufferFrom)(m), this.touch();
      }, v.prototype.getSize = function() {
        return this.buf ? this.buf.length : 0;
      }, v.prototype.setModeProperty = function(m) {
        this.mode = this.mode & ~u | m;
      }, v.prototype.setIsFile = function() {
        this.setModeProperty(F);
      }, v.prototype.setIsDirectory = function() {
        this.setModeProperty(_);
      }, v.prototype.setIsSymlink = function() {
        this.setModeProperty(d);
      }, v.prototype.isFile = function() {
        return (this.mode & u) === F;
      }, v.prototype.isDirectory = function() {
        return (this.mode & u) === _;
      }, v.prototype.isSymlink = function() {
        return (this.mode & u) === d;
      }, v.prototype.makeSymlink = function(m) {
        this.symlink = m, this.setIsSymlink();
      }, v.prototype.write = function(m, N, I, M) {
        if (N === void 0 && (N = 0), I === void 0 && (I = m.length), M === void 0 && (M = 0), this.buf || (this.buf = (0, i.bufferAllocUnsafe)(0)), M + I > this.buf.length) {
          var H = (0, i.bufferAllocUnsafe)(M + I);
          this.buf.copy(H, 0, 0, this.buf.length), this.buf = H;
        }
        return m.copy(this.buf, M, N, N + I), this.touch(), I;
      }, v.prototype.read = function(m, N, I, M) {
        N === void 0 && (N = 0), I === void 0 && (I = m.byteLength), M === void 0 && (M = 0), this.atime = /* @__PURE__ */ new Date(), this.buf || (this.buf = (0, i.bufferAllocUnsafe)(0));
        var H = I;
        return H > m.byteLength && (H = m.byteLength), H + M > this.buf.length && (H = this.buf.length - M), this.buf.copy(m, N, M, M + H), H;
      }, v.prototype.truncate = function(m) {
        if (m === void 0 && (m = 0), !m)
          this.buf = (0, i.bufferAllocUnsafe)(0);
        else if (this.buf || (this.buf = (0, i.bufferAllocUnsafe)(0)), m <= this.buf.length)
          this.buf = this.buf.slice(0, m);
        else {
          var N = (0, i.bufferAllocUnsafe)(m);
          this.buf.copy(N), N.fill(0, this.buf.length), this.buf = N;
        }
        this.touch();
      }, v.prototype.chmod = function(m) {
        this.perm = m, this.mode = this.mode & -512 | m, this.touch();
      }, v.prototype.chown = function(m, N) {
        this.uid = m, this.gid = N, this.touch();
      }, v.prototype.touch = function() {
        this.mtime = /* @__PURE__ */ new Date(), this.emit("change", this);
      }, v.prototype.canRead = function(m, N) {
        return m === void 0 && (m = l()), N === void 0 && (N = h()), !!(this.perm & 4 || N === this.gid && this.perm & 32 || m === this.uid && this.perm & 256);
      }, v.prototype.canWrite = function(m, N) {
        return m === void 0 && (m = l()), N === void 0 && (N = h()), !!(this.perm & 2 || N === this.gid && this.perm & 16 || m === this.uid && this.perm & 128);
      }, v.prototype.del = function() {
        this.emit("delete", this);
      }, v.prototype.toJSON = function() {
        return {
          ino: this.ino,
          uid: this.uid,
          gid: this.gid,
          atime: this.atime.getTime(),
          mtime: this.mtime.getTime(),
          ctime: this.ctime.getTime(),
          perm: this.perm,
          mode: this.mode,
          nlink: this.nlink,
          symlink: this.symlink,
          data: this.getString()
        };
      }, v;
    }(c.EventEmitter)
  );
  e.Node = b;
  var p = (
    /** @class */
    function(E) {
      t(v, E);
      function v(m, N, I) {
        var M = E.call(this) || this;
        return M.children = {}, M._steps = [], M.ino = 0, M.length = 0, M.vol = m, M.parent = N, M.name = I, M.syncSteps(), M;
      }
      return Object.defineProperty(v.prototype, "steps", {
        get: function() {
          return this._steps;
        },
        // Recursively sync children steps, e.g. in case of dir rename
        set: function(m) {
          this._steps = m;
          for (var N = 0, I = Object.entries(this.children); N < I.length; N++) {
            var M = I[N], H = M[0], x = M[1];
            H === "." || H === ".." || x?.syncSteps();
          }
        },
        enumerable: !1,
        configurable: !0
      }), v.prototype.setNode = function(m) {
        this.node = m, this.ino = m.ino;
      }, v.prototype.getNode = function() {
        return this.node;
      }, v.prototype.createChild = function(m, N) {
        N === void 0 && (N = this.vol.createNode());
        var I = new v(this.vol, this, m);
        return I.setNode(N), N.isDirectory() && (I.children["."] = I, I.getNode().nlink++), this.setChild(m, I), I;
      }, v.prototype.setChild = function(m, N) {
        N === void 0 && (N = new v(this.vol, this, m)), this.children[m] = N, N.parent = this, this.length++;
        var I = N.getNode();
        return I.isDirectory() && (N.children[".."] = this, this.getNode().nlink++), this.getNode().mtime = /* @__PURE__ */ new Date(), this.emit("child:add", N, this), N;
      }, v.prototype.deleteChild = function(m) {
        var N = m.getNode();
        N.isDirectory() && (delete m.children[".."], this.getNode().nlink--), delete this.children[m.getName()], this.length--, this.getNode().mtime = /* @__PURE__ */ new Date(), this.emit("child:delete", m, this);
      }, v.prototype.getChild = function(m) {
        if (this.getNode().mtime = /* @__PURE__ */ new Date(), Object.hasOwnProperty.call(this.children, m))
          return this.children[m];
      }, v.prototype.getPath = function() {
        return this.steps.join(e.SEP);
      }, v.prototype.getName = function() {
        return this.steps[this.steps.length - 1];
      }, v.prototype.walk = function(m, N, I) {
        if (N === void 0 && (N = m.length), I === void 0 && (I = 0), I >= m.length)
          return this;
        if (I >= N)
          return this;
        var M = m[I], H = this.getChild(M);
        return H ? H.walk(m, N, I + 1) : null;
      }, v.prototype.toJSON = function() {
        return {
          steps: this.steps,
          ino: this.ino,
          children: Object.keys(this.children)
        };
      }, v.prototype.syncSteps = function() {
        this.steps = this.parent ? this.parent.steps.concat([this.name]) : [this.name];
      }, v;
    }(c.EventEmitter)
  );
  e.Link = p;
  var S = (
    /** @class */
    function() {
      function E(v, m, N, I) {
        this.position = 0, this.link = v, this.node = m, this.flags = N, this.fd = I;
      }
      return E.prototype.getString = function(v) {
        return this.node.getString();
      }, E.prototype.setString = function(v) {
        this.node.setString(v);
      }, E.prototype.getBuffer = function() {
        return this.node.getBuffer();
      }, E.prototype.setBuffer = function(v) {
        this.node.setBuffer(v);
      }, E.prototype.getSize = function() {
        return this.node.getSize();
      }, E.prototype.truncate = function(v) {
        this.node.truncate(v);
      }, E.prototype.seekTo = function(v) {
        this.position = v;
      }, E.prototype.stats = function() {
        return n.default.build(this.node);
      }, E.prototype.write = function(v, m, N, I) {
        m === void 0 && (m = 0), N === void 0 && (N = v.length), typeof I != "number" && (I = this.position), this.flags & s && (I = this.getSize());
        var M = this.node.write(v, m, N, I);
        return this.position = I + M, M;
      }, E.prototype.read = function(v, m, N, I) {
        m === void 0 && (m = 0), N === void 0 && (N = v.byteLength), typeof I != "number" && (I = this.position);
        var M = this.node.read(v, m, N, I);
        return this.position = I + M, M;
      }, E.prototype.chmod = function(v) {
        this.node.chmod(v);
      }, E.prototype.chown = function(v, m) {
        this.node.chown(v, m);
      }, E;
    }()
  );
  e.File = S;
})(ea);
var es = {};
Object.defineProperty(es, "__esModule", { value: !0 });
function lu(e, t, r) {
  var i = setTimeout.apply(typeof globalThis < "u" ? globalThis : Ce, arguments);
  return i && typeof i == "object" && typeof i.unref == "function" && i.unref(), i;
}
es.default = lu;
var ua = { exports: {} }, Zn = { exports: {} }, ke = {
  ArrayIsArray(e) {
    return Array.isArray(e);
  },
  ArrayPrototypeIncludes(e, t) {
    return e.includes(t);
  },
  ArrayPrototypeIndexOf(e, t) {
    return e.indexOf(t);
  },
  ArrayPrototypeJoin(e, t) {
    return e.join(t);
  },
  ArrayPrototypeMap(e, t) {
    return e.map(t);
  },
  ArrayPrototypePop(e, t) {
    return e.pop(t);
  },
  ArrayPrototypePush(e, t) {
    return e.push(t);
  },
  ArrayPrototypeSlice(e, t, r) {
    return e.slice(t, r);
  },
  Error,
  FunctionPrototypeCall(e, t, ...r) {
    return e.call(t, ...r);
  },
  FunctionPrototypeSymbolHasInstance(e, t) {
    return Function.prototype[Symbol.hasInstance].call(e, t);
  },
  MathFloor: Math.floor,
  Number,
  NumberIsInteger: Number.isInteger,
  NumberIsNaN: Number.isNaN,
  NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
  NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
  NumberParseInt: Number.parseInt,
  ObjectDefineProperties(e, t) {
    return Object.defineProperties(e, t);
  },
  ObjectDefineProperty(e, t, r) {
    return Object.defineProperty(e, t, r);
  },
  ObjectGetOwnPropertyDescriptor(e, t) {
    return Object.getOwnPropertyDescriptor(e, t);
  },
  ObjectKeys(e) {
    return Object.keys(e);
  },
  ObjectSetPrototypeOf(e, t) {
    return Object.setPrototypeOf(e, t);
  },
  Promise,
  PromisePrototypeCatch(e, t) {
    return e.catch(t);
  },
  PromisePrototypeThen(e, t, r) {
    return e.then(t, r);
  },
  PromiseReject(e) {
    return Promise.reject(e);
  },
  PromiseResolve(e) {
    return Promise.resolve(e);
  },
  ReflectApply: Reflect.apply,
  RegExpPrototypeTest(e, t) {
    return e.test(t);
  },
  SafeSet: Set,
  String,
  StringPrototypeSlice(e, t, r) {
    return e.slice(t, r);
  },
  StringPrototypeToLowerCase(e) {
    return e.toLowerCase();
  },
  StringPrototypeToUpperCase(e) {
    return e.toUpperCase();
  },
  StringPrototypeTrim(e) {
    return e.trim();
  },
  Symbol,
  SymbolFor: Symbol.for,
  SymbolAsyncIterator: Symbol.asyncIterator,
  SymbolHasInstance: Symbol.hasInstance,
  SymbolIterator: Symbol.iterator,
  SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
  SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
  TypedArrayPrototypeSet(e, t, r) {
    return e.set(t, r);
  },
  Boolean,
  Uint8Array
}, ca = { exports: {} }, Fr = { exports: {} }, Ps;
function Mr() {
  if (Ps) return Fr.exports;
  Ps = 1;
  const { AbortController: e, AbortSignal: t } = typeof self < "u" ? self : typeof window < "u" ? window : (
    /* otherwise */
    void 0
  );
  return Fr.exports = e, Fr.exports.AbortSignal = t, Fr.exports.default = e, Fr.exports;
}
(function(e) {
  const t = yt, { kResistStopPropagation: r, SymbolDispose: i } = ke, o = globalThis.AbortSignal || Mr().AbortSignal, c = globalThis.AbortController || Mr().AbortController, n = Object.getPrototypeOf(async function() {
  }).constructor, u = globalThis.Blob || t.Blob, _ = typeof u < "u" ? function(h) {
    return h instanceof u;
  } : function(h) {
    return !1;
  }, F = (l, h) => {
    if (l !== void 0 && (l === null || typeof l != "object" || !("aborted" in l)))
      throw new ERR_INVALID_ARG_TYPE(h, "AbortSignal", l);
  }, d = (l, h) => {
    if (typeof l != "function") throw new ERR_INVALID_ARG_TYPE(h, "Function", l);
  };
  class s extends Error {
    constructor(h) {
      if (!Array.isArray(h))
        throw new TypeError(`Expected input to be an Array, got ${typeof h}`);
      let b = "";
      for (let p = 0; p < h.length; p++)
        b += `    ${h[p].stack}
`;
      super(b), this.name = "AggregateError", this.errors = h;
    }
  }
  e.exports = {
    AggregateError: s,
    kEmptyObject: Object.freeze({}),
    once(l) {
      let h = !1;
      return function(...b) {
        h || (h = !0, l.apply(this, b));
      };
    },
    createDeferredPromise: function() {
      let l, h;
      return {
        promise: new Promise((p, S) => {
          l = p, h = S;
        }),
        resolve: l,
        reject: h
      };
    },
    promisify(l) {
      return new Promise((h, b) => {
        l((p, ...S) => p ? b(p) : h(...S));
      });
    },
    debuglog() {
      return function() {
      };
    },
    format(l, ...h) {
      return l.replace(/%([sdifj])/g, function(...[b, p]) {
        const S = h.shift();
        return p === "f" ? S.toFixed(6) : p === "j" ? JSON.stringify(S) : p === "s" && typeof S == "object" ? `${S.constructor !== Object ? S.constructor.name : ""} {}`.trim() : S.toString();
      });
    },
    inspect(l) {
      switch (typeof l) {
        case "string":
          if (l.includes("'"))
            if (l.includes('"')) {
              if (!l.includes("`") && !l.includes("${"))
                return `\`${l}\``;
            } else return `"${l}"`;
          return `'${l}'`;
        case "number":
          return isNaN(l) ? "NaN" : Object.is(l, -0) ? String(l) : l;
        case "bigint":
          return `${String(l)}n`;
        case "boolean":
        case "undefined":
          return String(l);
        case "object":
          return "{}";
      }
    },
    types: {
      isAsyncFunction(l) {
        return l instanceof n;
      },
      isArrayBufferView(l) {
        return ArrayBuffer.isView(l);
      }
    },
    isBlob: _,
    deprecate(l, h) {
      return l;
    },
    addAbortListener: mr.addAbortListener || function(h, b) {
      if (h === void 0)
        throw new ERR_INVALID_ARG_TYPE("signal", "AbortSignal", h);
      F(h, "signal"), d(b, "listener");
      let p;
      return h.aborted ? queueMicrotask(() => b()) : (h.addEventListener("abort", b, {
        __proto__: null,
        once: !0,
        [r]: !0
      }), p = () => {
        h.removeEventListener("abort", b);
      }), {
        __proto__: null,
        [i]() {
          var S;
          (S = p) === null || S === void 0 || S();
        }
      };
    },
    AbortSignalAny: o.any || function(h) {
      if (h.length === 1)
        return h[0];
      const b = new c(), p = () => b.abort();
      return h.forEach((S) => {
        F(S, "signals"), S.addEventListener("abort", p, {
          once: !0
        });
      }), b.signal.addEventListener(
        "abort",
        () => {
          h.forEach((S) => S.removeEventListener("abort", p));
        },
        {
          once: !0
        }
      ), b.signal;
    }
  }, e.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
})(ca);
var Ve = ca.exports, ts = {};
const { format: fu, inspect: _n, AggregateError: uu } = Ve, cu = globalThis.AggregateError || uu, du = Symbol("kIsNodeError"), hu = [
  "string",
  "function",
  "number",
  "object",
  // Accept 'Function' and 'Object' as alternative to the lower cased version.
  "Function",
  "Object",
  "boolean",
  "bigint",
  "symbol"
], yu = /^([A-Z][a-z0-9]*)+$/, pu = "__node_internal_", Nn = {};
function xt(e, t) {
  if (!e)
    throw new Nn.ERR_INTERNAL_ASSERTION(t);
}
function ks(e) {
  let t = "", r = e.length;
  const i = e[0] === "-" ? 1 : 0;
  for (; r >= i + 4; r -= 3)
    t = `_${e.slice(r - 3, r)}${t}`;
  return `${e.slice(0, r)}${t}`;
}
function gu(e, t, r) {
  if (typeof t == "function")
    return xt(
      t.length <= r.length,
      // Default options do not count.
      `Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${t.length}).`
    ), t(...r);
  const i = (t.match(/%[dfijoOs]/g) || []).length;
  return xt(
    i === r.length,
    `Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${i}).`
  ), r.length === 0 ? t : fu(t, ...r);
}
function He(e, t, r) {
  r || (r = Error);
  class i extends r {
    constructor(...c) {
      super(gu(e, t, c));
    }
    toString() {
      return `${this.name} [${e}]: ${this.message}`;
    }
  }
  Object.defineProperties(i.prototype, {
    name: {
      value: r.name,
      writable: !0,
      enumerable: !1,
      configurable: !0
    },
    toString: {
      value() {
        return `${this.name} [${e}]: ${this.message}`;
      },
      writable: !0,
      enumerable: !1,
      configurable: !0
    }
  }), i.prototype.code = e, i.prototype[du] = !0, Nn[e] = i;
}
function Ms(e) {
  const t = pu + e.name;
  return Object.defineProperty(e, "name", {
    value: t
  }), e;
}
function mu(e, t) {
  if (e && t && e !== t) {
    if (Array.isArray(t.errors))
      return t.errors.push(e), t;
    const r = new cu([t, e], t.message);
    return r.code = t.code, r;
  }
  return e || t;
}
let bu = class extends Error {
  constructor(t = "The operation was aborted", r = void 0) {
    if (r !== void 0 && typeof r != "object")
      throw new Nn.ERR_INVALID_ARG_TYPE("options", "Object", r);
    super(t, r), this.code = "ABORT_ERR", this.name = "AbortError";
  }
};
He("ERR_ASSERTION", "%s", Error);
He(
  "ERR_INVALID_ARG_TYPE",
  (e, t, r) => {
    xt(typeof e == "string", "'name' must be a string"), Array.isArray(t) || (t = [t]);
    let i = "The ";
    e.endsWith(" argument") ? i += `${e} ` : i += `"${e}" ${e.includes(".") ? "property" : "argument"} `, i += "must be ";
    const o = [], c = [], n = [];
    for (const _ of t)
      xt(typeof _ == "string", "All expected entries have to be of type string"), hu.includes(_) ? o.push(_.toLowerCase()) : yu.test(_) ? c.push(_) : (xt(_ !== "object", 'The value "object" should be written as "Object"'), n.push(_));
    if (c.length > 0) {
      const _ = o.indexOf("object");
      _ !== -1 && (o.splice(o, _, 1), c.push("Object"));
    }
    if (o.length > 0) {
      switch (o.length) {
        case 1:
          i += `of type ${o[0]}`;
          break;
        case 2:
          i += `one of type ${o[0]} or ${o[1]}`;
          break;
        default: {
          const _ = o.pop();
          i += `one of type ${o.join(", ")}, or ${_}`;
        }
      }
      (c.length > 0 || n.length > 0) && (i += " or ");
    }
    if (c.length > 0) {
      switch (c.length) {
        case 1:
          i += `an instance of ${c[0]}`;
          break;
        case 2:
          i += `an instance of ${c[0]} or ${c[1]}`;
          break;
        default: {
          const _ = c.pop();
          i += `an instance of ${c.join(", ")}, or ${_}`;
        }
      }
      n.length > 0 && (i += " or ");
    }
    switch (n.length) {
      case 0:
        break;
      case 1:
        n[0].toLowerCase() !== n[0] && (i += "an "), i += `${n[0]}`;
        break;
      case 2:
        i += `one of ${n[0]} or ${n[1]}`;
        break;
      default: {
        const _ = n.pop();
        i += `one of ${n.join(", ")}, or ${_}`;
      }
    }
    if (r == null)
      i += `. Received ${r}`;
    else if (typeof r == "function" && r.name)
      i += `. Received function ${r.name}`;
    else if (typeof r == "object") {
      var u;
      if ((u = r.constructor) !== null && u !== void 0 && u.name)
        i += `. Received an instance of ${r.constructor.name}`;
      else {
        const _ = _n(r, {
          depth: -1
        });
        i += `. Received ${_}`;
      }
    } else {
      let _ = _n(r, {
        colors: !1
      });
      _.length > 25 && (_ = `${_.slice(0, 25)}...`), i += `. Received type ${typeof r} (${_})`;
    }
    return i;
  },
  TypeError
);
He(
  "ERR_INVALID_ARG_VALUE",
  (e, t, r = "is invalid") => {
    let i = _n(t);
    return i.length > 128 && (i = i.slice(0, 128) + "..."), `The ${e.includes(".") ? "property" : "argument"} '${e}' ${r}. Received ${i}`;
  },
  TypeError
);
He(
  "ERR_INVALID_RETURN_VALUE",
  (e, t, r) => {
    var i;
    const o = r != null && (i = r.constructor) !== null && i !== void 0 && i.name ? `instance of ${r.constructor.name}` : `type ${typeof r}`;
    return `Expected ${e} to be returned from the "${t}" function but got ${o}.`;
  },
  TypeError
);
He(
  "ERR_MISSING_ARGS",
  (...e) => {
    xt(e.length > 0, "At least one arg needs to be specified");
    let t;
    const r = e.length;
    switch (e = (Array.isArray(e) ? e : [e]).map((i) => `"${i}"`).join(" or "), r) {
      case 1:
        t += `The ${e[0]} argument`;
        break;
      case 2:
        t += `The ${e[0]} and ${e[1]} arguments`;
        break;
      default:
        {
          const i = e.pop();
          t += `The ${e.join(", ")}, and ${i} arguments`;
        }
        break;
    }
    return `${t} must be specified`;
  },
  TypeError
);
He(
  "ERR_OUT_OF_RANGE",
  (e, t, r) => {
    xt(t, 'Missing "range" argument');
    let i;
    return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? i = ks(String(r)) : typeof r == "bigint" ? (i = String(r), (r > 2n ** 32n || r < -(2n ** 32n)) && (i = ks(i)), i += "n") : i = _n(r), `The value of "${e}" is out of range. It must be ${t}. Received ${i}`;
  },
  RangeError
);
He("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
He("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
He("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
He("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
He("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
He("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
He("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
He("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
He("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
He("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
He("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
var qe = {
  AbortError: bu,
  aggregateTwoErrors: Ms(mu),
  hideStackFrames: Ms,
  codes: Nn
};
const {
  ArrayIsArray: da,
  ArrayPrototypeIncludes: wu,
  ArrayPrototypeJoin: _u,
  ArrayPrototypeMap: Su,
  NumberIsInteger: rs,
  NumberMAX_SAFE_INTEGER: vu,
  NumberMIN_SAFE_INTEGER: Eu,
  ObjectPrototypeHasOwnProperty: Au,
  String: Tu
} = ke, {
  hideStackFrames: rt,
  codes: { ERR_INVALID_ARG_TYPE: nt, ERR_INVALID_ARG_VALUE: ha, ERR_OUT_OF_RANGE: dr }
} = qe, { normalizeEncoding: Oy } = Ve, { isAsyncFunction: Ru, isArrayBufferView: Iu } = Ve.types, Fu = rt((e, t, r = Eu, i = vu) => {
  if (typeof e != "number") throw new nt(t, "number", e);
  if (!rs(e)) throw new dr(t, "an integer", e);
  if (e < r || e > i) throw new dr(t, `>= ${r} && <= ${i}`, e);
});
rt((e, t, r = -2147483648, i = 2147483647) => {
  if (typeof e != "number")
    throw new nt(t, "number", e);
  if (!rs(e))
    throw new dr(t, "an integer", e);
  if (e < r || e > i)
    throw new dr(t, `>= ${r} && <= ${i}`, e);
});
rt((e, t, r = !1) => {
  if (typeof e != "number")
    throw new nt(t, "number", e);
  if (!rs(e))
    throw new dr(t, "an integer", e);
  const i = r ? 1 : 0, o = 4294967295;
  if (e < i || e > o)
    throw new dr(t, `>= ${i} && <= ${o}`, e);
});
rt((e, t, r) => {
  if (!wu(r, e)) {
    const o = "must be one of: " + _u(
      Su(r, (c) => typeof c == "string" ? `'${c}'` : Tu(c)),
      ", "
    );
    throw new ha(t, e, o);
  }
});
function Nu(e, t) {
  if (typeof e != "boolean") throw new nt(t, "boolean", e);
}
function Qn(e, t, r) {
  return e == null || !Au(e, t) ? r : e[t];
}
const Ou = rt((e, t, r = null) => {
  const i = Qn(r, "allowArray", !1), o = Qn(r, "allowFunction", !1);
  if (!Qn(r, "nullable", !1) && e === null || !i && da(e) || typeof e != "object" && (!o || typeof e != "function"))
    throw new nt(t, "Object", e);
});
rt((e, t) => {
  if (e != null && typeof e != "object" && typeof e != "function")
    throw new nt(t, "a dictionary", e);
});
rt((e, t, r = 0) => {
  if (!da(e))
    throw new nt(t, "Array", e);
  if (e.length < r) {
    const i = `must be longer than ${r}`;
    throw new ha(t, e, i);
  }
});
rt((e, t = "buffer") => {
  if (!Iu(e))
    throw new nt(t, ["Buffer", "TypedArray", "DataView"], e);
});
const Du = rt((e, t) => {
  if (e !== void 0 && (e === null || typeof e != "object" || !("aborted" in e)))
    throw new nt(t, "AbortSignal", e);
}), Bu = rt((e, t) => {
  if (typeof e != "function") throw new nt(t, "Function", e);
});
rt((e, t) => {
  if (typeof e != "function" || Ru(e)) throw new nt(t, "Function", e);
});
rt((e, t) => {
  if (e !== void 0) throw new nt(t, "undefined", e);
});
var Ur = {
  validateBoolean: Nu,
  validateFunction: Bu,
  validateInteger: Fu,
  validateObject: Ou,
  validateAbortSignal: Du
}, ns = { exports: {} };
const { SymbolAsyncIterator: Cs, SymbolIterator: Ls, SymbolFor: zt } = ke, ya = zt("nodejs.stream.destroyed"), Pu = zt("nodejs.stream.errored"), Us = zt("nodejs.stream.readable"), Ws = zt("nodejs.stream.writable"), ku = zt("nodejs.stream.disturbed"), Mu = zt("nodejs.webstream.isClosedPromise"), Cu = zt("nodejs.webstream.controllerErrorFunction");
function is(e, t = !1) {
  var r;
  return !!(e && typeof e.pipe == "function" && typeof e.on == "function" && (!t || typeof e.pause == "function" && typeof e.resume == "function") && (!e._writableState || ((r = e._readableState) === null || r === void 0 ? void 0 : r.readable) !== !1) && // Duplex
  (!e._writableState || e._readableState));
}
function On(e) {
  var t;
  return !!(e && typeof e.write == "function" && typeof e.on == "function" && (!e._readableState || ((t = e._writableState) === null || t === void 0 ? void 0 : t.writable) !== !1));
}
function Lu(e) {
  return !!(e && typeof e.pipe == "function" && e._readableState && typeof e.on == "function" && typeof e.write == "function");
}
function pt(e) {
  return e && (e._readableState || e._writableState || typeof e.write == "function" && typeof e.on == "function" || typeof e.pipe == "function" && typeof e.on == "function");
}
function pa(e) {
  return !!(e && !pt(e) && typeof e.pipeThrough == "function" && typeof e.getReader == "function" && typeof e.cancel == "function");
}
function ga(e) {
  return !!(e && !pt(e) && typeof e.getWriter == "function" && typeof e.abort == "function");
}
function ma(e) {
  return !!(e && !pt(e) && typeof e.readable == "object" && typeof e.writable == "object");
}
function Uu(e) {
  return pa(e) || ga(e) || ma(e);
}
function Wu(e, t) {
  return e == null ? !1 : t === !0 ? typeof e[Cs] == "function" : t === !1 ? typeof e[Ls] == "function" : typeof e[Cs] == "function" || typeof e[Ls] == "function";
}
function Dn(e) {
  if (!pt(e)) return null;
  const t = e._writableState, r = e._readableState, i = t || r;
  return !!(e.destroyed || e[ya] || i != null && i.destroyed);
}
function ju(e) {
  if (!On(e)) return null;
  if (e.writableEnded === !0) return !0;
  const t = e._writableState;
  return t != null && t.errored ? !1 : typeof t?.ended != "boolean" ? null : t.ended;
}
function $u(e, t) {
  if (!On(e)) return null;
  if (e.writableFinished === !0) return !0;
  const r = e._writableState;
  return r != null && r.errored ? !1 : typeof r?.finished != "boolean" ? null : !!(r.finished || t === !1 && r.ended === !0 && r.length === 0);
}
function ba(e, t) {
  if (!is(e)) return null;
  const r = e._readableState;
  return r != null && r.errored ? !1 : typeof r?.endEmitted != "boolean" ? null : !!(r.endEmitted || t === !1 && r.ended === !0 && r.length === 0);
}
function wa(e) {
  return e && e[Us] != null ? e[Us] : typeof e?.readable != "boolean" ? null : Dn(e) ? !1 : is(e) && e.readable && !ba(e);
}
function _a(e) {
  return e && e[Ws] != null ? e[Ws] : typeof e?.writable != "boolean" ? null : Dn(e) ? !1 : On(e) && e.writable && !ju(e);
}
function xu(e, t) {
  return pt(e) ? Dn(e) ? !0 : !(t?.readable !== !1 && wa(e) || t?.writable !== !1 && _a(e)) : null;
}
function Hu(e) {
  var t, r;
  return pt(e) ? e.writableErrored ? e.writableErrored : (t = (r = e._writableState) === null || r === void 0 ? void 0 : r.errored) !== null && t !== void 0 ? t : null : null;
}
function zu(e) {
  var t, r;
  return pt(e) ? e.readableErrored ? e.readableErrored : (t = (r = e._readableState) === null || r === void 0 ? void 0 : r.errored) !== null && t !== void 0 ? t : null : null;
}
function Vu(e) {
  if (!pt(e))
    return null;
  if (typeof e.closed == "boolean")
    return e.closed;
  const t = e._writableState, r = e._readableState;
  return typeof t?.closed == "boolean" || typeof r?.closed == "boolean" ? t?.closed || r?.closed : typeof e._closed == "boolean" && Sa(e) ? e._closed : null;
}
function Sa(e) {
  return typeof e._closed == "boolean" && typeof e._defaultKeepAlive == "boolean" && typeof e._removedConnection == "boolean" && typeof e._removedContLen == "boolean";
}
function Gu(e) {
  return typeof e._sent100 == "boolean" && Sa(e);
}
function Ku(e) {
  var t;
  return typeof e._consuming == "boolean" && typeof e._dumped == "boolean" && ((t = e.req) === null || t === void 0 ? void 0 : t.upgradeOrConnect) === void 0;
}
function Yu(e) {
  if (!pt(e)) return null;
  const t = e._writableState, r = e._readableState, i = t || r;
  return !i && Gu(e) || !!(i && i.autoDestroy && i.emitClose && i.closed === !1);
}
function qu(e) {
  var t;
  return !!(e && ((t = e[ku]) !== null && t !== void 0 ? t : e.readableDidRead || e.readableAborted));
}
function Ju(e) {
  var t, r, i, o, c, n, u, _, F, d;
  return !!(e && ((t = (r = (i = (o = (c = (n = e[Pu]) !== null && n !== void 0 ? n : e.readableErrored) !== null && c !== void 0 ? c : e.writableErrored) !== null && o !== void 0 ? o : (u = e._readableState) === null || u === void 0 ? void 0 : u.errorEmitted) !== null && i !== void 0 ? i : (_ = e._writableState) === null || _ === void 0 ? void 0 : _.errorEmitted) !== null && r !== void 0 ? r : (F = e._readableState) === null || F === void 0 ? void 0 : F.errored) !== null && t !== void 0 ? t : !((d = e._writableState) === null || d === void 0) && d.errored));
}
var St = {
  isDestroyed: Dn,
  kIsDestroyed: ya,
  isDisturbed: qu,
  isErrored: Ju,
  isReadable: wa,
  kIsClosedPromise: Mu,
  kControllerErrorFunction: Cu,
  isClosed: Vu,
  isDuplexNodeStream: Lu,
  isFinished: xu,
  isIterable: Wu,
  isReadableNodeStream: is,
  isReadableStream: pa,
  isReadableFinished: ba,
  isReadableErrored: zu,
  isNodeStream: pt,
  isWebStream: Uu,
  isWritable: _a,
  isWritableNodeStream: On,
  isWritableStream: ga,
  isWritableFinished: $u,
  isWritableErrored: Hu,
  isServerRequest: Ku,
  willEmitClose: Yu,
  isTransformStream: ma
};
const At = _t, { AbortError: va, codes: Xu } = qe, { ERR_INVALID_ARG_TYPE: Zu, ERR_STREAM_PREMATURE_CLOSE: js } = Xu, { kEmptyObject: ki, once: Mi } = Ve, { validateAbortSignal: Qu, validateFunction: ec, validateObject: tc, validateBoolean: rc } = Ur, { Promise: nc, PromisePrototypeThen: ic, SymbolDispose: Ea } = ke, {
  isClosed: sc,
  isReadable: $s,
  isReadableNodeStream: ei,
  isReadableStream: oc,
  isReadableFinished: xs,
  isReadableErrored: Hs,
  isWritable: zs,
  isWritableNodeStream: Vs,
  isWritableStream: ac,
  isWritableFinished: Gs,
  isWritableErrored: Ks,
  isNodeStream: lc,
  willEmitClose: fc,
  kIsClosedPromise: uc
} = St;
let fr;
function cc(e) {
  return e.setHeader && typeof e.abort == "function";
}
const Ci = () => {
};
function Aa(e, t, r) {
  var i, o;
  if (arguments.length === 2 ? (r = t, t = ki) : t == null ? t = ki : tc(t, "options"), ec(r, "callback"), Qu(t.signal, "options.signal"), r = Mi(r), oc(e) || ac(e))
    return dc(e, t, r);
  if (!lc(e))
    throw new Zu("stream", ["ReadableStream", "WritableStream", "Stream"], e);
  const c = (i = t.readable) !== null && i !== void 0 ? i : ei(e), n = (o = t.writable) !== null && o !== void 0 ? o : Vs(e), u = e._writableState, _ = e._readableState, F = () => {
    e.writable || l();
  };
  let d = fc(e) && ei(e) === c && Vs(e) === n, s = Gs(e, !1);
  const l = () => {
    s = !0, e.destroyed && (d = !1), !(d && (!e.readable || c)) && (!c || h) && r.call(e);
  };
  let h = xs(e, !1);
  const b = () => {
    h = !0, e.destroyed && (d = !1), !(d && (!e.writable || n)) && (!n || s) && r.call(e);
  }, p = (I) => {
    r.call(e, I);
  };
  let S = sc(e);
  const E = () => {
    S = !0;
    const I = Ks(e) || Hs(e);
    if (I && typeof I != "boolean")
      return r.call(e, I);
    if (c && !h && ei(e, !0) && !xs(e, !1))
      return r.call(e, new js());
    if (n && !s && !Gs(e, !1))
      return r.call(e, new js());
    r.call(e);
  }, v = () => {
    S = !0;
    const I = Ks(e) || Hs(e);
    if (I && typeof I != "boolean")
      return r.call(e, I);
    r.call(e);
  }, m = () => {
    e.req.on("finish", l);
  };
  cc(e) ? (e.on("complete", l), d || e.on("abort", E), e.req ? m() : e.on("request", m)) : n && !u && (e.on("end", F), e.on("close", F)), !d && typeof e.aborted == "boolean" && e.on("aborted", E), e.on("end", b), e.on("finish", l), t.error !== !1 && e.on("error", p), e.on("close", E), S ? At.nextTick(E) : u != null && u.errorEmitted || _ != null && _.errorEmitted ? d || At.nextTick(v) : (!c && (!d || $s(e)) && (s || zs(e) === !1) || !n && (!d || zs(e)) && (h || $s(e) === !1) || _ && e.req && e.aborted) && At.nextTick(v);
  const N = () => {
    r = Ci, e.removeListener("aborted", E), e.removeListener("complete", l), e.removeListener("abort", E), e.removeListener("request", m), e.req && e.req.removeListener("finish", l), e.removeListener("end", F), e.removeListener("close", F), e.removeListener("finish", l), e.removeListener("end", b), e.removeListener("error", p), e.removeListener("close", E);
  };
  if (t.signal && !S) {
    const I = () => {
      const M = r;
      N(), M.call(
        e,
        new va(void 0, {
          cause: t.signal.reason
        })
      );
    };
    if (t.signal.aborted)
      At.nextTick(I);
    else {
      fr = fr || Ve.addAbortListener;
      const M = fr(t.signal, I), H = r;
      r = Mi((...x) => {
        M[Ea](), H.apply(e, x);
      });
    }
  }
  return N;
}
function dc(e, t, r) {
  let i = !1, o = Ci;
  if (t.signal)
    if (o = () => {
      i = !0, r.call(
        e,
        new va(void 0, {
          cause: t.signal.reason
        })
      );
    }, t.signal.aborted)
      At.nextTick(o);
    else {
      fr = fr || Ve.addAbortListener;
      const n = fr(t.signal, o), u = r;
      r = Mi((..._) => {
        n[Ea](), u.apply(e, _);
      });
    }
  const c = (...n) => {
    i || At.nextTick(() => r.apply(e, n));
  };
  return ic(e[uc].promise, c, c), Ci;
}
function hc(e, t) {
  var r;
  let i = !1;
  return t === null && (t = ki), (r = t) !== null && r !== void 0 && r.cleanup && (rc(t.cleanup, "cleanup"), i = t.cleanup), new nc((o, c) => {
    const n = Aa(e, t, (u) => {
      i && n(), u ? c(u) : o();
    });
  });
}
ns.exports = Aa;
ns.exports.finished = hc;
var Dt = ns.exports;
const dt = _t, {
  aggregateTwoErrors: yc,
  codes: { ERR_MULTIPLE_CALLBACK: pc },
  AbortError: gc
} = qe, { Symbol: Ta } = ke, { kIsDestroyed: mc, isDestroyed: bc, isFinished: wc, isServerRequest: _c } = St, Ra = Ta("kDestroy"), Li = Ta("kConstruct");
function Ia(e, t, r) {
  e && (e.stack, t && !t.errored && (t.errored = e), r && !r.errored && (r.errored = e));
}
function Sc(e, t) {
  const r = this._readableState, i = this._writableState, o = i || r;
  return i != null && i.destroyed || r != null && r.destroyed ? (typeof t == "function" && t(), this) : (Ia(e, i, r), i && (i.destroyed = !0), r && (r.destroyed = !0), o.constructed ? Ys(this, e, t) : this.once(Ra, function(c) {
    Ys(this, yc(c, e), t);
  }), this);
}
function Ys(e, t, r) {
  let i = !1;
  function o(c) {
    if (i)
      return;
    i = !0;
    const n = e._readableState, u = e._writableState;
    Ia(c, u, n), u && (u.closed = !0), n && (n.closed = !0), typeof r == "function" && r(c), c ? dt.nextTick(vc, e, c) : dt.nextTick(Fa, e);
  }
  try {
    e._destroy(t || null, o);
  } catch (c) {
    o(c);
  }
}
function vc(e, t) {
  Ui(e, t), Fa(e);
}
function Fa(e) {
  const t = e._readableState, r = e._writableState;
  r && (r.closeEmitted = !0), t && (t.closeEmitted = !0), (r != null && r.emitClose || t != null && t.emitClose) && e.emit("close");
}
function Ui(e, t) {
  const r = e._readableState, i = e._writableState;
  i != null && i.errorEmitted || r != null && r.errorEmitted || (i && (i.errorEmitted = !0), r && (r.errorEmitted = !0), e.emit("error", t));
}
function Ec() {
  const e = this._readableState, t = this._writableState;
  e && (e.constructed = !0, e.closed = !1, e.closeEmitted = !1, e.destroyed = !1, e.errored = null, e.errorEmitted = !1, e.reading = !1, e.ended = e.readable === !1, e.endEmitted = e.readable === !1), t && (t.constructed = !0, t.destroyed = !1, t.closed = !1, t.closeEmitted = !1, t.errored = null, t.errorEmitted = !1, t.finalCalled = !1, t.prefinished = !1, t.ended = t.writable === !1, t.ending = t.writable === !1, t.finished = t.writable === !1);
}
function Wi(e, t, r) {
  const i = e._readableState, o = e._writableState;
  if (o != null && o.destroyed || i != null && i.destroyed)
    return this;
  i != null && i.autoDestroy || o != null && o.autoDestroy ? e.destroy(t) : t && (t.stack, o && !o.errored && (o.errored = t), i && !i.errored && (i.errored = t), r ? dt.nextTick(Ui, e, t) : Ui(e, t));
}
function Ac(e, t) {
  if (typeof e._construct != "function")
    return;
  const r = e._readableState, i = e._writableState;
  r && (r.constructed = !1), i && (i.constructed = !1), e.once(Li, t), !(e.listenerCount(Li) > 1) && dt.nextTick(Tc, e);
}
function Tc(e) {
  let t = !1;
  function r(i) {
    if (t) {
      Wi(e, i ?? new pc());
      return;
    }
    t = !0;
    const o = e._readableState, c = e._writableState, n = c || o;
    o && (o.constructed = !0), c && (c.constructed = !0), n.destroyed ? e.emit(Ra, i) : i ? Wi(e, i, !0) : dt.nextTick(Rc, e);
  }
  try {
    e._construct((i) => {
      dt.nextTick(r, i);
    });
  } catch (i) {
    dt.nextTick(r, i);
  }
}
function Rc(e) {
  e.emit(Li);
}
function qs(e) {
  return e?.setHeader && typeof e.abort == "function";
}
function Na(e) {
  e.emit("close");
}
function Ic(e, t) {
  e.emit("error", t), dt.nextTick(Na, e);
}
function Fc(e, t) {
  !e || bc(e) || (!t && !wc(e) && (t = new gc()), _c(e) ? (e.socket = null, e.destroy(t)) : qs(e) ? e.abort() : qs(e.req) ? e.req.abort() : typeof e.destroy == "function" ? e.destroy(t) : typeof e.close == "function" ? e.close() : t ? dt.nextTick(Ic, e, t) : dt.nextTick(Na, e), e.destroyed || (e[mc] = !0));
}
var br = {
  construct: Ac,
  destroyer: Fc,
  destroy: Sc,
  undestroy: Ec,
  errorOrDestroy: Wi
};
const { ArrayIsArray: Nc, ObjectSetPrototypeOf: Oa } = ke, { EventEmitter: Bn } = mr;
function Pn(e) {
  Bn.call(this, e);
}
Oa(Pn.prototype, Bn.prototype);
Oa(Pn, Bn);
Pn.prototype.pipe = function(e, t) {
  const r = this;
  function i(d) {
    e.writable && e.write(d) === !1 && r.pause && r.pause();
  }
  r.on("data", i);
  function o() {
    r.readable && r.resume && r.resume();
  }
  e.on("drain", o), !e._isStdio && (!t || t.end !== !1) && (r.on("end", n), r.on("close", u));
  let c = !1;
  function n() {
    c || (c = !0, e.end());
  }
  function u() {
    c || (c = !0, typeof e.destroy == "function" && e.destroy());
  }
  function _(d) {
    F(), Bn.listenerCount(this, "error") === 0 && this.emit("error", d);
  }
  ji(r, "error", _), ji(e, "error", _);
  function F() {
    r.removeListener("data", i), e.removeListener("drain", o), r.removeListener("end", n), r.removeListener("close", u), r.removeListener("error", _), e.removeListener("error", _), r.removeListener("end", F), r.removeListener("close", F), e.removeListener("close", F);
  }
  return r.on("end", F), r.on("close", F), e.on("close", F), e.emit("pipe", r), e;
};
function ji(e, t, r) {
  if (typeof e.prependListener == "function") return e.prependListener(t, r);
  !e._events || !e._events[t] ? e.on(t, r) : Nc(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]];
}
var ss = {
  Stream: Pn,
  prependListener: ji
}, Da = { exports: {} };
(function(e) {
  const { SymbolDispose: t } = ke, { AbortError: r, codes: i } = qe, { isNodeStream: o, isWebStream: c, kControllerErrorFunction: n } = St, u = Dt, { ERR_INVALID_ARG_TYPE: _ } = i;
  let F;
  const d = (s, l) => {
    if (typeof s != "object" || !("aborted" in s))
      throw new _(l, "AbortSignal", s);
  };
  e.exports.addAbortSignal = function(l, h) {
    if (d(l, "signal"), !o(h) && !c(h))
      throw new _("stream", ["ReadableStream", "WritableStream", "Stream"], h);
    return e.exports.addAbortSignalNoValidate(l, h);
  }, e.exports.addAbortSignalNoValidate = function(s, l) {
    if (typeof s != "object" || !("aborted" in s))
      return l;
    const h = o(l) ? () => {
      l.destroy(
        new r(void 0, {
          cause: s.reason
        })
      );
    } : () => {
      l[n](
        new r(void 0, {
          cause: s.reason
        })
      );
    };
    if (s.aborted)
      h();
    else {
      F = F || Ve.addAbortListener;
      const b = F(s, h);
      u(l, b[t]);
    }
    return l;
  };
})(Da);
var kn = Da.exports;
const { StringPrototypeSlice: Js, SymbolIterator: Oc, TypedArrayPrototypeSet: en, Uint8Array: Dc } = ke, { Buffer: ti } = yt, { inspect: Bc } = Ve;
var Pc = class {
  constructor() {
    this.head = null, this.tail = null, this.length = 0;
  }
  push(t) {
    const r = {
      data: t,
      next: null
    };
    this.length > 0 ? this.tail.next = r : this.head = r, this.tail = r, ++this.length;
  }
  unshift(t) {
    const r = {
      data: t,
      next: this.head
    };
    this.length === 0 && (this.tail = r), this.head = r, ++this.length;
  }
  shift() {
    if (this.length === 0) return;
    const t = this.head.data;
    return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, t;
  }
  clear() {
    this.head = this.tail = null, this.length = 0;
  }
  join(t) {
    if (this.length === 0) return "";
    let r = this.head, i = "" + r.data;
    for (; (r = r.next) !== null; ) i += t + r.data;
    return i;
  }
  concat(t) {
    if (this.length === 0) return ti.alloc(0);
    const r = ti.allocUnsafe(t >>> 0);
    let i = this.head, o = 0;
    for (; i; )
      en(r, i.data, o), o += i.data.length, i = i.next;
    return r;
  }
  // Consumes a specified amount of bytes or characters from the buffered data.
  consume(t, r) {
    const i = this.head.data;
    if (t < i.length) {
      const o = i.slice(0, t);
      return this.head.data = i.slice(t), o;
    }
    return t === i.length ? this.shift() : r ? this._getString(t) : this._getBuffer(t);
  }
  first() {
    return this.head.data;
  }
  *[Oc]() {
    for (let t = this.head; t; t = t.next)
      yield t.data;
  }
  // Consumes a specified amount of characters from the buffered data.
  _getString(t) {
    let r = "", i = this.head, o = 0;
    do {
      const c = i.data;
      if (t > c.length)
        r += c, t -= c.length;
      else {
        t === c.length ? (r += c, ++o, i.next ? this.head = i.next : this.head = this.tail = null) : (r += Js(c, 0, t), this.head = i, i.data = Js(c, t));
        break;
      }
      ++o;
    } while ((i = i.next) !== null);
    return this.length -= o, r;
  }
  // Consumes a specified amount of bytes from the buffered data.
  _getBuffer(t) {
    const r = ti.allocUnsafe(t), i = t;
    let o = this.head, c = 0;
    do {
      const n = o.data;
      if (t > n.length)
        en(r, n, i - t), t -= n.length;
      else {
        t === n.length ? (en(r, n, i - t), ++c, o.next ? this.head = o.next : this.head = this.tail = null) : (en(r, new Dc(n.buffer, n.byteOffset, t), i - t), this.head = o, o.data = n.slice(t));
        break;
      }
      ++c;
    } while ((o = o.next) !== null);
    return this.length -= c, r;
  }
  // Make sure the linked list only shows the minimal necessary information.
  [Symbol.for("nodejs.util.inspect.custom")](t, r) {
    return Bc(this, {
      ...r,
      // Only inspect one level.
      depth: 0,
      // It should not recurse.
      customInspect: !1
    });
  }
};
const { MathFloor: kc, NumberIsInteger: Mc } = ke, { validateInteger: Cc } = Ur, { ERR_INVALID_ARG_VALUE: Lc } = qe.codes;
let Ba = 16 * 1024, Pa = 16;
function Uc(e, t, r) {
  return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
}
function ka(e) {
  return e ? Pa : Ba;
}
function Wc(e, t) {
  Cc(t, "value", 0), e ? Pa = t : Ba = t;
}
function jc(e, t, r, i) {
  const o = Uc(t, i, r);
  if (o != null) {
    if (!Mc(o) || o < 0) {
      const c = i ? `options.${r}` : "options.highWaterMark";
      throw new Lc(c, o);
    }
    return kc(o);
  }
  return ka(e.objectMode);
}
var Mn = {
  getHighWaterMark: jc,
  getDefaultHighWaterMark: ka,
  setDefaultHighWaterMark: Wc
}, Ma = {}, $i = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(e, t) {
  var r = yt, i = r.Buffer;
  function o(n, u) {
    for (var _ in n)
      u[_] = n[_];
  }
  i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? e.exports = r : (o(r, t), t.Buffer = c);
  function c(n, u, _) {
    return i(n, u, _);
  }
  c.prototype = Object.create(i.prototype), o(i, c), c.from = function(n, u, _) {
    if (typeof n == "number")
      throw new TypeError("Argument must not be a number");
    return i(n, u, _);
  }, c.alloc = function(n, u, _) {
    if (typeof n != "number")
      throw new TypeError("Argument must be a number");
    var F = i(n);
    return u !== void 0 ? typeof _ == "string" ? F.fill(u, _) : F.fill(u) : F.fill(0), F;
  }, c.allocUnsafe = function(n) {
    if (typeof n != "number")
      throw new TypeError("Argument must be a number");
    return i(n);
  }, c.allocUnsafeSlow = function(n) {
    if (typeof n != "number")
      throw new TypeError("Argument must be a number");
    return r.SlowBuffer(n);
  };
})($i, $i.exports);
var $c = $i.exports, os = $c.Buffer, Xs = os.isEncoding || function(e) {
  switch (e = "" + e, e && e.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return !0;
    default:
      return !1;
  }
};
function xc(e) {
  if (!e) return "utf8";
  for (var t; ; )
    switch (e) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return e;
      default:
        if (t) return;
        e = ("" + e).toLowerCase(), t = !0;
    }
}
function Hc(e) {
  var t = xc(e);
  if (typeof t != "string" && (os.isEncoding === Xs || !Xs(e))) throw new Error("Unknown encoding: " + e);
  return t || e;
}
Ma.StringDecoder = Wr;
function Wr(e) {
  this.encoding = Hc(e);
  var t;
  switch (this.encoding) {
    case "utf16le":
      this.text = qc, this.end = Jc, t = 4;
      break;
    case "utf8":
      this.fillLast = Gc, t = 4;
      break;
    case "base64":
      this.text = Xc, this.end = Zc, t = 3;
      break;
    default:
      this.write = Qc, this.end = ed;
      return;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = os.allocUnsafe(t);
}
Wr.prototype.write = function(e) {
  if (e.length === 0) return "";
  var t, r;
  if (this.lastNeed) {
    if (t = this.fillLast(e), t === void 0) return "";
    r = this.lastNeed, this.lastNeed = 0;
  } else
    r = 0;
  return r < e.length ? t ? t + this.text(e, r) : this.text(e, r) : t || "";
};
Wr.prototype.end = Yc;
Wr.prototype.text = Kc;
Wr.prototype.fillLast = function(e) {
  if (this.lastNeed <= e.length)
    return e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length), this.lastNeed -= e.length;
};
function ri(e) {
  return e <= 127 ? 0 : e >> 5 === 6 ? 2 : e >> 4 === 14 ? 3 : e >> 3 === 30 ? 4 : e >> 6 === 2 ? -1 : -2;
}
function zc(e, t, r) {
  var i = t.length - 1;
  if (i < r) return 0;
  var o = ri(t[i]);
  return o >= 0 ? (o > 0 && (e.lastNeed = o - 1), o) : --i < r || o === -2 ? 0 : (o = ri(t[i]), o >= 0 ? (o > 0 && (e.lastNeed = o - 2), o) : --i < r || o === -2 ? 0 : (o = ri(t[i]), o >= 0 ? (o > 0 && (o === 2 ? o = 0 : e.lastNeed = o - 3), o) : 0));
}
function Vc(e, t, r) {
  if ((t[0] & 192) !== 128)
    return e.lastNeed = 0, "";
  if (e.lastNeed > 1 && t.length > 1) {
    if ((t[1] & 192) !== 128)
      return e.lastNeed = 1, "";
    if (e.lastNeed > 2 && t.length > 2 && (t[2] & 192) !== 128)
      return e.lastNeed = 2, "";
  }
}
function Gc(e) {
  var t = this.lastTotal - this.lastNeed, r = Vc(this, e);
  if (r !== void 0) return r;
  if (this.lastNeed <= e.length)
    return e.copy(this.lastChar, t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  e.copy(this.lastChar, t, 0, e.length), this.lastNeed -= e.length;
}
function Kc(e, t) {
  var r = zc(this, e, t);
  if (!this.lastNeed) return e.toString("utf8", t);
  this.lastTotal = r;
  var i = e.length - (r - this.lastNeed);
  return e.copy(this.lastChar, 0, i), e.toString("utf8", t, i);
}
function Yc(e) {
  var t = e && e.length ? this.write(e) : "";
  return this.lastNeed ? t + "" : t;
}
function qc(e, t) {
  if ((e.length - t) % 2 === 0) {
    var r = e.toString("utf16le", t);
    if (r) {
      var i = r.charCodeAt(r.length - 1);
      if (i >= 55296 && i <= 56319)
        return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1], r.slice(0, -1);
    }
    return r;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e[e.length - 1], e.toString("utf16le", t, e.length - 1);
}
function Jc(e) {
  var t = e && e.length ? this.write(e) : "";
  if (this.lastNeed) {
    var r = this.lastTotal - this.lastNeed;
    return t + this.lastChar.toString("utf16le", 0, r);
  }
  return t;
}
function Xc(e, t) {
  var r = (e.length - t) % 3;
  return r === 0 ? e.toString("base64", t) : (this.lastNeed = 3 - r, this.lastTotal = 3, r === 1 ? this.lastChar[0] = e[e.length - 1] : (this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1]), e.toString("base64", t, e.length - r));
}
function Zc(e) {
  var t = e && e.length ? this.write(e) : "";
  return this.lastNeed ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t;
}
function Qc(e) {
  return e.toString(this.encoding);
}
function ed(e) {
  return e && e.length ? this.write(e) : "";
}
const Zs = _t, { PromisePrototypeThen: td, SymbolAsyncIterator: Qs, SymbolIterator: eo } = ke, { Buffer: rd } = yt, { ERR_INVALID_ARG_TYPE: nd, ERR_STREAM_NULL_VALUES: id } = qe.codes;
function sd(e, t, r) {
  let i;
  if (typeof t == "string" || t instanceof rd)
    return new e({
      objectMode: !0,
      ...r,
      read() {
        this.push(t), this.push(null);
      }
    });
  let o;
  if (t && t[Qs])
    o = !0, i = t[Qs]();
  else if (t && t[eo])
    o = !1, i = t[eo]();
  else
    throw new nd("iterable", ["Iterable"], t);
  const c = new e({
    objectMode: !0,
    highWaterMark: 1,
    // TODO(ronag): What options should be allowed?
    ...r
  });
  let n = !1;
  c._read = function() {
    n || (n = !0, _());
  }, c._destroy = function(F, d) {
    td(
      u(F),
      () => Zs.nextTick(d, F),
      // nextTick is here in case cb throws
      (s) => Zs.nextTick(d, s || F)
    );
  };
  async function u(F) {
    const d = F != null, s = typeof i.throw == "function";
    if (d && s) {
      const { value: l, done: h } = await i.throw(F);
      if (await l, h)
        return;
    }
    if (typeof i.return == "function") {
      const { value: l } = await i.return();
      await l;
    }
  }
  async function _() {
    for (; ; ) {
      try {
        const { value: F, done: d } = o ? await i.next() : i.next();
        if (d)
          c.push(null);
        else {
          const s = F && typeof F.then == "function" ? await F : F;
          if (s === null)
            throw n = !1, new id();
          if (c.push(s))
            continue;
          n = !1;
        }
      } catch (F) {
        c.destroy(F);
      }
      break;
    }
  }
  return c;
}
var Ca = sd, ni, to;
function Cn() {
  if (to) return ni;
  to = 1;
  const e = _t, {
    ArrayPrototypeIndexOf: t,
    NumberIsInteger: r,
    NumberIsNaN: i,
    NumberParseInt: o,
    ObjectDefineProperties: c,
    ObjectKeys: n,
    ObjectSetPrototypeOf: u,
    Promise: _,
    SafeSet: F,
    SymbolAsyncDispose: d,
    SymbolAsyncIterator: s,
    Symbol: l
  } = ke;
  ni = le, le.ReadableState = Ke;
  const { EventEmitter: h } = mr, { Stream: b, prependListener: p } = ss, { Buffer: S } = yt, { addAbortSignal: E } = kn, v = Dt;
  let m = Ve.debuglog("stream", (A) => {
    m = A;
  });
  const N = Pc, I = br, { getHighWaterMark: M, getDefaultHighWaterMark: H } = Mn, {
    aggregateTwoErrors: x,
    codes: {
      ERR_INVALID_ARG_TYPE: Y,
      ERR_METHOD_NOT_IMPLEMENTED: X,
      ERR_OUT_OF_RANGE: oe,
      ERR_STREAM_PUSH_AFTER_EOF: Z,
      ERR_STREAM_UNSHIFT_AFTER_END_EVENT: W
    },
    AbortError: ae
  } = qe, { validateObject: ie } = Ur, ne = l("kPaused"), { StringDecoder: we } = Ma, me = Ca;
  u(le.prototype, b.prototype), u(le, b);
  const _e = () => {
  }, { errorOrDestroy: pe } = I, B = 1, j = 2, U = 4, q = 8, fe = 16, ge = 32, de = 64, he = 128, ye = 256, Fe = 512, ze = 1024, Ge = 2048, D = 4096, k = 8192, V = 16384, te = 32768, re = 65536, Q = 1 << 17, L = 1 << 18;
  function Se(A) {
    return {
      enumerable: !1,
      get() {
        return (this.state & A) !== 0;
      },
      set(T) {
        T ? this.state |= A : this.state &= ~A;
      }
    };
  }
  c(Ke.prototype, {
    objectMode: Se(B),
    ended: Se(j),
    endEmitted: Se(U),
    reading: Se(q),
    // Stream is still being constructed and cannot be
    // destroyed until construction finished or failed.
    // Async construction is opt in, therefore we start as
    // constructed.
    constructed: Se(fe),
    // A flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.
    sync: Se(ge),
    // Whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    needReadable: Se(de),
    emittedReadable: Se(he),
    readableListening: Se(ye),
    resumeScheduled: Se(Fe),
    // True if the error was already emitted and should not be thrown again.
    errorEmitted: Se(ze),
    emitClose: Se(Ge),
    autoDestroy: Se(D),
    // Has it been destroyed.
    destroyed: Se(k),
    // Indicates whether the stream has finished destroying.
    closed: Se(V),
    // True if close has been emitted or would have been emitted
    // depending on emitClose.
    closeEmitted: Se(te),
    multiAwaitDrain: Se(re),
    // If true, a maybeReadMore has been scheduled.
    readingMore: Se(Q),
    dataEmitted: Se(L)
  });
  function Ke(A, T, G) {
    typeof G != "boolean" && (G = T instanceof mt()), this.state = Ge | D | fe | ge, A && A.objectMode && (this.state |= B), G && A && A.readableObjectMode && (this.state |= B), this.highWaterMark = A ? M(this, A, "readableHighWaterMark", G) : H(!1), this.buffer = new N(), this.length = 0, this.pipes = [], this.flowing = null, this[ne] = null, A && A.emitClose === !1 && (this.state &= ~Ge), A && A.autoDestroy === !1 && (this.state &= ~D), this.errored = null, this.defaultEncoding = A && A.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.decoder = null, this.encoding = null, A && A.encoding && (this.decoder = new we(A.encoding), this.encoding = A.encoding);
  }
  function le(A) {
    if (!(this instanceof le)) return new le(A);
    const T = this instanceof mt();
    this._readableState = new Ke(A, this, T), A && (typeof A.read == "function" && (this._read = A.read), typeof A.destroy == "function" && (this._destroy = A.destroy), typeof A.construct == "function" && (this._construct = A.construct), A.signal && !T && E(A.signal, this)), b.call(this, A), I.construct(this, () => {
      this._readableState.needReadable && Pt(this, this._readableState);
    });
  }
  le.prototype.destroy = I.destroy, le.prototype._undestroy = I.undestroy, le.prototype._destroy = function(A, T) {
    T(A);
  }, le.prototype[h.captureRejectionSymbol] = function(A) {
    this.destroy(A);
  }, le.prototype[d] = function() {
    let A;
    return this.destroyed || (A = this.readableEnded ? null : new ae(), this.destroy(A)), new _((T, G) => v(this, (K) => K && K !== A ? G(K) : T(null)));
  }, le.prototype.push = function(A, T) {
    return De(this, A, T, !1);
  }, le.prototype.unshift = function(A, T) {
    return De(this, A, T, !0);
  };
  function De(A, T, G, K) {
    m("readableAddChunk", T);
    const $ = A._readableState;
    let Be;
    if (($.state & B) === 0 && (typeof T == "string" ? (G = G || $.defaultEncoding, $.encoding !== G && (K && $.encoding ? T = S.from(T, G).toString($.encoding) : (T = S.from(T, G), G = ""))) : T instanceof S ? G = "" : b._isUint8Array(T) ? (T = b._uint8ArrayToBuffer(T), G = "") : T != null && (Be = new Y("chunk", ["string", "Buffer", "Uint8Array"], T))), Be)
      pe(A, Be);
    else if (T === null)
      $.state &= ~q, Un(A, $);
    else if (($.state & B) !== 0 || T && T.length > 0)
      if (K)
        if (($.state & U) !== 0) pe(A, new W());
        else {
          if ($.destroyed || $.errored) return !1;
          st(A, $, T, !0);
        }
      else if ($.ended)
        pe(A, new Z());
      else {
        if ($.destroyed || $.errored)
          return !1;
        $.state &= ~q, $.decoder && !G ? (T = $.decoder.write(T), $.objectMode || T.length !== 0 ? st(A, $, T, !1) : Pt(A, $)) : st(A, $, T, !1);
      }
    else K || ($.state &= ~q, Pt(A, $));
    return !$.ended && ($.length < $.highWaterMark || $.length === 0);
  }
  function st(A, T, G, K) {
    T.flowing && T.length === 0 && !T.sync && A.listenerCount("data") > 0 ? ((T.state & re) !== 0 ? T.awaitDrainWriters.clear() : T.awaitDrainWriters = null, T.dataEmitted = !0, A.emit("data", G)) : (T.length += T.objectMode ? 1 : G.length, K ? T.buffer.unshift(G) : T.buffer.push(G), (T.state & de) !== 0 && Bt(A)), Pt(A, T);
  }
  le.prototype.isPaused = function() {
    const A = this._readableState;
    return A[ne] === !0 || A.flowing === !1;
  }, le.prototype.setEncoding = function(A) {
    const T = new we(A);
    this._readableState.decoder = T, this._readableState.encoding = this._readableState.decoder.encoding;
    const G = this._readableState.buffer;
    let K = "";
    for (const $ of G)
      K += T.write($);
    return G.clear(), K !== "" && G.push(K), this._readableState.length = K.length, this;
  };
  const wr = 1073741824;
  function Kt(A) {
    if (A > wr)
      throw new oe("size", "<= 1GiB", A);
    return A--, A |= A >>> 1, A |= A >>> 2, A |= A >>> 4, A |= A >>> 8, A |= A >>> 16, A++, A;
  }
  function _r(A, T) {
    return A <= 0 || T.length === 0 && T.ended ? 0 : (T.state & B) !== 0 ? 1 : i(A) ? T.flowing && T.length ? T.buffer.first().length : T.length : A <= T.length ? A : T.ended ? T.length : 0;
  }
  le.prototype.read = function(A) {
    m("read", A), A === void 0 ? A = NaN : r(A) || (A = o(A, 10));
    const T = this._readableState, G = A;
    if (A > T.highWaterMark && (T.highWaterMark = Kt(A)), A !== 0 && (T.state &= ~he), A === 0 && T.needReadable && ((T.highWaterMark !== 0 ? T.length >= T.highWaterMark : T.length > 0) || T.ended))
      return m("read: emitReadable", T.length, T.ended), T.length === 0 && T.ended ? Tr(this) : Bt(this), null;
    if (A = _r(A, T), A === 0 && T.ended)
      return T.length === 0 && Tr(this), null;
    let K = (T.state & de) !== 0;
    if (m("need readable", K), (T.length === 0 || T.length - A < T.highWaterMark) && (K = !0, m("length less than watermark", K)), T.ended || T.reading || T.destroyed || T.errored || !T.constructed)
      K = !1, m("reading, ended or constructing", K);
    else if (K) {
      m("do read"), T.state |= q | ge, T.length === 0 && (T.state |= de);
      try {
        this._read(T.highWaterMark);
      } catch (Be) {
        pe(this, Be);
      }
      T.state &= ~ge, T.reading || (A = _r(G, T));
    }
    let $;
    return A > 0 ? $ = Ar(A, T) : $ = null, $ === null ? (T.needReadable = T.length <= T.highWaterMark, A = 0) : (T.length -= A, T.multiAwaitDrain ? T.awaitDrainWriters.clear() : T.awaitDrainWriters = null), T.length === 0 && (T.ended || (T.needReadable = !0), G !== A && T.ended && Tr(this)), $ !== null && !T.errorEmitted && !T.closeEmitted && (T.dataEmitted = !0, this.emit("data", $)), $;
  };
  function Un(A, T) {
    if (m("onEofChunk"), !T.ended) {
      if (T.decoder) {
        const G = T.decoder.end();
        G && G.length && (T.buffer.push(G), T.length += T.objectMode ? 1 : G.length);
      }
      T.ended = !0, T.sync ? Bt(A) : (T.needReadable = !1, T.emittedReadable = !0, Sr(A));
    }
  }
  function Bt(A) {
    const T = A._readableState;
    m("emitReadable", T.needReadable, T.emittedReadable), T.needReadable = !1, T.emittedReadable || (m("emitReadable", T.flowing), T.emittedReadable = !0, e.nextTick(Sr, A));
  }
  function Sr(A) {
    const T = A._readableState;
    m("emitReadable_", T.destroyed, T.length, T.ended), !T.destroyed && !T.errored && (T.length || T.ended) && (A.emit("readable"), T.emittedReadable = !1), T.needReadable = !T.flowing && !T.ended && T.length <= T.highWaterMark, vr(A);
  }
  function Pt(A, T) {
    !T.readingMore && T.constructed && (T.readingMore = !0, e.nextTick(Vr, A, T));
  }
  function Vr(A, T) {
    for (; !T.reading && !T.ended && (T.length < T.highWaterMark || T.flowing && T.length === 0); ) {
      const G = T.length;
      if (m("maybeReadMore read 0"), A.read(0), G === T.length)
        break;
    }
    T.readingMore = !1;
  }
  le.prototype._read = function(A) {
    throw new X("_read()");
  }, le.prototype.pipe = function(A, T) {
    const G = this, K = this._readableState;
    K.pipes.length === 1 && (K.multiAwaitDrain || (K.multiAwaitDrain = !0, K.awaitDrainWriters = new F(K.awaitDrainWriters ? [K.awaitDrainWriters] : []))), K.pipes.push(A), m("pipe count=%d opts=%j", K.pipes.length, T);
    const Be = (!T || T.end !== !1) && A !== e.stdout && A !== e.stderr ? Jr : Je;
    K.endEmitted ? e.nextTick(Be) : G.once("end", Be), A.on("unpipe", Ye);
    function Ye(Xe, Ue) {
      m("onunpipe"), Xe === G && Ue && Ue.hasUnpiped === !1 && (Ue.hasUnpiped = !0, zn());
    }
    function Jr() {
      m("onend"), A.end();
    }
    let Te, Xr = !1;
    function zn() {
      m("cleanup"), A.removeListener("close", Ir), A.removeListener("finish", $e), Te && A.removeListener("drain", Te), A.removeListener("error", kt), A.removeListener("unpipe", Ye), G.removeListener("end", Jr), G.removeListener("end", Je), G.removeListener("data", Rr), Xr = !0, Te && K.awaitDrainWriters && (!A._writableState || A._writableState.needDrain) && Te();
    }
    function vt() {
      Xr || (K.pipes.length === 1 && K.pipes[0] === A ? (m("false write response, pause", 0), K.awaitDrainWriters = A, K.multiAwaitDrain = !1) : K.pipes.length > 1 && K.pipes.includes(A) && (m("false write response, pause", K.awaitDrainWriters.size), K.awaitDrainWriters.add(A)), G.pause()), Te || (Te = Gr(G, A), A.on("drain", Te));
    }
    G.on("data", Rr);
    function Rr(Xe) {
      m("ondata");
      const Ue = A.write(Xe);
      m("dest.write", Ue), Ue === !1 && vt();
    }
    function kt(Xe) {
      if (m("onerror", Xe), Je(), A.removeListener("error", kt), A.listenerCount("error") === 0) {
        const Ue = A._writableState || A._readableState;
        Ue && !Ue.errorEmitted ? pe(A, Xe) : A.emit("error", Xe);
      }
    }
    p(A, "error", kt);
    function Ir() {
      A.removeListener("finish", $e), Je();
    }
    A.once("close", Ir);
    function $e() {
      m("onfinish"), A.removeListener("close", Ir), Je();
    }
    A.once("finish", $e);
    function Je() {
      m("unpipe"), G.unpipe(A);
    }
    return A.emit("pipe", G), A.writableNeedDrain === !0 ? vt() : K.flowing || (m("pipe resume"), G.resume()), A;
  };
  function Gr(A, T) {
    return function() {
      const K = A._readableState;
      K.awaitDrainWriters === T ? (m("pipeOnDrain", 1), K.awaitDrainWriters = null) : K.multiAwaitDrain && (m("pipeOnDrain", K.awaitDrainWriters.size), K.awaitDrainWriters.delete(T)), (!K.awaitDrainWriters || K.awaitDrainWriters.size === 0) && A.listenerCount("data") && A.resume();
    };
  }
  le.prototype.unpipe = function(A) {
    const T = this._readableState, G = {
      hasUnpiped: !1
    };
    if (T.pipes.length === 0) return this;
    if (!A) {
      const $ = T.pipes;
      T.pipes = [], this.pause();
      for (let Be = 0; Be < $.length; Be++)
        $[Be].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    const K = t(T.pipes, A);
    return K === -1 ? this : (T.pipes.splice(K, 1), T.pipes.length === 0 && this.pause(), A.emit("unpipe", this, G), this);
  }, le.prototype.on = function(A, T) {
    const G = b.prototype.on.call(this, A, T), K = this._readableState;
    return A === "data" ? (K.readableListening = this.listenerCount("readable") > 0, K.flowing !== !1 && this.resume()) : A === "readable" && !K.endEmitted && !K.readableListening && (K.readableListening = K.needReadable = !0, K.flowing = !1, K.emittedReadable = !1, m("on readable", K.length, K.reading), K.length ? Bt(this) : K.reading || e.nextTick(Wn, this)), G;
  }, le.prototype.addListener = le.prototype.on, le.prototype.removeListener = function(A, T) {
    const G = b.prototype.removeListener.call(this, A, T);
    return A === "readable" && e.nextTick(Kr, this), G;
  }, le.prototype.off = le.prototype.removeListener, le.prototype.removeAllListeners = function(A) {
    const T = b.prototype.removeAllListeners.apply(this, arguments);
    return (A === "readable" || A === void 0) && e.nextTick(Kr, this), T;
  };
  function Kr(A) {
    const T = A._readableState;
    T.readableListening = A.listenerCount("readable") > 0, T.resumeScheduled && T[ne] === !1 ? T.flowing = !0 : A.listenerCount("data") > 0 ? A.resume() : T.readableListening || (T.flowing = null);
  }
  function Wn(A) {
    m("readable nexttick read 0"), A.read(0);
  }
  le.prototype.resume = function() {
    const A = this._readableState;
    return A.flowing || (m("resume"), A.flowing = !A.readableListening, Yr(this, A)), A[ne] = !1, this;
  };
  function Yr(A, T) {
    T.resumeScheduled || (T.resumeScheduled = !0, e.nextTick(jn, A, T));
  }
  function jn(A, T) {
    m("resume", T.reading), T.reading || A.read(0), T.resumeScheduled = !1, A.emit("resume"), vr(A), T.flowing && !T.reading && A.read(0);
  }
  le.prototype.pause = function() {
    return m("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (m("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState[ne] = !0, this;
  };
  function vr(A) {
    const T = A._readableState;
    for (m("flow", T.flowing); T.flowing && A.read() !== null; ) ;
  }
  le.prototype.wrap = function(A) {
    let T = !1;
    A.on("data", (K) => {
      !this.push(K) && A.pause && (T = !0, A.pause());
    }), A.on("end", () => {
      this.push(null);
    }), A.on("error", (K) => {
      pe(this, K);
    }), A.on("close", () => {
      this.destroy();
    }), A.on("destroy", () => {
      this.destroy();
    }), this._read = () => {
      T && A.resume && (T = !1, A.resume());
    };
    const G = n(A);
    for (let K = 1; K < G.length; K++) {
      const $ = G[K];
      this[$] === void 0 && typeof A[$] == "function" && (this[$] = A[$].bind(A));
    }
    return this;
  }, le.prototype[s] = function() {
    return Er(this);
  }, le.prototype.iterator = function(A) {
    return A !== void 0 && ie(A, "options"), Er(this, A);
  };
  function Er(A, T) {
    typeof A.read != "function" && (A = le.wrap(A, {
      objectMode: !0
    }));
    const G = $n(A, T);
    return G.stream = A, G;
  }
  async function* $n(A, T) {
    let G = _e;
    function K(Ye) {
      this === A ? (G(), G = _e) : G = Ye;
    }
    A.on("readable", K);
    let $;
    const Be = v(
      A,
      {
        writable: !1
      },
      (Ye) => {
        $ = Ye ? x($, Ye) : null, G(), G = _e;
      }
    );
    try {
      for (; ; ) {
        const Ye = A.destroyed ? null : A.read();
        if (Ye !== null)
          yield Ye;
        else {
          if ($)
            throw $;
          if ($ === null)
            return;
          await new _(K);
        }
      }
    } catch (Ye) {
      throw $ = x($, Ye), $;
    } finally {
      ($ || T?.destroyOnReturn !== !1) && ($ === void 0 || A._readableState.autoDestroy) ? I.destroyer(A, null) : (A.off("readable", K), Be());
    }
  }
  c(le.prototype, {
    readable: {
      __proto__: null,
      get() {
        const A = this._readableState;
        return !!A && A.readable !== !1 && !A.destroyed && !A.errorEmitted && !A.endEmitted;
      },
      set(A) {
        this._readableState && (this._readableState.readable = !!A);
      }
    },
    readableDidRead: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.dataEmitted;
      }
    },
    readableAborted: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return !!(this._readableState.readable !== !1 && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
      }
    },
    readableHighWaterMark: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.highWaterMark;
      }
    },
    readableBuffer: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState && this._readableState.buffer;
      }
    },
    readableFlowing: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.flowing;
      },
      set: function(A) {
        this._readableState && (this._readableState.flowing = A);
      }
    },
    readableLength: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState.length;
      }
    },
    readableObjectMode: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.objectMode : !1;
      }
    },
    readableEncoding: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.encoding : null;
      }
    },
    errored: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.errored : null;
      }
    },
    closed: {
      __proto__: null,
      get() {
        return this._readableState ? this._readableState.closed : !1;
      }
    },
    destroyed: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.destroyed : !1;
      },
      set(A) {
        this._readableState && (this._readableState.destroyed = A);
      }
    },
    readableEnded: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.endEmitted : !1;
      }
    }
  }), c(Ke.prototype, {
    // Legacy getter for `pipesCount`.
    pipesCount: {
      __proto__: null,
      get() {
        return this.pipes.length;
      }
    },
    // Legacy property for `paused`.
    paused: {
      __proto__: null,
      get() {
        return this[ne] !== !1;
      },
      set(A) {
        this[ne] = !!A;
      }
    }
  }), le._fromList = Ar;
  function Ar(A, T) {
    if (T.length === 0) return null;
    let G;
    return T.objectMode ? G = T.buffer.shift() : !A || A >= T.length ? (T.decoder ? G = T.buffer.join("") : T.buffer.length === 1 ? G = T.buffer.first() : G = T.buffer.concat(T.length), T.buffer.clear()) : G = T.buffer.consume(A, T.decoder), G;
  }
  function Tr(A) {
    const T = A._readableState;
    m("endReadable", T.endEmitted), T.endEmitted || (T.ended = !0, e.nextTick(xn, T, A));
  }
  function xn(A, T) {
    if (m("endReadableNT", A.endEmitted, A.length), !A.errored && !A.closeEmitted && !A.endEmitted && A.length === 0) {
      if (A.endEmitted = !0, T.emit("end"), T.writable && T.allowHalfOpen === !1)
        e.nextTick(Hn, T);
      else if (A.autoDestroy) {
        const G = T._writableState;
        (!G || G.autoDestroy && // We don't expect the writable to ever 'finish'
        // if writable is explicitly set to false.
        (G.finished || G.writable === !1)) && T.destroy();
      }
    }
  }
  function Hn(A) {
    A.writable && !A.writableEnded && !A.destroyed && A.end();
  }
  le.from = function(A, T) {
    return me(le, A, T);
  };
  let Yt;
  function qr() {
    return Yt === void 0 && (Yt = {}), Yt;
  }
  return le.fromWeb = function(A, T) {
    return qr().newStreamReadableFromReadableStream(A, T);
  }, le.toWeb = function(A, T) {
    return qr().newReadableStreamFromStreamReadable(A, T);
  }, le.wrap = function(A, T) {
    var G, K;
    return new le({
      objectMode: (G = (K = A.readableObjectMode) !== null && K !== void 0 ? K : A.objectMode) !== null && G !== void 0 ? G : !0,
      ...T,
      destroy($, Be) {
        I.destroyer(A, $), Be($);
      }
    }).wrap(A);
  }, ni;
}
var ii, ro;
function as() {
  if (ro) return ii;
  ro = 1;
  const e = _t, {
    ArrayPrototypeSlice: t,
    Error: r,
    FunctionPrototypeSymbolHasInstance: i,
    ObjectDefineProperty: o,
    ObjectDefineProperties: c,
    ObjectSetPrototypeOf: n,
    StringPrototypeToLowerCase: u,
    Symbol: _,
    SymbolHasInstance: F
  } = ke;
  ii = ie, ie.WritableState = W;
  const { EventEmitter: d } = mr, s = ss.Stream, { Buffer: l } = yt, h = br, { addAbortSignal: b } = kn, { getHighWaterMark: p, getDefaultHighWaterMark: S } = Mn, {
    ERR_INVALID_ARG_TYPE: E,
    ERR_METHOD_NOT_IMPLEMENTED: v,
    ERR_MULTIPLE_CALLBACK: m,
    ERR_STREAM_CANNOT_PIPE: N,
    ERR_STREAM_DESTROYED: I,
    ERR_STREAM_ALREADY_FINISHED: M,
    ERR_STREAM_NULL_VALUES: H,
    ERR_STREAM_WRITE_AFTER_END: x,
    ERR_UNKNOWN_ENCODING: Y
  } = qe.codes, { errorOrDestroy: X } = h;
  n(ie.prototype, s.prototype), n(ie, s);
  function oe() {
  }
  const Z = _("kOnFinished");
  function W(D, k, V) {
    typeof V != "boolean" && (V = k instanceof mt()), this.objectMode = !!(D && D.objectMode), V && (this.objectMode = this.objectMode || !!(D && D.writableObjectMode)), this.highWaterMark = D ? p(this, D, "writableHighWaterMark", V) : S(!1), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    const te = !!(D && D.decodeStrings === !1);
    this.decodeStrings = !te, this.defaultEncoding = D && D.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = pe.bind(void 0, k), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, ae(this), this.pendingcb = 0, this.constructed = !0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !D || D.emitClose !== !1, this.autoDestroy = !D || D.autoDestroy !== !1, this.errored = null, this.closed = !1, this.closeEmitted = !1, this[Z] = [];
  }
  function ae(D) {
    D.buffered = [], D.bufferedIndex = 0, D.allBuffers = !0, D.allNoop = !0;
  }
  W.prototype.getBuffer = function() {
    return t(this.buffered, this.bufferedIndex);
  }, o(W.prototype, "bufferedRequestCount", {
    __proto__: null,
    get() {
      return this.buffered.length - this.bufferedIndex;
    }
  });
  function ie(D) {
    const k = this instanceof mt();
    if (!k && !i(ie, this)) return new ie(D);
    this._writableState = new W(D, this, k), D && (typeof D.write == "function" && (this._write = D.write), typeof D.writev == "function" && (this._writev = D.writev), typeof D.destroy == "function" && (this._destroy = D.destroy), typeof D.final == "function" && (this._final = D.final), typeof D.construct == "function" && (this._construct = D.construct), D.signal && b(D.signal, this)), s.call(this, D), h.construct(this, () => {
      const V = this._writableState;
      V.writing || q(this, V), he(this, V);
    });
  }
  o(ie, F, {
    __proto__: null,
    value: function(D) {
      return i(this, D) ? !0 : this !== ie ? !1 : D && D._writableState instanceof W;
    }
  }), ie.prototype.pipe = function() {
    X(this, new N());
  };
  function ne(D, k, V, te) {
    const re = D._writableState;
    if (typeof V == "function")
      te = V, V = re.defaultEncoding;
    else {
      if (!V) V = re.defaultEncoding;
      else if (V !== "buffer" && !l.isEncoding(V)) throw new Y(V);
      typeof te != "function" && (te = oe);
    }
    if (k === null)
      throw new H();
    if (!re.objectMode)
      if (typeof k == "string")
        re.decodeStrings !== !1 && (k = l.from(k, V), V = "buffer");
      else if (k instanceof l)
        V = "buffer";
      else if (s._isUint8Array(k))
        k = s._uint8ArrayToBuffer(k), V = "buffer";
      else
        throw new E("chunk", ["string", "Buffer", "Uint8Array"], k);
    let Q;
    return re.ending ? Q = new x() : re.destroyed && (Q = new I("write")), Q ? (e.nextTick(te, Q), X(D, Q, !0), Q) : (re.pendingcb++, we(D, re, k, V, te));
  }
  ie.prototype.write = function(D, k, V) {
    return ne(this, D, k, V) === !0;
  }, ie.prototype.cork = function() {
    this._writableState.corked++;
  }, ie.prototype.uncork = function() {
    const D = this._writableState;
    D.corked && (D.corked--, D.writing || q(this, D));
  }, ie.prototype.setDefaultEncoding = function(k) {
    if (typeof k == "string" && (k = u(k)), !l.isEncoding(k)) throw new Y(k);
    return this._writableState.defaultEncoding = k, this;
  };
  function we(D, k, V, te, re) {
    const Q = k.objectMode ? 1 : V.length;
    k.length += Q;
    const L = k.length < k.highWaterMark;
    return L || (k.needDrain = !0), k.writing || k.corked || k.errored || !k.constructed ? (k.buffered.push({
      chunk: V,
      encoding: te,
      callback: re
    }), k.allBuffers && te !== "buffer" && (k.allBuffers = !1), k.allNoop && re !== oe && (k.allNoop = !1)) : (k.writelen = Q, k.writecb = re, k.writing = !0, k.sync = !0, D._write(V, te, k.onwrite), k.sync = !1), L && !k.errored && !k.destroyed;
  }
  function me(D, k, V, te, re, Q, L) {
    k.writelen = te, k.writecb = L, k.writing = !0, k.sync = !0, k.destroyed ? k.onwrite(new I("write")) : V ? D._writev(re, k.onwrite) : D._write(re, Q, k.onwrite), k.sync = !1;
  }
  function _e(D, k, V, te) {
    --k.pendingcb, te(V), U(k), X(D, V);
  }
  function pe(D, k) {
    const V = D._writableState, te = V.sync, re = V.writecb;
    if (typeof re != "function") {
      X(D, new m());
      return;
    }
    V.writing = !1, V.writecb = null, V.length -= V.writelen, V.writelen = 0, k ? (k.stack, V.errored || (V.errored = k), D._readableState && !D._readableState.errored && (D._readableState.errored = k), te ? e.nextTick(_e, D, V, k, re) : _e(D, V, k, re)) : (V.buffered.length > V.bufferedIndex && q(D, V), te ? V.afterWriteTickInfo !== null && V.afterWriteTickInfo.cb === re ? V.afterWriteTickInfo.count++ : (V.afterWriteTickInfo = {
      count: 1,
      cb: re,
      stream: D,
      state: V
    }, e.nextTick(B, V.afterWriteTickInfo)) : j(D, V, 1, re));
  }
  function B({ stream: D, state: k, count: V, cb: te }) {
    return k.afterWriteTickInfo = null, j(D, k, V, te);
  }
  function j(D, k, V, te) {
    for (!k.ending && !D.destroyed && k.length === 0 && k.needDrain && (k.needDrain = !1, D.emit("drain")); V-- > 0; )
      k.pendingcb--, te();
    k.destroyed && U(k), he(D, k);
  }
  function U(D) {
    if (D.writing)
      return;
    for (let re = D.bufferedIndex; re < D.buffered.length; ++re) {
      var k;
      const { chunk: Q, callback: L } = D.buffered[re], Se = D.objectMode ? 1 : Q.length;
      D.length -= Se, L(
        (k = D.errored) !== null && k !== void 0 ? k : new I("write")
      );
    }
    const V = D[Z].splice(0);
    for (let re = 0; re < V.length; re++) {
      var te;
      V[re](
        (te = D.errored) !== null && te !== void 0 ? te : new I("end")
      );
    }
    ae(D);
  }
  function q(D, k) {
    if (k.corked || k.bufferProcessing || k.destroyed || !k.constructed)
      return;
    const { buffered: V, bufferedIndex: te, objectMode: re } = k, Q = V.length - te;
    if (!Q)
      return;
    let L = te;
    if (k.bufferProcessing = !0, Q > 1 && D._writev) {
      k.pendingcb -= Q - 1;
      const Se = k.allNoop ? oe : (le) => {
        for (let De = L; De < V.length; ++De)
          V[De].callback(le);
      }, Ke = k.allNoop && L === 0 ? V : t(V, L);
      Ke.allBuffers = k.allBuffers, me(D, k, !0, k.length, Ke, "", Se), ae(k);
    } else {
      do {
        const { chunk: Se, encoding: Ke, callback: le } = V[L];
        V[L++] = null;
        const De = re ? 1 : Se.length;
        me(D, k, !1, De, Se, Ke, le);
      } while (L < V.length && !k.writing);
      L === V.length ? ae(k) : L > 256 ? (V.splice(0, L), k.bufferedIndex = 0) : k.bufferedIndex = L;
    }
    k.bufferProcessing = !1;
  }
  ie.prototype._write = function(D, k, V) {
    if (this._writev)
      this._writev(
        [
          {
            chunk: D,
            encoding: k
          }
        ],
        V
      );
    else
      throw new v("_write()");
  }, ie.prototype._writev = null, ie.prototype.end = function(D, k, V) {
    const te = this._writableState;
    typeof D == "function" ? (V = D, D = null, k = null) : typeof k == "function" && (V = k, k = null);
    let re;
    if (D != null) {
      const Q = ne(this, D, k);
      Q instanceof r && (re = Q);
    }
    return te.corked && (te.corked = 1, this.uncork()), re || (!te.errored && !te.ending ? (te.ending = !0, he(this, te, !0), te.ended = !0) : te.finished ? re = new M("end") : te.destroyed && (re = new I("end"))), typeof V == "function" && (re || te.finished ? e.nextTick(V, re) : te[Z].push(V)), this;
  };
  function fe(D) {
    return D.ending && !D.destroyed && D.constructed && D.length === 0 && !D.errored && D.buffered.length === 0 && !D.finished && !D.writing && !D.errorEmitted && !D.closeEmitted;
  }
  function ge(D, k) {
    let V = !1;
    function te(re) {
      if (V) {
        X(D, re ?? m());
        return;
      }
      if (V = !0, k.pendingcb--, re) {
        const Q = k[Z].splice(0);
        for (let L = 0; L < Q.length; L++)
          Q[L](re);
        X(D, re, k.sync);
      } else fe(k) && (k.prefinished = !0, D.emit("prefinish"), k.pendingcb++, e.nextTick(ye, D, k));
    }
    k.sync = !0, k.pendingcb++;
    try {
      D._final(te);
    } catch (re) {
      te(re);
    }
    k.sync = !1;
  }
  function de(D, k) {
    !k.prefinished && !k.finalCalled && (typeof D._final == "function" && !k.destroyed ? (k.finalCalled = !0, ge(D, k)) : (k.prefinished = !0, D.emit("prefinish")));
  }
  function he(D, k, V) {
    fe(k) && (de(D, k), k.pendingcb === 0 && (V ? (k.pendingcb++, e.nextTick(
      (te, re) => {
        fe(re) ? ye(te, re) : re.pendingcb--;
      },
      D,
      k
    )) : fe(k) && (k.pendingcb++, ye(D, k))));
  }
  function ye(D, k) {
    k.pendingcb--, k.finished = !0;
    const V = k[Z].splice(0);
    for (let te = 0; te < V.length; te++)
      V[te]();
    if (D.emit("finish"), k.autoDestroy) {
      const te = D._readableState;
      (!te || te.autoDestroy && // We don't expect the readable to ever 'end'
      // if readable is explicitly set to false.
      (te.endEmitted || te.readable === !1)) && D.destroy();
    }
  }
  c(ie.prototype, {
    closed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.closed : !1;
      }
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.destroyed : !1;
      },
      set(D) {
        this._writableState && (this._writableState.destroyed = D);
      }
    },
    writable: {
      __proto__: null,
      get() {
        const D = this._writableState;
        return !!D && D.writable !== !1 && !D.destroyed && !D.errored && !D.ending && !D.ended;
      },
      set(D) {
        this._writableState && (this._writableState.writable = !!D);
      }
    },
    writableFinished: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.finished : !1;
      }
    },
    writableObjectMode: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.objectMode : !1;
      }
    },
    writableBuffer: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.getBuffer();
      }
    },
    writableEnded: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.ending : !1;
      }
    },
    writableNeedDrain: {
      __proto__: null,
      get() {
        const D = this._writableState;
        return D ? !D.destroyed && !D.ending && D.needDrain : !1;
      }
    },
    writableHighWaterMark: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.highWaterMark;
      }
    },
    writableCorked: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.corked : 0;
      }
    },
    writableLength: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.length;
      }
    },
    errored: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._writableState ? this._writableState.errored : null;
      }
    },
    writableAborted: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return !!(this._writableState.writable !== !1 && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
      }
    }
  });
  const Fe = h.destroy;
  ie.prototype.destroy = function(D, k) {
    const V = this._writableState;
    return !V.destroyed && (V.bufferedIndex < V.buffered.length || V[Z].length) && e.nextTick(U, V), Fe.call(this, D, k), this;
  }, ie.prototype._undestroy = h.undestroy, ie.prototype._destroy = function(D, k) {
    k(D);
  }, ie.prototype[d.captureRejectionSymbol] = function(D) {
    this.destroy(D);
  };
  let ze;
  function Ge() {
    return ze === void 0 && (ze = {}), ze;
  }
  return ie.fromWeb = function(D, k) {
    return Ge().newStreamWritableFromWritableStream(D, k);
  }, ie.toWeb = function(D) {
    return Ge().newWritableStreamFromStreamWritable(D);
  }, ii;
}
var si, no;
function od() {
  if (no) return si;
  no = 1;
  const e = _t, t = yt, {
    isReadable: r,
    isWritable: i,
    isIterable: o,
    isNodeStream: c,
    isReadableNodeStream: n,
    isWritableNodeStream: u,
    isDuplexNodeStream: _,
    isReadableStream: F,
    isWritableStream: d
  } = St, s = Dt, {
    AbortError: l,
    codes: { ERR_INVALID_ARG_TYPE: h, ERR_INVALID_RETURN_VALUE: b }
  } = qe, { destroyer: p } = br, S = mt(), E = Cn(), v = as(), { createDeferredPromise: m } = Ve, N = Ca, I = globalThis.Blob || t.Blob, M = typeof I < "u" ? function(W) {
    return W instanceof I;
  } : function(W) {
    return !1;
  }, H = globalThis.AbortController || Mr().AbortController, { FunctionPrototypeCall: x } = ke;
  class Y extends S {
    constructor(W) {
      super(W), W?.readable === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), W?.writable === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0);
    }
  }
  si = function Z(W, ae) {
    if (_(W))
      return W;
    if (n(W))
      return oe({
        readable: W
      });
    if (u(W))
      return oe({
        writable: W
      });
    if (c(W))
      return oe({
        writable: !1,
        readable: !1
      });
    if (F(W))
      return oe({
        readable: E.fromWeb(W)
      });
    if (d(W))
      return oe({
        writable: v.fromWeb(W)
      });
    if (typeof W == "function") {
      const { value: ne, write: we, final: me, destroy: _e } = X(W);
      if (o(ne))
        return N(Y, ne, {
          // TODO (ronag): highWaterMark?
          objectMode: !0,
          write: we,
          final: me,
          destroy: _e
        });
      const pe = ne?.then;
      if (typeof pe == "function") {
        let B;
        const j = x(
          pe,
          ne,
          (U) => {
            if (U != null)
              throw new b("nully", "body", U);
          },
          (U) => {
            p(B, U);
          }
        );
        return B = new Y({
          // TODO (ronag): highWaterMark?
          objectMode: !0,
          readable: !1,
          write: we,
          final(U) {
            me(async () => {
              try {
                await j, e.nextTick(U, null);
              } catch (q) {
                e.nextTick(U, q);
              }
            });
          },
          destroy: _e
        });
      }
      throw new b("Iterable, AsyncIterable or AsyncFunction", ae, ne);
    }
    if (M(W))
      return Z(W.arrayBuffer());
    if (o(W))
      return N(Y, W, {
        // TODO (ronag): highWaterMark?
        objectMode: !0,
        writable: !1
      });
    if (F(W?.readable) && d(W?.writable))
      return Y.fromWeb(W);
    if (typeof W?.writable == "object" || typeof W?.readable == "object") {
      const ne = W != null && W.readable ? n(W?.readable) ? W?.readable : Z(W.readable) : void 0, we = W != null && W.writable ? u(W?.writable) ? W?.writable : Z(W.writable) : void 0;
      return oe({
        readable: ne,
        writable: we
      });
    }
    const ie = W?.then;
    if (typeof ie == "function") {
      let ne;
      return x(
        ie,
        W,
        (we) => {
          we != null && ne.push(we), ne.push(null);
        },
        (we) => {
          p(ne, we);
        }
      ), ne = new Y({
        objectMode: !0,
        writable: !1,
        read() {
        }
      });
    }
    throw new h(
      ae,
      [
        "Blob",
        "ReadableStream",
        "WritableStream",
        "Stream",
        "Iterable",
        "AsyncIterable",
        "Function",
        "{ readable, writable } pair",
        "Promise"
      ],
      W
    );
  };
  function X(Z) {
    let { promise: W, resolve: ae } = m();
    const ie = new H(), ne = ie.signal;
    return {
      value: Z(
        async function* () {
          for (; ; ) {
            const me = W;
            W = null;
            const { chunk: _e, done: pe, cb: B } = await me;
            if (e.nextTick(B), pe) return;
            if (ne.aborted)
              throw new l(void 0, {
                cause: ne.reason
              });
            ({ promise: W, resolve: ae } = m()), yield _e;
          }
        }(),
        {
          signal: ne
        }
      ),
      write(me, _e, pe) {
        const B = ae;
        ae = null, B({
          chunk: me,
          done: !1,
          cb: pe
        });
      },
      final(me) {
        const _e = ae;
        ae = null, _e({
          done: !0,
          cb: me
        });
      },
      destroy(me, _e) {
        ie.abort(), _e(me);
      }
    };
  }
  function oe(Z) {
    const W = Z.readable && typeof Z.readable.read != "function" ? E.wrap(Z.readable) : Z.readable, ae = Z.writable;
    let ie = !!r(W), ne = !!i(ae), we, me, _e, pe, B;
    function j(U) {
      const q = pe;
      pe = null, q ? q(U) : U && B.destroy(U);
    }
    return B = new Y({
      // TODO (ronag): highWaterMark?
      readableObjectMode: !!(W != null && W.readableObjectMode),
      writableObjectMode: !!(ae != null && ae.writableObjectMode),
      readable: ie,
      writable: ne
    }), ne && (s(ae, (U) => {
      ne = !1, U && p(W, U), j(U);
    }), B._write = function(U, q, fe) {
      ae.write(U, q) ? fe() : we = fe;
    }, B._final = function(U) {
      ae.end(), me = U;
    }, ae.on("drain", function() {
      if (we) {
        const U = we;
        we = null, U();
      }
    }), ae.on("finish", function() {
      if (me) {
        const U = me;
        me = null, U();
      }
    })), ie && (s(W, (U) => {
      ie = !1, U && p(W, U), j(U);
    }), W.on("readable", function() {
      if (_e) {
        const U = _e;
        _e = null, U();
      }
    }), W.on("end", function() {
      B.push(null);
    }), B._read = function() {
      for (; ; ) {
        const U = W.read();
        if (U === null) {
          _e = B._read;
          return;
        }
        if (!B.push(U))
          return;
      }
    }), B._destroy = function(U, q) {
      !U && pe !== null && (U = new l()), _e = null, we = null, me = null, pe === null ? q(U) : (pe = q, p(ae, U), p(W, U));
    }, B;
  }
  return si;
}
var oi, io;
function mt() {
  if (io) return oi;
  io = 1;
  const {
    ObjectDefineProperties: e,
    ObjectGetOwnPropertyDescriptor: t,
    ObjectKeys: r,
    ObjectSetPrototypeOf: i
  } = ke;
  oi = n;
  const o = Cn(), c = as();
  i(n.prototype, o.prototype), i(n, o);
  {
    const d = r(c.prototype);
    for (let s = 0; s < d.length; s++) {
      const l = d[s];
      n.prototype[l] || (n.prototype[l] = c.prototype[l]);
    }
  }
  function n(d) {
    if (!(this instanceof n)) return new n(d);
    o.call(this, d), c.call(this, d), d ? (this.allowHalfOpen = d.allowHalfOpen !== !1, d.readable === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), d.writable === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0)) : this.allowHalfOpen = !0;
  }
  e(n.prototype, {
    writable: {
      __proto__: null,
      ...t(c.prototype, "writable")
    },
    writableHighWaterMark: {
      __proto__: null,
      ...t(c.prototype, "writableHighWaterMark")
    },
    writableObjectMode: {
      __proto__: null,
      ...t(c.prototype, "writableObjectMode")
    },
    writableBuffer: {
      __proto__: null,
      ...t(c.prototype, "writableBuffer")
    },
    writableLength: {
      __proto__: null,
      ...t(c.prototype, "writableLength")
    },
    writableFinished: {
      __proto__: null,
      ...t(c.prototype, "writableFinished")
    },
    writableCorked: {
      __proto__: null,
      ...t(c.prototype, "writableCorked")
    },
    writableEnded: {
      __proto__: null,
      ...t(c.prototype, "writableEnded")
    },
    writableNeedDrain: {
      __proto__: null,
      ...t(c.prototype, "writableNeedDrain")
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
      },
      set(d) {
        this._readableState && this._writableState && (this._readableState.destroyed = d, this._writableState.destroyed = d);
      }
    }
  });
  let u;
  function _() {
    return u === void 0 && (u = {}), u;
  }
  n.fromWeb = function(d, s) {
    return _().newStreamDuplexFromReadableWritablePair(d, s);
  }, n.toWeb = function(d) {
    return _().newReadableWritablePairFromDuplex(d);
  };
  let F;
  return n.from = function(d) {
    return F || (F = od()), F(d, "body");
  }, oi;
}
const { ObjectSetPrototypeOf: La, Symbol: ad } = ke;
var Ua = bt;
const { ERR_METHOD_NOT_IMPLEMENTED: ld } = qe.codes, ls = mt(), { getHighWaterMark: fd } = Mn;
La(bt.prototype, ls.prototype);
La(bt, ls);
const kr = ad("kCallback");
function bt(e) {
  if (!(this instanceof bt)) return new bt(e);
  const t = e ? fd(this, e, "readableHighWaterMark", !0) : null;
  t === 0 && (e = {
    ...e,
    highWaterMark: null,
    readableHighWaterMark: t,
    // TODO (ronag): 0 is not optimal since we have
    // a "bug" where we check needDrain before calling _write and not after.
    // Refs: https://github.com/nodejs/node/pull/32887
    // Refs: https://github.com/nodejs/node/pull/35941
    writableHighWaterMark: e.writableHighWaterMark || 0
  }), ls.call(this, e), this._readableState.sync = !1, this[kr] = null, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", ud);
}
function xi(e) {
  typeof this._flush == "function" && !this.destroyed ? this._flush((t, r) => {
    if (t) {
      e ? e(t) : this.destroy(t);
      return;
    }
    r != null && this.push(r), this.push(null), e && e();
  }) : (this.push(null), e && e());
}
function ud() {
  this._final !== xi && xi.call(this);
}
bt.prototype._final = xi;
bt.prototype._transform = function(e, t, r) {
  throw new ld("_transform()");
};
bt.prototype._write = function(e, t, r) {
  const i = this._readableState, o = this._writableState, c = i.length;
  this._transform(e, t, (n, u) => {
    if (n) {
      r(n);
      return;
    }
    u != null && this.push(u), o.ended || // Backwards compat.
    c === i.length || // Backwards compat.
    i.length < i.highWaterMark ? r() : this[kr] = r;
  });
};
bt.prototype._read = function() {
  if (this[kr]) {
    const e = this[kr];
    this[kr] = null, e();
  }
};
const { ObjectSetPrototypeOf: Wa } = ke;
var ja = hr;
const fs = Ua;
Wa(hr.prototype, fs.prototype);
Wa(hr, fs);
function hr(e) {
  if (!(this instanceof hr)) return new hr(e);
  fs.call(this, e);
}
hr.prototype._transform = function(e, t, r) {
  r(null, e);
};
const Or = _t, { ArrayIsArray: cd, Promise: dd, SymbolAsyncIterator: hd, SymbolDispose: yd } = ke, Sn = Dt, { once: pd } = Ve, gd = br, so = mt(), {
  aggregateTwoErrors: md,
  codes: {
    ERR_INVALID_ARG_TYPE: Hi,
    ERR_INVALID_RETURN_VALUE: ai,
    ERR_MISSING_ARGS: bd,
    ERR_STREAM_DESTROYED: wd,
    ERR_STREAM_PREMATURE_CLOSE: _d
  },
  AbortError: Sd
} = qe, { validateFunction: vd, validateAbortSignal: Ed } = Ur, {
  isIterable: Ut,
  isReadable: li,
  isReadableNodeStream: yn,
  isNodeStream: oo,
  isTransformStream: tr,
  isWebStream: Ad,
  isReadableStream: fi,
  isReadableFinished: Td
} = St, Rd = globalThis.AbortController || Mr().AbortController;
let ui, ci, di;
function ao(e, t, r) {
  let i = !1;
  e.on("close", () => {
    i = !0;
  });
  const o = Sn(
    e,
    {
      readable: t,
      writable: r
    },
    (c) => {
      i = !c;
    }
  );
  return {
    destroy: (c) => {
      i || (i = !0, gd.destroyer(e, c || new wd("pipe")));
    },
    cleanup: o
  };
}
function Id(e) {
  return vd(e[e.length - 1], "streams[stream.length - 1]"), e.pop();
}
function hi(e) {
  if (Ut(e))
    return e;
  if (yn(e))
    return Fd(e);
  throw new Hi("val", ["Readable", "Iterable", "AsyncIterable"], e);
}
async function* Fd(e) {
  ci || (ci = Cn()), yield* ci.prototype[hd].call(e);
}
async function tn(e, t, r, { end: i }) {
  let o, c = null;
  const n = (F) => {
    if (F && (o = F), c) {
      const d = c;
      c = null, d();
    }
  }, u = () => new dd((F, d) => {
    o ? d(o) : c = () => {
      o ? d(o) : F();
    };
  });
  t.on("drain", n);
  const _ = Sn(
    t,
    {
      readable: !1
    },
    n
  );
  try {
    t.writableNeedDrain && await u();
    for await (const F of e)
      t.write(F) || await u();
    i && (t.end(), await u()), r();
  } catch (F) {
    r(o !== F ? md(o, F) : F);
  } finally {
    _(), t.off("drain", n);
  }
}
async function yi(e, t, r, { end: i }) {
  tr(t) && (t = t.writable);
  const o = t.getWriter();
  try {
    for await (const c of e)
      await o.ready, o.write(c).catch(() => {
      });
    await o.ready, i && await o.close(), r();
  } catch (c) {
    try {
      await o.abort(c), r(c);
    } catch (n) {
      r(n);
    }
  }
}
function Nd(...e) {
  return $a(e, pd(Id(e)));
}
function $a(e, t, r) {
  if (e.length === 1 && cd(e[0]) && (e = e[0]), e.length < 2)
    throw new bd("streams");
  const i = new Rd(), o = i.signal, c = r?.signal, n = [];
  Ed(c, "options.signal");
  function u() {
    b(new Sd());
  }
  di = di || Ve.addAbortListener;
  let _;
  c && (_ = di(c, u));
  let F, d;
  const s = [];
  let l = 0;
  function h(v) {
    b(v, --l === 0);
  }
  function b(v, m) {
    var N;
    if (v && (!F || F.code === "ERR_STREAM_PREMATURE_CLOSE") && (F = v), !(!F && !m)) {
      for (; s.length; )
        s.shift()(F);
      (N = _) === null || N === void 0 || N[yd](), i.abort(), m && (F || n.forEach((I) => I()), Or.nextTick(t, F, d));
    }
  }
  let p;
  for (let v = 0; v < e.length; v++) {
    const m = e[v], N = v < e.length - 1, I = v > 0, M = N || r?.end !== !1, H = v === e.length - 1;
    if (oo(m)) {
      let x = function(Y) {
        Y && Y.name !== "AbortError" && Y.code !== "ERR_STREAM_PREMATURE_CLOSE" && h(Y);
      };
      if (M) {
        const { destroy: Y, cleanup: X } = ao(m, N, I);
        s.push(Y), li(m) && H && n.push(X);
      }
      m.on("error", x), li(m) && H && n.push(() => {
        m.removeListener("error", x);
      });
    }
    if (v === 0)
      if (typeof m == "function") {
        if (p = m({
          signal: o
        }), !Ut(p))
          throw new ai("Iterable, AsyncIterable or Stream", "source", p);
      } else Ut(m) || yn(m) || tr(m) ? p = m : p = so.from(m);
    else if (typeof m == "function") {
      if (tr(p)) {
        var S;
        p = hi((S = p) === null || S === void 0 ? void 0 : S.readable);
      } else
        p = hi(p);
      if (p = m(p, {
        signal: o
      }), N) {
        if (!Ut(p, !0))
          throw new ai("AsyncIterable", `transform[${v - 1}]`, p);
      } else {
        var E;
        ui || (ui = ja);
        const x = new ui({
          objectMode: !0
        }), Y = (E = p) === null || E === void 0 ? void 0 : E.then;
        if (typeof Y == "function")
          l++, Y.call(
            p,
            (Z) => {
              d = Z, Z != null && x.write(Z), M && x.end(), Or.nextTick(h);
            },
            (Z) => {
              x.destroy(Z), Or.nextTick(h, Z);
            }
          );
        else if (Ut(p, !0))
          l++, tn(p, x, h, {
            end: M
          });
        else if (fi(p) || tr(p)) {
          const Z = p.readable || p;
          l++, tn(Z, x, h, {
            end: M
          });
        } else
          throw new ai("AsyncIterable or Promise", "destination", p);
        p = x;
        const { destroy: X, cleanup: oe } = ao(p, !1, !0);
        s.push(X), H && n.push(oe);
      }
    } else if (oo(m)) {
      if (yn(p)) {
        l += 2;
        const x = Od(p, m, h, {
          end: M
        });
        li(m) && H && n.push(x);
      } else if (tr(p) || fi(p)) {
        const x = p.readable || p;
        l++, tn(x, m, h, {
          end: M
        });
      } else if (Ut(p))
        l++, tn(p, m, h, {
          end: M
        });
      else
        throw new Hi(
          "val",
          ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
          p
        );
      p = m;
    } else if (Ad(m)) {
      if (yn(p))
        l++, yi(hi(p), m, h, {
          end: M
        });
      else if (fi(p) || Ut(p))
        l++, yi(p, m, h, {
          end: M
        });
      else if (tr(p))
        l++, yi(p.readable, m, h, {
          end: M
        });
      else
        throw new Hi(
          "val",
          ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
          p
        );
      p = m;
    } else
      p = so.from(m);
  }
  return (o != null && o.aborted || c != null && c.aborted) && Or.nextTick(u), p;
}
function Od(e, t, r, { end: i }) {
  let o = !1;
  if (t.on("close", () => {
    o || r(new _d());
  }), e.pipe(t, {
    end: !1
  }), i) {
    let c = function() {
      o = !0, t.end();
    };
    Td(e) ? Or.nextTick(c) : e.once("end", c);
  } else
    r();
  return Sn(
    e,
    {
      readable: !0,
      writable: !1
    },
    (c) => {
      const n = e._readableState;
      c && c.code === "ERR_STREAM_PREMATURE_CLOSE" && n && n.ended && !n.errored && !n.errorEmitted ? e.once("end", r).once("error", r) : r(c);
    }
  ), Sn(
    t,
    {
      readable: !1,
      writable: !0
    },
    r
  );
}
var us = {
  pipelineImpl: $a,
  pipeline: Nd
};
const { pipeline: Dd } = us, rn = mt(), { destroyer: Bd } = br, {
  isNodeStream: nn,
  isReadable: lo,
  isWritable: fo,
  isWebStream: pi,
  isTransformStream: Lt,
  isWritableStream: uo,
  isReadableStream: co
} = St, {
  AbortError: Pd,
  codes: { ERR_INVALID_ARG_VALUE: ho, ERR_MISSING_ARGS: kd }
} = qe, Md = Dt;
var xa = function(...t) {
  if (t.length === 0)
    throw new kd("streams");
  if (t.length === 1)
    return rn.from(t[0]);
  const r = [...t];
  if (typeof t[0] == "function" && (t[0] = rn.from(t[0])), typeof t[t.length - 1] == "function") {
    const h = t.length - 1;
    t[h] = rn.from(t[h]);
  }
  for (let h = 0; h < t.length; ++h)
    if (!(!nn(t[h]) && !pi(t[h]))) {
      if (h < t.length - 1 && !(lo(t[h]) || co(t[h]) || Lt(t[h])))
        throw new ho(`streams[${h}]`, r[h], "must be readable");
      if (h > 0 && !(fo(t[h]) || uo(t[h]) || Lt(t[h])))
        throw new ho(`streams[${h}]`, r[h], "must be writable");
    }
  let i, o, c, n, u;
  function _(h) {
    const b = n;
    n = null, b ? b(h) : h ? u.destroy(h) : !l && !s && u.destroy();
  }
  const F = t[0], d = Dd(t, _), s = !!(fo(F) || uo(F) || Lt(F)), l = !!(lo(d) || co(d) || Lt(d));
  if (u = new rn({
    // TODO (ronag): highWaterMark?
    writableObjectMode: !!(F != null && F.writableObjectMode),
    readableObjectMode: !!(d != null && d.readableObjectMode),
    writable: s,
    readable: l
  }), s) {
    if (nn(F))
      u._write = function(b, p, S) {
        F.write(b, p) ? S() : i = S;
      }, u._final = function(b) {
        F.end(), o = b;
      }, F.on("drain", function() {
        if (i) {
          const b = i;
          i = null, b();
        }
      });
    else if (pi(F)) {
      const p = (Lt(F) ? F.writable : F).getWriter();
      u._write = async function(S, E, v) {
        try {
          await p.ready, p.write(S).catch(() => {
          }), v();
        } catch (m) {
          v(m);
        }
      }, u._final = async function(S) {
        try {
          await p.ready, p.close().catch(() => {
          }), o = S;
        } catch (E) {
          S(E);
        }
      };
    }
    const h = Lt(d) ? d.readable : d;
    Md(h, () => {
      if (o) {
        const b = o;
        o = null, b();
      }
    });
  }
  if (l) {
    if (nn(d))
      d.on("readable", function() {
        if (c) {
          const h = c;
          c = null, h();
        }
      }), d.on("end", function() {
        u.push(null);
      }), u._read = function() {
        for (; ; ) {
          const h = d.read();
          if (h === null) {
            c = u._read;
            return;
          }
          if (!u.push(h))
            return;
        }
      };
    else if (pi(d)) {
      const b = (Lt(d) ? d.readable : d).getReader();
      u._read = async function() {
        for (; ; )
          try {
            const { value: p, done: S } = await b.read();
            if (!u.push(p))
              return;
            if (S) {
              u.push(null);
              return;
            }
          } catch {
            return;
          }
      };
    }
  }
  return u._destroy = function(h, b) {
    !h && n !== null && (h = new Pd()), c = null, i = null, o = null, n === null ? b(h) : (n = b, nn(d) && Bd(d, h));
  }, u;
};
const Cd = globalThis.AbortController || Mr().AbortController, {
  codes: { ERR_INVALID_ARG_VALUE: Ld, ERR_INVALID_ARG_TYPE: jr, ERR_MISSING_ARGS: Ud, ERR_OUT_OF_RANGE: Wd },
  AbortError: ht
} = qe, { validateAbortSignal: Vt, validateInteger: yo, validateObject: Gt } = Ur, jd = ke.Symbol("kWeak"), $d = ke.Symbol("kResistStopPropagation"), { finished: xd } = Dt, Hd = xa, { addAbortSignalNoValidate: zd } = kn, { isWritable: Vd, isNodeStream: Gd } = St, { deprecate: Kd } = Ve, {
  ArrayPrototypePush: Yd,
  Boolean: qd,
  MathFloor: po,
  Number: Jd,
  NumberIsNaN: Xd,
  Promise: go,
  PromiseReject: mo,
  PromiseResolve: Zd,
  PromisePrototypeThen: bo,
  Symbol: Ha
} = ke, vn = Ha("kEmpty"), wo = Ha("kEof");
function Qd(e, t) {
  if (t != null && Gt(t, "options"), t?.signal != null && Vt(t.signal, "options.signal"), Gd(e) && !Vd(e))
    throw new Ld("stream", e, "must be writable");
  const r = Hd(this, e);
  return t != null && t.signal && zd(t.signal, r), r;
}
function Ln(e, t) {
  if (typeof e != "function")
    throw new jr("fn", ["Function", "AsyncFunction"], e);
  t != null && Gt(t, "options"), t?.signal != null && Vt(t.signal, "options.signal");
  let r = 1;
  t?.concurrency != null && (r = po(t.concurrency));
  let i = r - 1;
  return t?.highWaterMark != null && (i = po(t.highWaterMark)), yo(r, "options.concurrency", 1), yo(i, "options.highWaterMark", 0), i += r, async function* () {
    const c = Ve.AbortSignalAny(
      [t?.signal].filter(qd)
    ), n = this, u = [], _ = {
      signal: c
    };
    let F, d, s = !1, l = 0;
    function h() {
      s = !0, b();
    }
    function b() {
      l -= 1, p();
    }
    function p() {
      d && !s && l < r && u.length < i && (d(), d = null);
    }
    async function S() {
      try {
        for await (let E of n) {
          if (s)
            return;
          if (c.aborted)
            throw new ht();
          try {
            if (E = e(E, _), E === vn)
              continue;
            E = Zd(E);
          } catch (v) {
            E = mo(v);
          }
          l += 1, bo(E, b, h), u.push(E), F && (F(), F = null), !s && (u.length >= i || l >= r) && await new go((v) => {
            d = v;
          });
        }
        u.push(wo);
      } catch (E) {
        const v = mo(E);
        bo(v, b, h), u.push(v);
      } finally {
        s = !0, F && (F(), F = null);
      }
    }
    S();
    try {
      for (; ; ) {
        for (; u.length > 0; ) {
          const E = await u[0];
          if (E === wo)
            return;
          if (c.aborted)
            throw new ht();
          E !== vn && (yield E), u.shift(), p();
        }
        await new go((E) => {
          F = E;
        });
      }
    } finally {
      s = !0, d && (d(), d = null);
    }
  }.call(this);
}
function eh(e = void 0) {
  return e != null && Gt(e, "options"), e?.signal != null && Vt(e.signal, "options.signal"), async function* () {
    let r = 0;
    for await (const o of this) {
      var i;
      if (e != null && (i = e.signal) !== null && i !== void 0 && i.aborted)
        throw new ht({
          cause: e.signal.reason
        });
      yield [r++, o];
    }
  }.call(this);
}
async function za(e, t = void 0) {
  for await (const r of cs.call(this, e, t))
    return !0;
  return !1;
}
async function th(e, t = void 0) {
  if (typeof e != "function")
    throw new jr("fn", ["Function", "AsyncFunction"], e);
  return !await za.call(
    this,
    async (...r) => !await e(...r),
    t
  );
}
async function rh(e, t) {
  for await (const r of cs.call(this, e, t))
    return r;
}
async function nh(e, t) {
  if (typeof e != "function")
    throw new jr("fn", ["Function", "AsyncFunction"], e);
  async function r(i, o) {
    return await e(i, o), vn;
  }
  for await (const i of Ln.call(this, r, t)) ;
}
function cs(e, t) {
  if (typeof e != "function")
    throw new jr("fn", ["Function", "AsyncFunction"], e);
  async function r(i, o) {
    return await e(i, o) ? i : vn;
  }
  return Ln.call(this, r, t);
}
class ih extends Ud {
  constructor() {
    super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
  }
}
async function sh(e, t, r) {
  var i;
  if (typeof e != "function")
    throw new jr("reducer", ["Function", "AsyncFunction"], e);
  r != null && Gt(r, "options"), r?.signal != null && Vt(r.signal, "options.signal");
  let o = arguments.length > 1;
  if (r != null && (i = r.signal) !== null && i !== void 0 && i.aborted) {
    const F = new ht(void 0, {
      cause: r.signal.reason
    });
    throw this.once("error", () => {
    }), await xd(this.destroy(F)), F;
  }
  const c = new Cd(), n = c.signal;
  if (r != null && r.signal) {
    const F = {
      once: !0,
      [jd]: this,
      [$d]: !0
    };
    r.signal.addEventListener("abort", () => c.abort(), F);
  }
  let u = !1;
  try {
    for await (const F of this) {
      var _;
      if (u = !0, r != null && (_ = r.signal) !== null && _ !== void 0 && _.aborted)
        throw new ht();
      o ? t = await e(t, F, {
        signal: n
      }) : (t = F, o = !0);
    }
    if (!u && !o)
      throw new ih();
  } finally {
    c.abort();
  }
  return t;
}
async function oh(e) {
  e != null && Gt(e, "options"), e?.signal != null && Vt(e.signal, "options.signal");
  const t = [];
  for await (const i of this) {
    var r;
    if (e != null && (r = e.signal) !== null && r !== void 0 && r.aborted)
      throw new ht(void 0, {
        cause: e.signal.reason
      });
    Yd(t, i);
  }
  return t;
}
function ah(e, t) {
  const r = Ln.call(this, e, t);
  return async function* () {
    for await (const o of r)
      yield* o;
  }.call(this);
}
function Va(e) {
  if (e = Jd(e), Xd(e))
    return 0;
  if (e < 0)
    throw new Wd("number", ">= 0", e);
  return e;
}
function lh(e, t = void 0) {
  return t != null && Gt(t, "options"), t?.signal != null && Vt(t.signal, "options.signal"), e = Va(e), async function* () {
    var i;
    if (t != null && (i = t.signal) !== null && i !== void 0 && i.aborted)
      throw new ht();
    for await (const c of this) {
      var o;
      if (t != null && (o = t.signal) !== null && o !== void 0 && o.aborted)
        throw new ht();
      e-- <= 0 && (yield c);
    }
  }.call(this);
}
function fh(e, t = void 0) {
  return t != null && Gt(t, "options"), t?.signal != null && Vt(t.signal, "options.signal"), e = Va(e), async function* () {
    var i;
    if (t != null && (i = t.signal) !== null && i !== void 0 && i.aborted)
      throw new ht();
    for await (const c of this) {
      var o;
      if (t != null && (o = t.signal) !== null && o !== void 0 && o.aborted)
        throw new ht();
      if (e-- > 0 && (yield c), e <= 0)
        return;
    }
  }.call(this);
}
ts.streamReturningOperators = {
  asIndexedPairs: Kd(eh, "readable.asIndexedPairs will be removed in a future version."),
  drop: lh,
  filter: cs,
  flatMap: ah,
  map: Ln,
  take: fh,
  compose: Qd
};
ts.promiseReturningOperators = {
  every: th,
  forEach: nh,
  reduce: sh,
  toArray: oh,
  some: za,
  find: rh
};
var gi, _o;
function Ga() {
  if (_o) return gi;
  _o = 1;
  const { ArrayPrototypePop: e, Promise: t } = ke, { isIterable: r, isNodeStream: i, isWebStream: o } = St, { pipelineImpl: c } = us, { finished: n } = Dt;
  Ka();
  function u(..._) {
    return new t((F, d) => {
      let s, l;
      const h = _[_.length - 1];
      if (h && typeof h == "object" && !i(h) && !r(h) && !o(h)) {
        const b = e(_);
        s = b.signal, l = b.end;
      }
      c(
        _,
        (b, p) => {
          b ? d(b) : F(p);
        },
        {
          signal: s,
          end: l
        }
      );
    });
  }
  return gi = {
    finished: n,
    pipeline: u
  }, gi;
}
var So;
function Ka() {
  if (So) return Zn.exports;
  So = 1;
  const { Buffer: e } = yt, { ObjectDefineProperty: t, ObjectKeys: r, ReflectApply: i } = ke, {
    promisify: { custom: o }
  } = Ve, { streamReturningOperators: c, promiseReturningOperators: n } = ts, {
    codes: { ERR_ILLEGAL_CONSTRUCTOR: u }
  } = qe, _ = xa, { setDefaultHighWaterMark: F, getDefaultHighWaterMark: d } = Mn, { pipeline: s } = us, { destroyer: l } = br, h = Dt, b = Ga(), p = St, S = Zn.exports = ss.Stream;
  S.isDestroyed = p.isDestroyed, S.isDisturbed = p.isDisturbed, S.isErrored = p.isErrored, S.isReadable = p.isReadable, S.isWritable = p.isWritable, S.Readable = Cn();
  for (const v of r(c)) {
    let N = function(...I) {
      if (new.target)
        throw u();
      return S.Readable.from(i(m, this, I));
    };
    const m = c[v];
    t(N, "name", {
      __proto__: null,
      value: m.name
    }), t(N, "length", {
      __proto__: null,
      value: m.length
    }), t(S.Readable.prototype, v, {
      __proto__: null,
      value: N,
      enumerable: !1,
      configurable: !0,
      writable: !0
    });
  }
  for (const v of r(n)) {
    let N = function(...I) {
      if (new.target)
        throw u();
      return i(m, this, I);
    };
    const m = n[v];
    t(N, "name", {
      __proto__: null,
      value: m.name
    }), t(N, "length", {
      __proto__: null,
      value: m.length
    }), t(S.Readable.prototype, v, {
      __proto__: null,
      value: N,
      enumerable: !1,
      configurable: !0,
      writable: !0
    });
  }
  S.Writable = as(), S.Duplex = mt(), S.Transform = Ua, S.PassThrough = ja, S.pipeline = s;
  const { addAbortSignal: E } = kn;
  return S.addAbortSignal = E, S.finished = h, S.destroy = l, S.compose = _, S.setDefaultHighWaterMark = F, S.getDefaultHighWaterMark = d, t(S, "promises", {
    __proto__: null,
    configurable: !0,
    enumerable: !0,
    get() {
      return b;
    }
  }), t(s, o, {
    __proto__: null,
    enumerable: !0,
    get() {
      return b.pipeline;
    }
  }), t(h, o, {
    __proto__: null,
    enumerable: !0,
    get() {
      return b.finished;
    }
  }), S.Stream = S, S._isUint8Array = function(m) {
    return m instanceof Uint8Array;
  }, S._uint8ArrayToBuffer = function(m) {
    return e.from(m.buffer, m.byteOffset, m.byteLength);
  }, Zn.exports;
}
(function(e) {
  const t = Ka(), r = Ga(), i = t.Readable.destroy;
  e.exports = t.Readable, e.exports._uint8ArrayToBuffer = t._uint8ArrayToBuffer, e.exports._isUint8Array = t._isUint8Array, e.exports.isDisturbed = t.isDisturbed, e.exports.isErrored = t.isErrored, e.exports.isReadable = t.isReadable, e.exports.Readable = t.Readable, e.exports.Writable = t.Writable, e.exports.Duplex = t.Duplex, e.exports.Transform = t.Transform, e.exports.PassThrough = t.PassThrough, e.exports.addAbortSignal = t.addAbortSignal, e.exports.finished = t.finished, e.exports.destroy = t.destroy, e.exports.destroy = i, e.exports.pipeline = t.pipeline, e.exports.compose = t.compose, Object.defineProperty(t, "promises", {
    configurable: !0,
    enumerable: !0,
    get() {
      return r;
    }
  }), e.exports.Stream = t.Stream, e.exports.default = e.exports;
})(ua);
var uh = ua.exports, $r = {}, vo = Ce && Ce.__spreadArray || function(e, t, r) {
  if (r || arguments.length === 2) for (var i = 0, o = t.length, c; i < o; i++)
    (c || !(i in t)) && (c || (c = Array.prototype.slice.call(t, 0, i)), c[i] = t[i]);
  return e.concat(c || Array.prototype.slice.call(t));
};
Object.defineProperty($r, "__esModule", { value: !0 });
$r.FileHandle = void 0;
function be(e, t, r) {
  return r === void 0 && (r = function(i) {
    return i;
  }), function() {
    for (var i = [], o = 0; o < arguments.length; o++)
      i[o] = arguments[o];
    return new Promise(function(c, n) {
      e[t].bind(e).apply(void 0, vo(vo([], i, !1), [function(u, _) {
        return u ? n(u) : c(r(_));
      }], !1));
    });
  };
}
var rr = (
  /** @class */
  function() {
    function e(t, r) {
      this.vol = t, this.fd = r;
    }
    return e.prototype.appendFile = function(t, r) {
      return be(this.vol, "appendFile")(this.fd, t, r);
    }, e.prototype.chmod = function(t) {
      return be(this.vol, "fchmod")(this.fd, t);
    }, e.prototype.chown = function(t, r) {
      return be(this.vol, "fchown")(this.fd, t, r);
    }, e.prototype.close = function() {
      return be(this.vol, "close")(this.fd);
    }, e.prototype.datasync = function() {
      return be(this.vol, "fdatasync")(this.fd);
    }, e.prototype.read = function(t, r, i, o) {
      return be(this.vol, "read", function(c) {
        return { bytesRead: c, buffer: t };
      })(this.fd, t, r, i, o);
    }, e.prototype.readFile = function(t) {
      return be(this.vol, "readFile")(this.fd, t);
    }, e.prototype.stat = function(t) {
      return be(this.vol, "fstat")(this.fd, t);
    }, e.prototype.sync = function() {
      return be(this.vol, "fsync")(this.fd);
    }, e.prototype.truncate = function(t) {
      return be(this.vol, "ftruncate")(this.fd, t);
    }, e.prototype.utimes = function(t, r) {
      return be(this.vol, "futimes")(this.fd, t, r);
    }, e.prototype.write = function(t, r, i, o) {
      return be(this.vol, "write", function(c) {
        return { bytesWritten: c, buffer: t };
      })(this.fd, t, r, i, o);
    }, e.prototype.writeFile = function(t, r) {
      return be(this.vol, "writeFile")(this.fd, t, r);
    }, e;
  }()
);
$r.FileHandle = rr;
function ch(e) {
  return typeof Promise > "u" ? null : {
    FileHandle: rr,
    access: function(t, r) {
      return be(e, "access")(t, r);
    },
    appendFile: function(t, r, i) {
      return be(e, "appendFile")(t instanceof rr ? t.fd : t, r, i);
    },
    chmod: function(t, r) {
      return be(e, "chmod")(t, r);
    },
    chown: function(t, r, i) {
      return be(e, "chown")(t, r, i);
    },
    copyFile: function(t, r, i) {
      return be(e, "copyFile")(t, r, i);
    },
    lchmod: function(t, r) {
      return be(e, "lchmod")(t, r);
    },
    lchown: function(t, r, i) {
      return be(e, "lchown")(t, r, i);
    },
    link: function(t, r) {
      return be(e, "link")(t, r);
    },
    lstat: function(t, r) {
      return be(e, "lstat")(t, r);
    },
    mkdir: function(t, r) {
      return be(e, "mkdir")(t, r);
    },
    mkdtemp: function(t, r) {
      return be(e, "mkdtemp")(t, r);
    },
    open: function(t, r, i) {
      return be(e, "open", function(o) {
        return new rr(e, o);
      })(t, r, i);
    },
    readdir: function(t, r) {
      return be(e, "readdir")(t, r);
    },
    readFile: function(t, r) {
      return be(e, "readFile")(t instanceof rr ? t.fd : t, r);
    },
    readlink: function(t, r) {
      return be(e, "readlink")(t, r);
    },
    realpath: function(t, r) {
      return be(e, "realpath")(t, r);
    },
    rename: function(t, r) {
      return be(e, "rename")(t, r);
    },
    rmdir: function(t) {
      return be(e, "rmdir")(t);
    },
    rm: function(t, r) {
      return be(e, "rm")(t, r);
    },
    stat: function(t, r) {
      return be(e, "stat")(t, r);
    },
    symlink: function(t, r, i) {
      return be(e, "symlink")(t, r, i);
    },
    truncate: function(t, r) {
      return be(e, "truncate")(t, r);
    },
    unlink: function(t) {
      return be(e, "unlink")(t);
    },
    utimes: function(t, r, i) {
      return be(e, "utimes")(t, r, i);
    },
    writeFile: function(t, r, i) {
      return be(e, "writeFile")(t instanceof rr ? t.fd : t, r, i);
    }
  };
}
$r.default = ch;
var mi = {}, Eo;
function dh() {
  if (Eo) return mi;
  if (Eo = 1, typeof URL > "u")
    throw new Error("URL is not supported in this environment");
  return mi.URL = URL, mi;
}
var Nr = {}, Ao;
function hh() {
  if (Ao) return Nr;
  Ao = 1, Object.defineProperty(Nr, "__esModule", {
    value: !0
  }), Nr.correctPath = c, Nr.unixify = o;
  var e = tt.platform === "win32";
  function t(n) {
    var u = n.length - 1;
    if (u < 2)
      return n;
    for (; r(n, u); )
      u--;
    return n.substr(0, u + 1);
  }
  function r(n, u) {
    var _ = n[u];
    return u > 0 && (_ === "/" || e && _ === "\\");
  }
  function i(n, u) {
    if (typeof n != "string")
      throw new TypeError("expected a string");
    return n = n.replace(/[\\\/]+/g, "/"), u !== !1 && (n = t(n)), n;
  }
  function o(n) {
    var u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    return e ? (n = i(n, u), n.replace(/^([a-zA-Z]+:|\.\/)/, "")) : n;
  }
  function c(n) {
    return o(n.replace(/^\\\\\?\\.:\\/, "\\"));
  }
  return Nr;
}
(function(e) {
  var t = Ce && Ce.__extends || /* @__PURE__ */ function() {
    var g = function(a, f) {
      return g = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(y, w) {
        y.__proto__ = w;
      } || function(y, w) {
        for (var O in w) Object.prototype.hasOwnProperty.call(w, O) && (y[O] = w[O]);
      }, g(a, f);
    };
    return function(a, f) {
      if (typeof f != "function" && f !== null)
        throw new TypeError("Class extends value " + String(f) + " is not a constructor or null");
      g(a, f);
      function y() {
        this.constructor = a;
      }
      a.prototype = f === null ? Object.create(f) : (y.prototype = f.prototype, new y());
    };
  }(), r = Ce && Ce.__spreadArray || function(g, a, f) {
    if (f || arguments.length === 2) for (var y = 0, w = a.length, O; y < w; y++)
      (O || !(y in a)) && (O || (O = Array.prototype.slice.call(a, 0, y)), O[y] = a[y]);
    return g.concat(O || Array.prototype.slice.call(a));
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.FSWatcher = e.StatWatcher = e.Volume = e.toUnixTimestamp = e.bufferToEncoding = e.dataToBuffer = e.dataToStr = e.pathToSteps = e.filenameToSteps = e.pathToFilename = e.flagsToNumber = e.FLAGS = void 0;
  var i = eu, o = ea, c = Ht, n = yr, u = Tn, _ = In, F = gr, d = es, s = uh, l = Ft, h = mr, b = zi, p = Vi, S = Gi, E = $r, v = i.resolve, m = l.constants.O_RDONLY, N = l.constants.O_WRONLY, I = l.constants.O_RDWR, M = l.constants.O_CREAT, H = l.constants.O_EXCL, x = l.constants.O_TRUNC, Y = l.constants.O_APPEND, X = l.constants.O_SYNC, oe = l.constants.O_DIRECTORY, Z = l.constants.F_OK, W = l.constants.COPYFILE_EXCL, ae = l.constants.COPYFILE_FICLONE_FORCE, ie = i.posix ? i.posix : i, ne = ie.sep, we = ie.relative, me = ie.join, _e = ie.dirname, pe = F.default.platform === "win32", B = 128, j = {
    PATH_STR: "path must be a string or Buffer",
    // FD:             'file descriptor must be a unsigned 32-bit integer',
    FD: "fd must be a file descriptor",
    MODE_INT: "mode must be an int",
    CB: "callback must be a function",
    UID: "uid must be an unsigned int",
    GID: "gid must be an unsigned int",
    LEN: "len must be an integer",
    ATIME: "atime must be an integer",
    MTIME: "mtime must be an integer",
    PREFIX: "filename prefix is required",
    BUFFER: "buffer must be an instance of Buffer or StaticBuffer",
    OFFSET: "offset must be an integer",
    LENGTH: "length must be an integer",
    POSITION: "position must be an integer"
  }, U = function(g) {
    return "Expected options to be either an object or a string, but got ".concat(g, " instead");
  }, q = "ENOENT", fe = "EBADF", ge = "EINVAL", de = "EPERM", he = "EPROTO", ye = "EEXIST", Fe = "ENOTDIR", ze = "EMFILE", Ge = "EACCES", D = "EISDIR", k = "ENOTEMPTY", V = "ENOSYS", te = "ERR_FS_EISDIR";
  function re(g, a, f, y) {
    a === void 0 && (a = ""), f === void 0 && (f = ""), y === void 0 && (y = "");
    var w = "";
    switch (f && (w = " '".concat(f, "'")), y && (w += " -> '".concat(y, "'")), g) {
      case q:
        return "ENOENT: no such file or directory, ".concat(a).concat(w);
      case fe:
        return "EBADF: bad file descriptor, ".concat(a).concat(w);
      case ge:
        return "EINVAL: invalid argument, ".concat(a).concat(w);
      case de:
        return "EPERM: operation not permitted, ".concat(a).concat(w);
      case he:
        return "EPROTO: protocol error, ".concat(a).concat(w);
      case ye:
        return "EEXIST: file already exists, ".concat(a).concat(w);
      case Fe:
        return "ENOTDIR: not a directory, ".concat(a).concat(w);
      case D:
        return "EISDIR: illegal operation on a directory, ".concat(a).concat(w);
      case Ge:
        return "EACCES: permission denied, ".concat(a).concat(w);
      case k:
        return "ENOTEMPTY: directory not empty, ".concat(a).concat(w);
      case ze:
        return "EMFILE: too many open files, ".concat(a).concat(w);
      case V:
        return "ENOSYS: function not implemented, ".concat(a).concat(w);
      case te:
        return "[ERR_FS_EISDIR]: Path is a directory: ".concat(a, " returned EISDIR (is a directory) ").concat(f);
      default:
        return "".concat(g, ": error occurred, ").concat(a).concat(w);
    }
  }
  function Q(g, a, f, y, w) {
    a === void 0 && (a = ""), f === void 0 && (f = ""), y === void 0 && (y = ""), w === void 0 && (w = Error);
    var O = new w(re(g, a, f, y));
    return O.code = g, f && (O.path = f), O;
  }
  var L;
  (function(g) {
    g[g.r = m] = "r", g[g["r+"] = I] = "r+", g[g.rs = m | X] = "rs", g[g.sr = g.rs] = "sr", g[g["rs+"] = I | X] = "rs+", g[g["sr+"] = g["rs+"]] = "sr+", g[g.w = N | M | x] = "w", g[g.wx = N | M | x | H] = "wx", g[g.xw = g.wx] = "xw", g[g["w+"] = I | M | x] = "w+", g[g["wx+"] = I | M | x | H] = "wx+", g[g["xw+"] = g["wx+"]] = "xw+", g[g.a = N | Y | M] = "a", g[g.ax = N | Y | M | H] = "ax", g[g.xa = g.ax] = "xa", g[g["a+"] = I | Y | M] = "a+", g[g["ax+"] = I | Y | M | H] = "ax+", g[g["xa+"] = g["ax+"]] = "xa+";
  })(L = e.FLAGS || (e.FLAGS = {}));
  function Se(g) {
    if (typeof g == "number")
      return g;
    if (typeof g == "string") {
      var a = L[g];
      if (typeof a < "u")
        return a;
    }
    throw new p.TypeError("ERR_INVALID_OPT_VALUE", "flags", g);
  }
  e.flagsToNumber = Se;
  function Ke(g, a) {
    var f;
    if (a) {
      var y = typeof a;
      switch (y) {
        case "string":
          f = Object.assign({}, g, { encoding: a });
          break;
        case "object":
          f = Object.assign({}, g, a);
          break;
        default:
          throw TypeError(U(y));
      }
    } else
      return g;
    return f.encoding !== "buffer" && (0, b.assertEncoding)(f.encoding), f;
  }
  function le(g) {
    return function(a) {
      return Ke(g, a);
    };
  }
  function De(g) {
    if (typeof g != "function")
      throw TypeError(j.CB);
    return g;
  }
  function st(g) {
    return function(a, f) {
      return typeof a == "function" ? [g(), a] : [g(a), De(f)];
    };
  }
  var wr = {
    encoding: "utf8"
  }, Kt = le(wr), _r = st(Kt), Un = {
    flag: "r"
  }, Bt = le(Un), Sr = {
    encoding: "utf8",
    mode: 438,
    flag: L[L.w]
  }, Pt = le(Sr), Vr = {
    encoding: "utf8",
    mode: 438,
    flag: L[L.a]
  }, Gr = le(Vr), Kr = st(Gr), Wn = wr, Yr = le(Wn), jn = st(Yr), vr = {
    mode: 511,
    recursive: !1
  }, Er = function(g) {
    return typeof g == "number" ? Object.assign({}, vr, { mode: g }) : Object.assign({}, vr, g);
  }, $n = {
    recursive: !1
  }, Ar = function(g) {
    return Object.assign({}, $n, g);
  }, Tr = le(wr), xn = st(Tr), Hn = {
    encoding: "utf8",
    withFileTypes: !1
  }, Yt = le(Hn), qr = st(Yt), A = {
    bigint: !1
  }, T = function(g) {
    return g === void 0 && (g = {}), Object.assign({}, A, g);
  }, G = function(g, a) {
    return typeof g == "function" ? [T(), g] : [T(g), De(a)];
  };
  function K(g) {
    if (g.hostname !== "")
      throw new p.TypeError("ERR_INVALID_FILE_URL_HOST", F.default.platform);
    for (var a = g.pathname, f = 0; f < a.length; f++)
      if (a[f] === "%") {
        var y = a.codePointAt(f + 2) | 32;
        if (a[f + 1] === "2" && y === 102)
          throw new p.TypeError("ERR_INVALID_FILE_URL_PATH", "must not include encoded / characters");
      }
    return decodeURIComponent(a);
  }
  function $(g) {
    if (typeof g != "string" && !u.Buffer.isBuffer(g)) {
      try {
        if (!(g instanceof dh().URL))
          throw new TypeError(j.PATH_STR);
      } catch {
        throw new TypeError(j.PATH_STR);
      }
      g = K(g);
    }
    var a = String(g);
    return kt(a), a;
  }
  e.pathToFilename = $;
  var Be = function(g, a) {
    return a === void 0 && (a = F.default.cwd()), v(a, g);
  };
  if (pe) {
    var Ye = Be, Jr = hh().unixify;
    Be = function(g, a) {
      return Jr(Ye(g, a));
    };
  }
  function Te(g, a) {
    var f = Be(g, a), y = f.substring(1);
    return y ? y.split(ne) : [];
  }
  e.filenameToSteps = Te;
  function Xr(g) {
    return Te($(g));
  }
  e.pathToSteps = Xr;
  function zn(g, a) {
    return a === void 0 && (a = b.ENCODING_UTF8), u.Buffer.isBuffer(g) ? g.toString(a) : g instanceof Uint8Array ? (0, u.bufferFrom)(g).toString(a) : String(g);
  }
  e.dataToStr = zn;
  function vt(g, a) {
    return a === void 0 && (a = b.ENCODING_UTF8), u.Buffer.isBuffer(g) ? g : g instanceof Uint8Array ? (0, u.bufferFrom)(g) : (0, u.bufferFrom)(String(g), a);
  }
  e.dataToBuffer = vt;
  function Rr(g, a) {
    return !a || a === "buffer" ? g : g.toString(a);
  }
  e.bufferToEncoding = Rr;
  function kt(g, a) {
    if (("" + g).indexOf("\0") !== -1) {
      var f = new Error("Path must be a string without null bytes");
      throw f.code = q, f;
    }
    return !0;
  }
  function Ir(g, a) {
    if (typeof g == "number")
      return g;
    if (typeof g == "string")
      return parseInt(g, 8);
    if (a)
      return $e(a);
  }
  function $e(g, a) {
    var f = Ir(g, a);
    if (typeof f != "number" || isNaN(f))
      throw new TypeError(j.MODE_INT);
    return f;
  }
  function Je(g) {
    return g >>> 0 === g;
  }
  function Xe(g) {
    if (!Je(g))
      throw TypeError(j.FD);
  }
  function Ue(g) {
    if (typeof g == "string" && +g == g)
      return +g;
    if (g instanceof Date)
      return g.getTime() / 1e3;
    if (isFinite(g))
      return g < 0 ? Date.now() / 1e3 : g;
    throw new Error("Cannot parse time: " + g);
  }
  e.toUnixTimestamp = Ue;
  function qt(g) {
    if (typeof g != "number")
      throw TypeError(j.UID);
  }
  function Jt(g) {
    if (typeof g != "number")
      throw TypeError(j.GID);
  }
  function rl(g) {
    var a = {};
    function f(y, w) {
      for (var O in w) {
        var P = w[O], z = me(y, O);
        typeof P == "string" ? a[z] = P : typeof P == "object" && P !== null && Object.keys(P).length > 0 ? f(z, P) : a[z] = null;
      }
    }
    return f("", g), a;
  }
  var nl = (
    /** @class */
    function() {
      function g(a) {
        a === void 0 && (a = {}), this.ino = 0, this.inodes = {}, this.releasedInos = [], this.fds = {}, this.releasedFds = [], this.maxFiles = 1e4, this.openFiles = 0, this.promisesApi = (0, E.default)(this), this.statWatchers = {}, this.props = Object.assign({ Node: o.Node, Link: o.Link, File: o.File }, a);
        var f = this.createLink();
        f.setNode(this.createNode(!0));
        var y = this;
        this.StatWatcher = /** @class */
        function(P) {
          t(z, P);
          function z() {
            return P.call(this, y) || this;
          }
          return z;
        }(ys);
        var w = ot;
        this.ReadStream = /** @class */
        function(P) {
          t(z, P);
          function z() {
            for (var J = [], ee = 0; ee < arguments.length; ee++)
              J[ee] = arguments[ee];
            return P.apply(this, r([y], J, !1)) || this;
          }
          return z;
        }(w);
        var O = Qe;
        this.WriteStream = /** @class */
        function(P) {
          t(z, P);
          function z() {
            for (var J = [], ee = 0; ee < arguments.length; ee++)
              J[ee] = arguments[ee];
            return P.apply(this, r([y], J, !1)) || this;
          }
          return z;
        }(O), this.FSWatcher = /** @class */
        function(P) {
          t(z, P);
          function z() {
            return P.call(this, y) || this;
          }
          return z;
        }(gs), f.setChild(".", f), f.getNode().nlink++, f.setChild("..", f), f.getNode().nlink++, this.root = f;
      }
      return g.fromJSON = function(a, f) {
        var y = new g();
        return y.fromJSON(a, f), y;
      }, g.fromNestedJSON = function(a, f) {
        var y = new g();
        return y.fromNestedJSON(a, f), y;
      }, Object.defineProperty(g.prototype, "promises", {
        get: function() {
          if (this.promisesApi === null)
            throw new Error("Promise is not supported in this environment.");
          return this.promisesApi;
        },
        enumerable: !1,
        configurable: !0
      }), g.prototype.createLink = function(a, f, y, w) {
        if (y === void 0 && (y = !1), !a)
          return new this.props.Link(this, null, "");
        if (!f)
          throw new Error("createLink: name cannot be empty");
        return a.createChild(f, this.createNode(y, w));
      }, g.prototype.deleteLink = function(a) {
        var f = a.parent;
        return f ? (f.deleteChild(a), !0) : !1;
      }, g.prototype.newInoNumber = function() {
        var a = this.releasedInos.pop();
        return a || (this.ino = (this.ino + 1) % 4294967295, this.ino);
      }, g.prototype.newFdNumber = function() {
        var a = this.releasedFds.pop();
        return typeof a == "number" ? a : g.fd--;
      }, g.prototype.createNode = function(a, f) {
        a === void 0 && (a = !1);
        var y = new this.props.Node(this.newInoNumber(), f);
        return a && y.setIsDirectory(), this.inodes[y.ino] = y, y;
      }, g.prototype.getNode = function(a) {
        return this.inodes[a];
      }, g.prototype.deleteNode = function(a) {
        a.del(), delete this.inodes[a.ino], this.releasedInos.push(a.ino);
      }, g.prototype.genRndStr = function() {
        var a = (Math.random() + 1).toString(36).substring(2, 8);
        return a.length === 6 ? a : this.genRndStr();
      }, g.prototype.getLink = function(a) {
        return this.root.walk(a);
      }, g.prototype.getLinkOrThrow = function(a, f) {
        var y = Te(a), w = this.getLink(y);
        if (!w)
          throw Q(q, f, a);
        return w;
      }, g.prototype.getResolvedLink = function(a) {
        for (var f = typeof a == "string" ? Te(a) : a, y = this.root, w = 0; w < f.length; ) {
          var O = f[w];
          if (y = y.getChild(O), !y)
            return null;
          var P = y.getNode();
          if (P.isSymlink()) {
            f = P.symlink.concat(f.slice(w + 1)), y = this.root, w = 0;
            continue;
          }
          w++;
        }
        return y;
      }, g.prototype.getResolvedLinkOrThrow = function(a, f) {
        var y = this.getResolvedLink(a);
        if (!y)
          throw Q(q, f, a);
        return y;
      }, g.prototype.resolveSymlinks = function(a) {
        return this.getResolvedLink(a.steps.slice(1));
      }, g.prototype.getLinkAsDirOrThrow = function(a, f) {
        var y = this.getLinkOrThrow(a, f);
        if (!y.getNode().isDirectory())
          throw Q(Fe, f, a);
        return y;
      }, g.prototype.getLinkParent = function(a) {
        return this.root.walk(a, a.length - 1);
      }, g.prototype.getLinkParentAsDirOrThrow = function(a, f) {
        var y = a instanceof Array ? a : Te(a), w = this.getLinkParent(y);
        if (!w)
          throw Q(q, f, ne + y.join(ne));
        if (!w.getNode().isDirectory())
          throw Q(Fe, f, ne + y.join(ne));
        return w;
      }, g.prototype.getFileByFd = function(a) {
        return this.fds[String(a)];
      }, g.prototype.getFileByFdOrThrow = function(a, f) {
        if (!Je(a))
          throw TypeError(j.FD);
        var y = this.getFileByFd(a);
        if (!y)
          throw Q(fe, f);
        return y;
      }, g.prototype.wrapAsync = function(a, f, y) {
        var w = this;
        De(y), (0, _.default)(function() {
          var O;
          try {
            O = a.apply(w, f);
          } catch (P) {
            y(P);
            return;
          }
          y(null, O);
        });
      }, g.prototype._toJSON = function(a, f, y) {
        var w;
        a === void 0 && (a = this.root), f === void 0 && (f = {});
        var O = !0, P = a.children;
        a.getNode().isFile() && (P = (w = {}, w[a.getName()] = a.parent.getChild(a.getName()), w), a = a.parent);
        for (var z in P)
          if (!(z === "." || z === "..")) {
            O = !1;
            var J = a.getChild(z);
            if (!J)
              throw new Error("_toJSON: unexpected undefined");
            var ee = J.getNode();
            if (ee.isFile()) {
              var ue = J.getPath();
              y && (ue = we(y, ue)), f[ue] = ee.getString();
            } else ee.isDirectory() && this._toJSON(J, f, y);
          }
        var ve = a.getPath();
        return y && (ve = we(y, ve)), ve && O && (f[ve] = null), f;
      }, g.prototype.toJSON = function(a, f, y) {
        f === void 0 && (f = {}), y === void 0 && (y = !1);
        var w = [];
        if (a) {
          a instanceof Array || (a = [a]);
          for (var O = 0, P = a; O < P.length; O++) {
            var z = P[O], J = $(z), ee = this.getResolvedLink(J);
            ee && w.push(ee);
          }
        } else
          w.push(this.root);
        if (!w.length)
          return f;
        for (var ue = 0, ve = w; ue < ve.length; ue++) {
          var ee = ve[ue];
          this._toJSON(ee, f, y ? ee.getPath() : "");
        }
        return f;
      }, g.prototype.fromJSON = function(a, f) {
        f === void 0 && (f = F.default.cwd());
        for (var y in a) {
          var w = a[y];
          if (y = Be(y, f), typeof w == "string") {
            var O = _e(y);
            this.mkdirpBase(
              O,
              511
              /* MODE.DIR */
            ), this.writeFileSync(y, w);
          } else
            this.mkdirpBase(
              y,
              511
              /* MODE.DIR */
            );
        }
      }, g.prototype.fromNestedJSON = function(a, f) {
        this.fromJSON(rl(a), f);
      }, g.prototype.reset = function() {
        this.ino = 0, this.inodes = {}, this.releasedInos = [], this.fds = {}, this.releasedFds = [], this.openFiles = 0, this.root = this.createLink(), this.root.setNode(this.createNode(!0));
      }, g.prototype.mountSync = function(a, f) {
        this.fromJSON(f, a);
      }, g.prototype.openLink = function(a, f, y) {
        if (y === void 0 && (y = !0), this.openFiles >= this.maxFiles)
          throw Q(ze, "open", a.getPath());
        var w = a;
        if (y && (w = this.resolveSymlinks(a)), !w)
          throw Q(q, "open", a.getPath());
        var O = w.getNode();
        if (O.isDirectory()) {
          if ((f & (m | I | N)) !== m)
            throw Q(D, "open", a.getPath());
        } else if (f & oe)
          throw Q(Fe, "open", a.getPath());
        if (!(f & N) && !O.canRead())
          throw Q(Ge, "open", a.getPath());
        var P = new this.props.File(a, O, f, this.newFdNumber());
        return this.fds[P.fd] = P, this.openFiles++, f & x && P.truncate(), P;
      }, g.prototype.openFile = function(a, f, y, w) {
        w === void 0 && (w = !0);
        var O = Te(a), P = w ? this.getResolvedLink(O) : this.getLink(O);
        if (P && f & H)
          throw Q(ye, "open", a);
        if (!P && f & M) {
          var z = this.getResolvedLink(O.slice(0, O.length - 1));
          if (!z)
            throw Q(q, "open", ne + O.join(ne));
          f & M && typeof y == "number" && (P = this.createLink(z, O[O.length - 1], !1, y));
        }
        if (P)
          return this.openLink(P, f, w);
        throw Q(q, "open", a);
      }, g.prototype.openBase = function(a, f, y, w) {
        w === void 0 && (w = !0);
        var O = this.openFile(a, f, y, w);
        if (!O)
          throw Q(q, "open", a);
        return O.fd;
      }, g.prototype.openSync = function(a, f, y) {
        y === void 0 && (y = 438);
        var w = $e(y), O = $(a), P = Se(f);
        return this.openBase(O, P, w);
      }, g.prototype.open = function(a, f, y, w) {
        var O = y, P = w;
        typeof y == "function" && (O = 438, P = y), O = O || 438;
        var z = $e(O), J = $(a), ee = Se(f);
        this.wrapAsync(this.openBase, [J, ee, z], P);
      }, g.prototype.closeFile = function(a) {
        this.fds[a.fd] && (this.openFiles--, delete this.fds[a.fd], this.releasedFds.push(a.fd));
      }, g.prototype.closeSync = function(a) {
        Xe(a);
        var f = this.getFileByFdOrThrow(a, "close");
        this.closeFile(f);
      }, g.prototype.close = function(a, f) {
        Xe(a), this.wrapAsync(this.closeSync, [a], f);
      }, g.prototype.openFileOrGetById = function(a, f, y) {
        if (typeof a == "number") {
          var w = this.fds[a];
          if (!w)
            throw Q(q);
          return w;
        } else
          return this.openFile($(a), f, y);
      }, g.prototype.readBase = function(a, f, y, w, O) {
        var P = this.getFileByFdOrThrow(a);
        return P.read(f, Number(y), Number(w), O);
      }, g.prototype.readSync = function(a, f, y, w, O) {
        return Xe(a), this.readBase(a, f, y, w, O);
      }, g.prototype.read = function(a, f, y, w, O, P) {
        var z = this;
        if (De(P), w === 0)
          return F.default.nextTick(function() {
            P && P(null, 0, f);
          });
        (0, _.default)(function() {
          try {
            var J = z.readBase(a, f, y, w, O);
            P(null, J, f);
          } catch (ee) {
            P(ee);
          }
        });
      }, g.prototype.readFileBase = function(a, f, y) {
        var w, O = typeof a == "number", P = O && Je(a), z;
        if (P)
          z = a;
        else {
          var J = $(a), ee = Te(J), ue = this.getResolvedLink(ee);
          if (ue) {
            var ve = ue.getNode();
            if (ve.isDirectory())
              throw Q(D, "open", ue.getPath());
          }
          z = this.openSync(a, f);
        }
        try {
          w = Rr(this.getFileByFdOrThrow(z).getBuffer(), y);
        } finally {
          P || this.closeSync(z);
        }
        return w;
      }, g.prototype.readFileSync = function(a, f) {
        var y = Bt(f), w = Se(y.flag);
        return this.readFileBase(a, w, y.encoding);
      }, g.prototype.readFile = function(a, f, y) {
        var w = st(Bt)(f, y), O = w[0], P = w[1], z = Se(O.flag);
        this.wrapAsync(this.readFileBase, [a, z, O.encoding], P);
      }, g.prototype.writeBase = function(a, f, y, w, O) {
        var P = this.getFileByFdOrThrow(a, "write");
        return P.write(f, y, w, O);
      }, g.prototype.writeSync = function(a, f, y, w, O) {
        Xe(a);
        var P, z, J, ee, ue = typeof f != "string";
        ue ? (z = (y || 0) | 0, J = w, ee = O) : (ee = y, P = w);
        var ve = vt(f, P);
        return ue ? typeof J > "u" && (J = ve.length) : (z = 0, J = ve.length), this.writeBase(a, ve, z, J, ee);
      }, g.prototype.write = function(a, f, y, w, O, P) {
        var z = this;
        Xe(a);
        var J, ee, ue, ve, We, Mt = typeof f, at = typeof y, Et = typeof w, Ct = typeof O;
        Mt !== "string" ? at === "function" ? We = y : Et === "function" ? (J = y | 0, We = w) : Ct === "function" ? (J = y | 0, ee = w, We = O) : (J = y | 0, ee = w, ue = O, We = P) : at === "function" ? We = y : Et === "function" ? (ue = y, We = w) : Ct === "function" && (ue = y, ve = w, We = O);
        var Me = vt(f, ve);
        Mt !== "string" ? typeof ee > "u" && (ee = Me.length) : (J = 0, ee = Me.length);
        var et = De(We);
        (0, _.default)(function() {
          try {
            var it = z.writeBase(a, Me, J, ee, ue);
            Mt !== "string" ? et(null, it, Me) : et(null, it, f);
          } catch (Zr) {
            et(Zr);
          }
        });
      }, g.prototype.writeFileBase = function(a, f, y, w) {
        var O = typeof a == "number", P;
        O ? P = a : P = this.openBase($(a), y, w);
        var z = 0, J = f.length, ee = y & Y ? void 0 : 0;
        try {
          for (; J > 0; ) {
            var ue = this.writeSync(P, f, z, J, ee);
            z += ue, J -= ue, ee !== void 0 && (ee += ue);
          }
        } finally {
          O || this.closeSync(P);
        }
      }, g.prototype.writeFileSync = function(a, f, y) {
        var w = Pt(y), O = Se(w.flag), P = $e(w.mode), z = vt(f, w.encoding);
        this.writeFileBase(a, z, O, P);
      }, g.prototype.writeFile = function(a, f, y, w) {
        var O = y, P = w;
        typeof y == "function" && (O = Sr, P = y);
        var z = De(P), J = Pt(O), ee = Se(J.flag), ue = $e(J.mode), ve = vt(f, J.encoding);
        this.wrapAsync(this.writeFileBase, [a, ve, ee, ue], z);
      }, g.prototype.linkBase = function(a, f) {
        var y = Te(a), w = this.getLink(y);
        if (!w)
          throw Q(q, "link", a, f);
        var O = Te(f), P = this.getLinkParent(O);
        if (!P)
          throw Q(q, "link", a, f);
        var z = O[O.length - 1];
        if (P.getChild(z))
          throw Q(ye, "link", a, f);
        var J = w.getNode();
        J.nlink++, P.createChild(z, J);
      }, g.prototype.copyFileBase = function(a, f, y) {
        var w = this.readFileSync(a);
        if (y & W && this.existsSync(f))
          throw Q(ye, "copyFile", a, f);
        if (y & ae)
          throw Q(V, "copyFile", a, f);
        this.writeFileBase(
          f,
          w,
          L.w,
          438
          /* MODE.DEFAULT */
        );
      }, g.prototype.copyFileSync = function(a, f, y) {
        var w = $(a), O = $(f);
        return this.copyFileBase(w, O, (y || 0) | 0);
      }, g.prototype.copyFile = function(a, f, y, w) {
        var O = $(a), P = $(f), z, J;
        typeof y == "function" ? (z = 0, J = y) : (z = y, J = w), De(J), this.wrapAsync(this.copyFileBase, [O, P, z], J);
      }, g.prototype.linkSync = function(a, f) {
        var y = $(a), w = $(f);
        this.linkBase(y, w);
      }, g.prototype.link = function(a, f, y) {
        var w = $(a), O = $(f);
        this.wrapAsync(this.linkBase, [w, O], y);
      }, g.prototype.unlinkBase = function(a) {
        var f = Te(a), y = this.getLink(f);
        if (!y)
          throw Q(q, "unlink", a);
        if (y.length)
          throw Error("Dir not empty...");
        this.deleteLink(y);
        var w = y.getNode();
        w.nlink--, w.nlink <= 0 && this.deleteNode(w);
      }, g.prototype.unlinkSync = function(a) {
        var f = $(a);
        this.unlinkBase(f);
      }, g.prototype.unlink = function(a, f) {
        var y = $(a);
        this.wrapAsync(this.unlinkBase, [y], f);
      }, g.prototype.symlinkBase = function(a, f) {
        var y = Te(f), w = this.getLinkParent(y);
        if (!w)
          throw Q(q, "symlink", a, f);
        var O = y[y.length - 1];
        if (w.getChild(O))
          throw Q(ye, "symlink", a, f);
        var P = w.createChild(O);
        return P.getNode().makeSymlink(Te(a)), P;
      }, g.prototype.symlinkSync = function(a, f, y) {
        var w = $(a), O = $(f);
        this.symlinkBase(w, O);
      }, g.prototype.symlink = function(a, f, y, w) {
        var O = De(typeof y == "function" ? y : w), P = $(a), z = $(f);
        this.wrapAsync(this.symlinkBase, [P, z], O);
      }, g.prototype.realpathBase = function(a, f) {
        var y = Te(a), w = this.getResolvedLink(y);
        if (!w)
          throw Q(q, "realpath", a);
        return (0, b.strToEncoding)(w.getPath() || "/", f);
      }, g.prototype.realpathSync = function(a, f) {
        return this.realpathBase($(a), Yr(f).encoding);
      }, g.prototype.realpath = function(a, f, y) {
        var w = jn(f, y), O = w[0], P = w[1], z = $(a);
        this.wrapAsync(this.realpathBase, [z, O.encoding], P);
      }, g.prototype.lstatBase = function(a, f, y) {
        f === void 0 && (f = !1), y === void 0 && (y = !1);
        var w = this.getLink(Te(a));
        if (w)
          return c.default.build(w.getNode(), f);
        if (y)
          throw Q(q, "lstat", a);
      }, g.prototype.lstatSync = function(a, f) {
        var y = T(f), w = y.throwIfNoEntry, O = w === void 0 ? !0 : w, P = y.bigint, z = P === void 0 ? !1 : P;
        return this.lstatBase($(a), z, O);
      }, g.prototype.lstat = function(a, f, y) {
        var w = G(f, y), O = w[0], P = O.throwIfNoEntry, z = P === void 0 ? !0 : P, J = O.bigint, ee = J === void 0 ? !1 : J, ue = w[1];
        this.wrapAsync(this.lstatBase, [$(a), ee, z], ue);
      }, g.prototype.statBase = function(a, f, y) {
        f === void 0 && (f = !1), y === void 0 && (y = !0);
        var w = this.getResolvedLink(Te(a));
        if (w)
          return c.default.build(w.getNode(), f);
        if (y)
          throw Q(q, "stat", a);
      }, g.prototype.statSync = function(a, f) {
        var y = T(f), w = y.bigint, O = w === void 0 ? !0 : w, P = y.throwIfNoEntry, z = P === void 0 ? !0 : P;
        return this.statBase($(a), O, z);
      }, g.prototype.stat = function(a, f, y) {
        var w = G(f, y), O = w[0], P = O.bigint, z = P === void 0 ? !1 : P, J = O.throwIfNoEntry, ee = J === void 0 ? !0 : J, ue = w[1];
        this.wrapAsync(this.statBase, [$(a), z, ee], ue);
      }, g.prototype.fstatBase = function(a, f) {
        f === void 0 && (f = !1);
        var y = this.getFileByFd(a);
        if (!y)
          throw Q(fe, "fstat");
        return c.default.build(y.node, f);
      }, g.prototype.fstatSync = function(a, f) {
        return this.fstatBase(a, T(f).bigint);
      }, g.prototype.fstat = function(a, f, y) {
        var w = G(f, y), O = w[0], P = w[1];
        this.wrapAsync(this.fstatBase, [a, O.bigint], P);
      }, g.prototype.renameBase = function(a, f) {
        var y = this.getLink(Te(a));
        if (!y)
          throw Q(q, "rename", a, f);
        var w = Te(f), O = this.getLinkParent(w);
        if (!O)
          throw Q(q, "rename", a, f);
        var P = y.parent;
        P && P.deleteChild(y);
        var z = w[w.length - 1];
        y.name = z, y.steps = r(r([], O.steps, !0), [z], !1), O.setChild(y.getName(), y);
      }, g.prototype.renameSync = function(a, f) {
        var y = $(a), w = $(f);
        this.renameBase(y, w);
      }, g.prototype.rename = function(a, f, y) {
        var w = $(a), O = $(f);
        this.wrapAsync(this.renameBase, [w, O], y);
      }, g.prototype.existsBase = function(a) {
        return !!this.statBase(a);
      }, g.prototype.existsSync = function(a) {
        try {
          return this.existsBase($(a));
        } catch {
          return !1;
        }
      }, g.prototype.exists = function(a, f) {
        var y = this, w = $(a);
        if (typeof f != "function")
          throw Error(j.CB);
        (0, _.default)(function() {
          try {
            f(y.existsBase(w));
          } catch {
            f(!1);
          }
        });
      }, g.prototype.accessBase = function(a, f) {
        this.getLinkOrThrow(a, "access");
      }, g.prototype.accessSync = function(a, f) {
        f === void 0 && (f = Z);
        var y = $(a);
        f = f | 0, this.accessBase(y, f);
      }, g.prototype.access = function(a, f, y) {
        var w = Z, O;
        typeof f != "function" ? (w = f | 0, O = De(y)) : O = f;
        var P = $(a);
        this.wrapAsync(this.accessBase, [P, w], O);
      }, g.prototype.appendFileSync = function(a, f, y) {
        y === void 0 && (y = Vr);
        var w = Gr(y);
        (!w.flag || Je(a)) && (w.flag = "a"), this.writeFileSync(a, f, w);
      }, g.prototype.appendFile = function(a, f, y, w) {
        var O = Kr(y, w), P = O[0], z = O[1];
        (!P.flag || Je(a)) && (P.flag = "a"), this.writeFile(a, f, P, z);
      }, g.prototype.readdirBase = function(a, f) {
        var y = Te(a), w = this.getResolvedLink(y);
        if (!w)
          throw Q(q, "readdir", a);
        var O = w.getNode();
        if (!O.isDirectory())
          throw Q(Fe, "scandir", a);
        if (f.withFileTypes) {
          var P = [];
          for (var z in w.children) {
            var J = w.getChild(z);
            !J || z === "." || z === ".." || P.push(n.default.build(J, f.encoding));
          }
          return !pe && f.encoding !== "buffer" && P.sort(function(ve, We) {
            return ve.name < We.name ? -1 : ve.name > We.name ? 1 : 0;
          }), P;
        }
        var ee = [];
        for (var ue in w.children)
          ue === "." || ue === ".." || ee.push((0, b.strToEncoding)(ue, f.encoding));
        return !pe && f.encoding !== "buffer" && ee.sort(), ee;
      }, g.prototype.readdirSync = function(a, f) {
        var y = Yt(f), w = $(a);
        return this.readdirBase(w, y);
      }, g.prototype.readdir = function(a, f, y) {
        var w = qr(f, y), O = w[0], P = w[1], z = $(a);
        this.wrapAsync(this.readdirBase, [z, O], P);
      }, g.prototype.readlinkBase = function(a, f) {
        var y = this.getLinkOrThrow(a, "readlink"), w = y.getNode();
        if (!w.isSymlink())
          throw Q(ge, "readlink", a);
        var O = ne + w.symlink.join(ne);
        return (0, b.strToEncoding)(O, f);
      }, g.prototype.readlinkSync = function(a, f) {
        var y = Kt(f), w = $(a);
        return this.readlinkBase(w, y.encoding);
      }, g.prototype.readlink = function(a, f, y) {
        var w = _r(f, y), O = w[0], P = w[1], z = $(a);
        this.wrapAsync(this.readlinkBase, [z, O.encoding], P);
      }, g.prototype.fsyncBase = function(a) {
        this.getFileByFdOrThrow(a, "fsync");
      }, g.prototype.fsyncSync = function(a) {
        this.fsyncBase(a);
      }, g.prototype.fsync = function(a, f) {
        this.wrapAsync(this.fsyncBase, [a], f);
      }, g.prototype.fdatasyncBase = function(a) {
        this.getFileByFdOrThrow(a, "fdatasync");
      }, g.prototype.fdatasyncSync = function(a) {
        this.fdatasyncBase(a);
      }, g.prototype.fdatasync = function(a, f) {
        this.wrapAsync(this.fdatasyncBase, [a], f);
      }, g.prototype.ftruncateBase = function(a, f) {
        var y = this.getFileByFdOrThrow(a, "ftruncate");
        y.truncate(f);
      }, g.prototype.ftruncateSync = function(a, f) {
        this.ftruncateBase(a, f);
      }, g.prototype.ftruncate = function(a, f, y) {
        var w = typeof f == "number" ? f : 0, O = De(typeof f == "number" ? y : f);
        this.wrapAsync(this.ftruncateBase, [a, w], O);
      }, g.prototype.truncateBase = function(a, f) {
        var y = this.openSync(a, "r+");
        try {
          this.ftruncateSync(y, f);
        } finally {
          this.closeSync(y);
        }
      }, g.prototype.truncateSync = function(a, f) {
        if (Je(a))
          return this.ftruncateSync(a, f);
        this.truncateBase(a, f);
      }, g.prototype.truncate = function(a, f, y) {
        var w = typeof f == "number" ? f : 0, O = De(typeof f == "number" ? y : f);
        if (Je(a))
          return this.ftruncate(a, w, O);
        this.wrapAsync(this.truncateBase, [a, w], O);
      }, g.prototype.futimesBase = function(a, f, y) {
        var w = this.getFileByFdOrThrow(a, "futimes"), O = w.node;
        O.atime = new Date(f * 1e3), O.mtime = new Date(y * 1e3);
      }, g.prototype.futimesSync = function(a, f, y) {
        this.futimesBase(a, Ue(f), Ue(y));
      }, g.prototype.futimes = function(a, f, y, w) {
        this.wrapAsync(this.futimesBase, [a, Ue(f), Ue(y)], w);
      }, g.prototype.utimesBase = function(a, f, y) {
        var w = this.openSync(a, "r");
        try {
          this.futimesBase(w, f, y);
        } finally {
          this.closeSync(w);
        }
      }, g.prototype.utimesSync = function(a, f, y) {
        this.utimesBase($(a), Ue(f), Ue(y));
      }, g.prototype.utimes = function(a, f, y, w) {
        this.wrapAsync(this.utimesBase, [$(a), Ue(f), Ue(y)], w);
      }, g.prototype.mkdirBase = function(a, f) {
        var y = Te(a);
        if (!y.length)
          throw Q(ye, "mkdir", a);
        var w = this.getLinkParentAsDirOrThrow(a, "mkdir"), O = y[y.length - 1];
        if (w.getChild(O))
          throw Q(ye, "mkdir", a);
        w.createChild(O, this.createNode(!0, f));
      }, g.prototype.mkdirpBase = function(a, f) {
        for (var y = Be(a), w = y.substring(1), O = w ? w.split(ne) : [], P = this.root, z = !1, J = 0; J < O.length; J++) {
          var ee = O[J];
          if (!P.getNode().isDirectory())
            throw Q(Fe, "mkdir", P.getPath());
          var ue = P.getChild(ee);
          if (ue)
            if (ue.getNode().isDirectory())
              P = ue;
            else
              throw Q(Fe, "mkdir", ue.getPath());
          else
            P = P.createChild(ee, this.createNode(!0, f)), z = !0;
        }
        return z ? y : void 0;
      }, g.prototype.mkdirSync = function(a, f) {
        var y = Er(f), w = $e(y.mode, 511), O = $(a);
        if (y.recursive)
          return this.mkdirpBase(O, w);
        this.mkdirBase(O, w);
      }, g.prototype.mkdir = function(a, f, y) {
        var w = Er(f), O = De(typeof f == "function" ? f : y), P = $e(w.mode, 511), z = $(a);
        w.recursive ? this.wrapAsync(this.mkdirpBase, [z, P], O) : this.wrapAsync(this.mkdirBase, [z, P], O);
      }, g.prototype.mkdirpSync = function(a, f) {
        return this.mkdirSync(a, { mode: f, recursive: !0 });
      }, g.prototype.mkdirp = function(a, f, y) {
        var w = typeof f == "function" ? void 0 : f, O = De(typeof f == "function" ? f : y);
        this.mkdir(a, { mode: w, recursive: !0 }, O);
      }, g.prototype.mkdtempBase = function(a, f, y) {
        y === void 0 && (y = 5);
        var w = a + this.genRndStr();
        try {
          return this.mkdirBase(
            w,
            511
            /* MODE.DIR */
          ), (0, b.strToEncoding)(w, f);
        } catch (O) {
          if (O.code === ye) {
            if (y > 1)
              return this.mkdtempBase(a, f, y - 1);
            throw Error("Could not create temp dir.");
          } else
            throw O;
        }
      }, g.prototype.mkdtempSync = function(a, f) {
        var y = Kt(f).encoding;
        if (!a || typeof a != "string")
          throw new TypeError("filename prefix is required");
        return kt(a), this.mkdtempBase(a, y);
      }, g.prototype.mkdtemp = function(a, f, y) {
        var w = _r(f, y), O = w[0].encoding, P = w[1];
        if (!a || typeof a != "string")
          throw new TypeError("filename prefix is required");
        kt(a) && this.wrapAsync(this.mkdtempBase, [a, O], P);
      }, g.prototype.rmdirBase = function(a, f) {
        var y = Ar(f), w = this.getLinkAsDirOrThrow(a, "rmdir");
        if (w.length && !y.recursive)
          throw Q(k, "rmdir", a);
        this.deleteLink(w);
      }, g.prototype.rmdirSync = function(a, f) {
        this.rmdirBase($(a), f);
      }, g.prototype.rmdir = function(a, f, y) {
        var w = Ar(f), O = De(typeof f == "function" ? f : y);
        this.wrapAsync(this.rmdirBase, [$(a), w], O);
      }, g.prototype.rmBase = function(a, f) {
        f === void 0 && (f = {});
        var y = this.getResolvedLink(a);
        if (!y) {
          if (!f.force)
            throw Q(q, "stat", a);
          return;
        }
        if (y.getNode().isDirectory() && !f.recursive)
          throw Q(te, "rm", a);
        this.deleteLink(y);
      }, g.prototype.rmSync = function(a, f) {
        this.rmBase($(a), f);
      }, g.prototype.rm = function(a, f, y) {
        var w = xn(f, y), O = w[0], P = w[1];
        this.wrapAsync(this.rmBase, [$(a), O], P);
      }, g.prototype.fchmodBase = function(a, f) {
        var y = this.getFileByFdOrThrow(a, "fchmod");
        y.chmod(f);
      }, g.prototype.fchmodSync = function(a, f) {
        this.fchmodBase(a, $e(f));
      }, g.prototype.fchmod = function(a, f, y) {
        this.wrapAsync(this.fchmodBase, [a, $e(f)], y);
      }, g.prototype.chmodBase = function(a, f) {
        var y = this.openSync(a, "r");
        try {
          this.fchmodBase(y, f);
        } finally {
          this.closeSync(y);
        }
      }, g.prototype.chmodSync = function(a, f) {
        var y = $e(f), w = $(a);
        this.chmodBase(w, y);
      }, g.prototype.chmod = function(a, f, y) {
        var w = $e(f), O = $(a);
        this.wrapAsync(this.chmodBase, [O, w], y);
      }, g.prototype.lchmodBase = function(a, f) {
        var y = this.openBase(a, I, 0, !1);
        try {
          this.fchmodBase(y, f);
        } finally {
          this.closeSync(y);
        }
      }, g.prototype.lchmodSync = function(a, f) {
        var y = $e(f), w = $(a);
        this.lchmodBase(w, y);
      }, g.prototype.lchmod = function(a, f, y) {
        var w = $e(f), O = $(a);
        this.wrapAsync(this.lchmodBase, [O, w], y);
      }, g.prototype.fchownBase = function(a, f, y) {
        this.getFileByFdOrThrow(a, "fchown").chown(f, y);
      }, g.prototype.fchownSync = function(a, f, y) {
        qt(f), Jt(y), this.fchownBase(a, f, y);
      }, g.prototype.fchown = function(a, f, y, w) {
        qt(f), Jt(y), this.wrapAsync(this.fchownBase, [a, f, y], w);
      }, g.prototype.chownBase = function(a, f, y) {
        var w = this.getResolvedLinkOrThrow(a, "chown"), O = w.getNode();
        O.chown(f, y);
      }, g.prototype.chownSync = function(a, f, y) {
        qt(f), Jt(y), this.chownBase($(a), f, y);
      }, g.prototype.chown = function(a, f, y, w) {
        qt(f), Jt(y), this.wrapAsync(this.chownBase, [$(a), f, y], w);
      }, g.prototype.lchownBase = function(a, f, y) {
        this.getLinkOrThrow(a, "lchown").getNode().chown(f, y);
      }, g.prototype.lchownSync = function(a, f, y) {
        qt(f), Jt(y), this.lchownBase($(a), f, y);
      }, g.prototype.lchown = function(a, f, y, w) {
        qt(f), Jt(y), this.wrapAsync(this.lchownBase, [$(a), f, y], w);
      }, g.prototype.watchFile = function(a, f, y) {
        var w = $(a), O = f, P = y;
        if (typeof O == "function" && (P = f, O = null), typeof P != "function")
          throw Error('"watchFile()" requires a listener function');
        var z = 5007, J = !0;
        O && typeof O == "object" && (typeof O.interval == "number" && (z = O.interval), typeof O.persistent == "boolean" && (J = O.persistent));
        var ee = this.statWatchers[w];
        return ee || (ee = new this.StatWatcher(), ee.start(w, J, z), this.statWatchers[w] = ee), ee.addListener("change", P), ee;
      }, g.prototype.unwatchFile = function(a, f) {
        var y = $(a), w = this.statWatchers[y];
        w && (typeof f == "function" ? w.removeListener("change", f) : w.removeAllListeners("change"), w.listenerCount("change") === 0 && (w.stop(), delete this.statWatchers[y]));
      }, g.prototype.createReadStream = function(a, f) {
        return new this.ReadStream(a, f);
      }, g.prototype.createWriteStream = function(a, f) {
        return new this.WriteStream(a, f);
      }, g.prototype.watch = function(a, f, y) {
        var w = $(a), O = f;
        typeof f == "function" && (y = f, O = null);
        var P = Kt(O), z = P.persistent, J = P.recursive, ee = P.encoding;
        z === void 0 && (z = !0), J === void 0 && (J = !1);
        var ue = new this.FSWatcher();
        return ue.start(w, z, J, ee), y && ue.addListener("change", y), ue;
      }, g.fd = 2147483647, g;
    }()
  );
  e.Volume = nl;
  function il(g) {
    g.emit("stop");
  }
  var ys = (
    /** @class */
    function(g) {
      t(a, g);
      function a(f) {
        var y = g.call(this) || this;
        return y.onInterval = function() {
          try {
            var w = y.vol.statSync(y.filename);
            y.hasChanged(w) && (y.emit("change", w, y.prev), y.prev = w);
          } finally {
            y.loop();
          }
        }, y.vol = f, y;
      }
      return a.prototype.loop = function() {
        this.timeoutRef = this.setTimeout(this.onInterval, this.interval);
      }, a.prototype.hasChanged = function(f) {
        return f.mtimeMs > this.prev.mtimeMs || f.nlink !== this.prev.nlink;
      }, a.prototype.start = function(f, y, w) {
        y === void 0 && (y = !0), w === void 0 && (w = 5007), this.filename = $(f), this.setTimeout = y ? setTimeout.bind(typeof globalThis < "u" ? globalThis : Ce) : d.default, this.interval = w, this.prev = this.vol.statSync(this.filename), this.loop();
      }, a.prototype.stop = function() {
        clearTimeout(this.timeoutRef), F.default.nextTick(il, this);
      }, a;
    }(h.EventEmitter)
  );
  e.StatWatcher = ys;
  var Ze;
  function sl(g) {
    Ze = (0, u.bufferAllocUnsafe)(g), Ze.used = 0;
  }
  S.inherits(ot, s.Readable), e.ReadStream = ot;
  function ot(g, a, f) {
    if (!(this instanceof ot))
      return new ot(g, a, f);
    if (this._vol = g, f = Object.assign({}, Ke(f, {})), f.highWaterMark === void 0 && (f.highWaterMark = 64 * 1024), s.Readable.call(this, f), this.path = $(a), this.fd = f.fd === void 0 ? null : f.fd, this.flags = f.flags === void 0 ? "r" : f.flags, this.mode = f.mode === void 0 ? 438 : f.mode, this.start = f.start, this.end = f.end, this.autoClose = f.autoClose === void 0 ? !0 : f.autoClose, this.pos = void 0, this.bytesRead = 0, this.start !== void 0) {
      if (typeof this.start != "number")
        throw new TypeError('"start" option must be a Number');
      if (this.end === void 0)
        this.end = 1 / 0;
      else if (typeof this.end != "number")
        throw new TypeError('"end" option must be a Number');
      if (this.start > this.end)
        throw new Error('"start" option must be <= "end" option');
      this.pos = this.start;
    }
    typeof this.fd != "number" && this.open(), this.on("end", function() {
      this.autoClose && this.destroy && this.destroy();
    });
  }
  ot.prototype.open = function() {
    var g = this;
    this._vol.open(this.path, this.flags, this.mode, function(a, f) {
      if (a) {
        g.autoClose && g.destroy && g.destroy(), g.emit("error", a);
        return;
      }
      g.fd = f, g.emit("open", f), g.read();
    });
  }, ot.prototype._read = function(g) {
    if (typeof this.fd != "number")
      return this.once("open", function() {
        this._read(g);
      });
    if (this.destroyed)
      return;
    (!Ze || Ze.length - Ze.used < B) && sl(this._readableState.highWaterMark);
    var a = Ze, f = Math.min(Ze.length - Ze.used, g), y = Ze.used;
    if (this.pos !== void 0 && (f = Math.min(this.end - this.pos + 1, f)), f <= 0)
      return this.push(null);
    var w = this;
    this._vol.read(this.fd, Ze, Ze.used, f, this.pos, O), this.pos !== void 0 && (this.pos += f), Ze.used += f;
    function O(P, z) {
      if (P)
        w.autoClose && w.destroy && w.destroy(), w.emit("error", P);
      else {
        var J = null;
        z > 0 && (w.bytesRead += z, J = a.slice(y, y + z)), w.push(J);
      }
    }
  }, ot.prototype._destroy = function(g, a) {
    this.close(function(f) {
      a(g || f);
    });
  }, ot.prototype.close = function(g) {
    var a = this, f;
    if (g && this.once("close", g), this.closed || typeof this.fd != "number") {
      if (typeof this.fd != "number") {
        this.once("open", ps);
        return;
      }
      return F.default.nextTick(function() {
        return a.emit("close");
      });
    }
    typeof ((f = this._readableState) === null || f === void 0 ? void 0 : f.closed) == "boolean" ? this._readableState.closed = !0 : this.closed = !0, this._vol.close(this.fd, function(y) {
      y ? a.emit("error", y) : a.emit("close");
    }), this.fd = null;
  };
  function ps(g) {
    this.close();
  }
  S.inherits(Qe, s.Writable), e.WriteStream = Qe;
  function Qe(g, a, f) {
    if (!(this instanceof Qe))
      return new Qe(g, a, f);
    if (this._vol = g, f = Object.assign({}, Ke(f, {})), s.Writable.call(this, f), this.path = $(a), this.fd = f.fd === void 0 ? null : f.fd, this.flags = f.flags === void 0 ? "w" : f.flags, this.mode = f.mode === void 0 ? 438 : f.mode, this.start = f.start, this.autoClose = f.autoClose === void 0 ? !0 : !!f.autoClose, this.pos = void 0, this.bytesWritten = 0, this.start !== void 0) {
      if (typeof this.start != "number")
        throw new TypeError('"start" option must be a Number');
      if (this.start < 0)
        throw new Error('"start" must be >= zero');
      this.pos = this.start;
    }
    f.encoding && this.setDefaultEncoding(f.encoding), typeof this.fd != "number" && this.open(), this.once("finish", function() {
      this.autoClose && this.close();
    });
  }
  Qe.prototype.open = function() {
    this._vol.open(this.path, this.flags, this.mode, function(g, a) {
      if (g) {
        this.autoClose && this.destroy && this.destroy(), this.emit("error", g);
        return;
      }
      this.fd = a, this.emit("open", a);
    }.bind(this));
  }, Qe.prototype._write = function(g, a, f) {
    if (!(g instanceof u.Buffer || g instanceof Uint8Array))
      return this.emit("error", new Error("Invalid data"));
    if (typeof this.fd != "number")
      return this.once("open", function() {
        this._write(g, a, f);
      });
    var y = this;
    this._vol.write(this.fd, g, 0, g.length, this.pos, function(w, O) {
      if (w)
        return y.autoClose && y.destroy && y.destroy(), f(w);
      y.bytesWritten += O, f();
    }), this.pos !== void 0 && (this.pos += g.length);
  }, Qe.prototype._writev = function(g, a) {
    if (typeof this.fd != "number")
      return this.once("open", function() {
        this._writev(g, a);
      });
    for (var f = this, y = g.length, w = new Array(y), O = 0, P = 0; P < y; P++) {
      var z = g[P].chunk;
      w[P] = z, O += z.length;
    }
    var J = u.Buffer.concat(w);
    this._vol.write(this.fd, J, 0, J.length, this.pos, function(ee, ue) {
      if (ee)
        return f.destroy && f.destroy(), a(ee);
      f.bytesWritten += ue, a();
    }), this.pos !== void 0 && (this.pos += O);
  }, Qe.prototype.close = function(g) {
    var a = this, f;
    if (g && this.once("close", g), this.closed || typeof this.fd != "number") {
      if (typeof this.fd != "number") {
        this.once("open", ps);
        return;
      }
      return F.default.nextTick(function() {
        return a.emit("close");
      });
    }
    typeof ((f = this._writableState) === null || f === void 0 ? void 0 : f.closed) == "boolean" ? this._writableState.closed = !0 : this.closed = !0, this._vol.close(this.fd, function(y) {
      y ? a.emit("error", y) : a.emit("close");
    }), this.fd = null;
  }, Qe.prototype._destroy = ot.prototype._destroy, Qe.prototype.destroySoon = Qe.prototype.end;
  var gs = (
    /** @class */
    function(g) {
      t(a, g);
      function a(f) {
        var y = g.call(this) || this;
        return y._filename = "", y._filenameEncoded = "", y._recursive = !1, y._encoding = b.ENCODING_UTF8, y._listenerRemovers = /* @__PURE__ */ new Map(), y._onParentChild = function(w) {
          w.getName() === y._getName() && y._emit("rename");
        }, y._emit = function(w) {
          y.emit("change", w, y._filenameEncoded);
        }, y._persist = function() {
          y._timer = setTimeout(y._persist, 1e6);
        }, y._vol = f, y;
      }
      return a.prototype._getName = function() {
        return this._steps[this._steps.length - 1];
      }, a.prototype.start = function(f, y, w, O) {
        var P = this;
        y === void 0 && (y = !0), w === void 0 && (w = !1), O === void 0 && (O = b.ENCODING_UTF8), this._filename = $(f), this._steps = Te(this._filename), this._filenameEncoded = (0, b.strToEncoding)(this._filename), this._recursive = w, this._encoding = O;
        try {
          this._link = this._vol.getLinkOrThrow(this._filename, "FSWatcher");
        } catch (ve) {
          var z = new Error("watch ".concat(this._filename, " ").concat(ve.code));
          throw z.code = ve.code, z.errno = ve.code, z;
        }
        var J = function(ve) {
          var We, Mt = ve.getPath(), at = ve.getNode(), Et = function() {
            var Me = we(P._filename, Mt);
            return Me || (Me = P._getName()), P.emit("change", "change", Me);
          };
          at.on("change", Et);
          var Ct = (We = P._listenerRemovers.get(at.ino)) !== null && We !== void 0 ? We : [];
          Ct.push(function() {
            return at.removeListener("change", Et);
          }), P._listenerRemovers.set(at.ino, Ct);
        }, ee = function(ve) {
          var We, Mt = ve.getNode(), at = function(Me) {
            P.emit("change", "rename", we(P._filename, Me.getPath())), setTimeout(function() {
              J(Me), ee(Me);
            });
          }, Et = function(Me) {
            var et = function(it) {
              var Zr = it.getNode().ino, ms = P._listenerRemovers.get(Zr);
              ms && (ms.forEach(function(Qr) {
                return Qr();
              }), P._listenerRemovers.delete(Zr)), Object.values(it.children).forEach(function(Qr) {
                Qr && et(Qr);
              });
            };
            et(Me), P.emit("change", "rename", we(P._filename, Me.getPath()));
          };
          Object.entries(ve.children).forEach(function(Me) {
            var et = Me[0], it = Me[1];
            it && et !== "." && et !== ".." && J(it);
          }), ve.on("child:add", at), ve.on("child:delete", Et);
          var Ct = (We = P._listenerRemovers.get(Mt.ino)) !== null && We !== void 0 ? We : [];
          Ct.push(function() {
            ve.removeListener("child:add", at), ve.removeListener("child:delete", Et);
          }), w && Object.entries(ve.children).forEach(function(Me) {
            var et = Me[0], it = Me[1];
            it && et !== "." && et !== ".." && ee(it);
          });
        };
        J(this._link), ee(this._link);
        var ue = this._link.parent;
        ue && (ue.setMaxListeners(ue.getMaxListeners() + 1), ue.on("child:delete", this._onParentChild)), y && this._persist();
      }, a.prototype.close = function() {
        clearTimeout(this._timer), this._listenerRemovers.forEach(function(y) {
          y.forEach(function(w) {
            return w();
          });
        }), this._listenerRemovers.clear();
        var f = this._link.parent;
        f && f.removeListener("child:delete", this._onParentChild);
      }, a;
    }(h.EventEmitter)
  );
  e.FSWatcher = gs;
})(Qo);
var It = {};
Object.defineProperty(It, "__esModule", {
  value: !0
});
It.fsSyncMethods = It.fsProps = It.fsAsyncMethods = void 0;
var yh = ["constants", "F_OK", "R_OK", "W_OK", "X_OK", "Stats"];
It.fsProps = yh;
var ph = ["renameSync", "ftruncateSync", "truncateSync", "chownSync", "fchownSync", "lchownSync", "chmodSync", "fchmodSync", "lchmodSync", "statSync", "lstatSync", "fstatSync", "linkSync", "symlinkSync", "readlinkSync", "realpathSync", "unlinkSync", "rmdirSync", "mkdirSync", "mkdirpSync", "readdirSync", "closeSync", "openSync", "utimesSync", "futimesSync", "fsyncSync", "writeSync", "readSync", "readFileSync", "writeFileSync", "appendFileSync", "existsSync", "accessSync", "fdatasyncSync", "mkdtempSync", "copyFileSync", "rmSync", "createReadStream", "createWriteStream"];
It.fsSyncMethods = ph;
var gh = ["rename", "ftruncate", "truncate", "chown", "fchown", "lchown", "chmod", "fchmod", "lchmod", "stat", "lstat", "fstat", "link", "symlink", "readlink", "realpath", "unlink", "rmdir", "mkdir", "mkdirp", "readdir", "close", "open", "utimes", "futimes", "fsync", "write", "read", "readFile", "writeFile", "appendFile", "exists", "access", "fdatasync", "mkdtemp", "copyFile", "rm", "watchFile", "unwatchFile", "watch"];
It.fsAsyncMethods = gh;
(function(e, t) {
  var r = Ce && Ce.__assign || function() {
    return r = Object.assign || function(p) {
      for (var S, E = 1, v = arguments.length; E < v; E++) {
        S = arguments[E];
        for (var m in S) Object.prototype.hasOwnProperty.call(S, m) && (p[m] = S[m]);
      }
      return p;
    }, r.apply(this, arguments);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.fs = t.createFsFromVolume = t.vol = t.Volume = void 0;
  var i = Ht, o = yr, c = Qo, n = It, u = n.fsSyncMethods, _ = n.fsAsyncMethods, F = Ft, d = F.constants.F_OK, s = F.constants.R_OK, l = F.constants.W_OK, h = F.constants.X_OK;
  t.Volume = c.Volume, t.vol = new c.Volume();
  function b(p) {
    for (var S = { F_OK: d, R_OK: s, W_OK: l, X_OK: h, constants: F.constants, Stats: i.default, Dirent: o.default }, E = 0, v = u; E < v.length; E++) {
      var m = v[E];
      typeof p[m] == "function" && (S[m] = p[m].bind(p));
    }
    for (var N = 0, I = _; N < I.length; N++) {
      var m = I[N];
      typeof p[m] == "function" && (S[m] = p[m].bind(p));
    }
    return S.StatWatcher = p.StatWatcher, S.FSWatcher = p.FSWatcher, S.WriteStream = p.WriteStream, S.ReadStream = p.ReadStream, S.promises = p.promises, S._toUnixTimestamp = c.toUnixTimestamp, S;
  }
  t.createFsFromVolume = b, t.fs = b(t.vol), e.exports = r(r({}, e.exports), t.fs), e.exports.semantic = !0;
})(Si, Si.exports);
var xr = Si.exports;
const {
  F_OK: By,
  R_OK: Py,
  W_OK: ky,
  X_OK: My,
  constants: Cy,
  Stats: Ly,
  Dirent: Uy,
  renameSync: Wy,
  ftruncateSync: jy,
  truncateSync: $y,
  chownSync: xy,
  fchownSync: Hy,
  lchownSync: zy,
  chmodSync: Vy,
  fchmodSync: Gy,
  lchmodSync: Ky,
  statSync: Yy,
  lstatSync: qy,
  fstatSync: Jy,
  linkSync: Xy,
  symlinkSync: Zy,
  readlinkSync: Qy,
  realpathSync: ep,
  unlinkSync: tp,
  rmdirSync: rp,
  mkdirSync: np,
  mkdirpSync: ip,
  readdirSync: sp,
  closeSync: op,
  openSync: ap,
  utimesSync: lp,
  futimesSync: fp,
  fsyncSync: up,
  writeSync: cp,
  readSync: dp,
  readFileSync: hp,
  writeFileSync: yp,
  appendFileSync: pp,
  existsSync: gp,
  accessSync: mp,
  fdatasyncSync: bp,
  mkdtempSync: wp,
  copyFileSync: _p,
  rmSync: Sp,
  createReadStream: vp,
  createWriteStream: Ep,
  rename: Ap,
  ftruncate: Tp,
  truncate: Rp,
  chown: Ip,
  fchown: Fp,
  lchown: Np,
  chmod: Op,
  fchmod: Dp,
  lchmod: Bp,
  stat: Pp,
  lstat: kp,
  fstat: Mp,
  link: Cp,
  symlink: Lp,
  readlink: Up,
  realpath: Wp,
  unlink: jp,
  rmdir: $p,
  mkdir: xp,
  mkdirp: Hp,
  readdir: zp,
  close: Vp,
  open: Gp,
  utimes: Kp,
  futimes: Yp,
  fsync: qp,
  write: Jp,
  read: Xp,
  readFile: Zp,
  writeFile: Qp,
  appendFile: eg,
  exists: tg,
  access: rg,
  fdatasync: ng,
  mkdtemp: ig,
  copyFile: sg,
  rm: og,
  watchFile: ag,
  unwatchFile: lg,
  watch: fg,
  StatWatcher: ug,
  FSWatcher: cg,
  WriteStream: dg,
  ReadStream: hg,
  promises: yg,
  _toUnixTimestamp: pg
} = xr.fs;
var mh = xr.Volume, bh = xr.createFsFromVolume;
xr.fs;
xr.vol;
const Hr = typeof WebAssembly < "u" ? WebAssembly : typeof WXWebAssembly < "u" ? WXWebAssembly : void 0;
if (!Hr)
  throw new Error("WebAssembly is not supported in this environment");
function ir(e, t) {
  if (e === null || typeof e != "object")
    throw new TypeError(`${t} must be an object. Received ${e === null ? "null" : typeof e}`);
}
function wh(e, t) {
  if (!Array.isArray(e))
    throw new TypeError(`${t} must be an array. Received ${e === null ? "null" : typeof e}`);
}
function _h(e, t) {
  if (typeof e != "boolean")
    throw new TypeError(`${t} must be a boolean. Received ${e === null ? "null" : typeof e}`);
}
function Ya(e, t) {
  if (typeof e != "string")
    throw new TypeError(`${t} must be a string. Received ${e === null ? "null" : typeof e}`);
}
function En(e, t) {
  if (typeof e != "function")
    throw new TypeError(`${t} must be a function. Received ${e === null ? "null" : typeof e}`);
}
function To(e, t) {
  if (e !== void 0)
    throw new TypeError(`${t} must be undefined. Received ${e === null ? "null" : typeof e}`);
}
function Sh(e) {
  return !!(e && (typeof e == "object" || typeof e == "function") && typeof e.then == "function");
}
function Ne(e, t, r) {
  return typeof SharedArrayBuffer == "function" && e.buffer instanceof SharedArrayBuffer || Object.prototype.toString.call(e.buffer.constructor) === "[object SharedArrayBuffer]" ? e.slice(t, r) : e.subarray(t, r);
}
const bi = 46, ds = 47;
function vh(e) {
  return e === ds;
}
function Eh(e, t, r, i) {
  let o = "", c = 0, n = -1, u = 0, _ = 0;
  for (let F = 0; F <= e.length; ++F) {
    if (F < e.length)
      _ = e.charCodeAt(F);
    else {
      if (i(_))
        break;
      _ = ds;
    }
    if (i(_)) {
      if (!(n === F - 1 || u === 1)) if (u === 2) {
        if (o.length < 2 || c !== 2 || o.charCodeAt(o.length - 1) !== bi || o.charCodeAt(o.length - 2) !== bi) {
          if (o.length > 2) {
            const d = o.indexOf(r);
            d === -1 ? (o = "", c = 0) : (o = o.slice(0, d), c = o.length - 1 - o.indexOf(r)), n = F, u = 0;
            continue;
          } else if (o.length !== 0) {
            o = "", c = 0, n = F, u = 0;
            continue;
          }
        }
        t && (o += o.length > 0 ? `${r}..` : "..", c = 2);
      } else
        o.length > 0 ? o += `${r}${e.slice(n + 1, F)}` : o = e.slice(n + 1, F), c = F - n - 1;
      n = F, u = 0;
    } else _ === bi && u !== -1 ? ++u : u = -1;
  }
  return o;
}
function Pe(...e) {
  let t = "", r = !1;
  for (let i = e.length - 1; i >= -1 && !r; i--) {
    const o = i >= 0 ? e[i] : "/";
    Ya(o, "path"), o.length !== 0 && (t = `${o}/${t}`, r = o.charCodeAt(0) === ds);
  }
  return t = Eh(t, !r, "/", vh), r ? `/${t}` : t.length > 0 ? t : ".";
}
const Ah = /* @__PURE__ */ BigInt(1) << /* @__PURE__ */ BigInt(0), Th = /* @__PURE__ */ BigInt(1) << /* @__PURE__ */ BigInt(1), Rh = /* @__PURE__ */ BigInt(1) << /* @__PURE__ */ BigInt(2), Ih = /* @__PURE__ */ BigInt(1) << /* @__PURE__ */ BigInt(3), Fh = /* @__PURE__ */ BigInt(1) << /* @__PURE__ */ BigInt(4), Nh = /* @__PURE__ */ BigInt(1) << /* @__PURE__ */ BigInt(5), Oh = /* @__PURE__ */ BigInt(1) << /* @__PURE__ */ BigInt(6), Dh = /* @__PURE__ */ BigInt(1) << /* @__PURE__ */ BigInt(7), Bh = /* @__PURE__ */ BigInt(1) << /* @__PURE__ */ BigInt(8), Ph = /* @__PURE__ */ BigInt(1) << /* @__PURE__ */ BigInt(9), kh = /* @__PURE__ */ BigInt(1) << /* @__PURE__ */ BigInt(10), Mh = /* @__PURE__ */ BigInt(1) << /* @__PURE__ */ BigInt(11), Ch = /* @__PURE__ */ BigInt(1) << /* @__PURE__ */ BigInt(12), Lh = /* @__PURE__ */ BigInt(1) << /* @__PURE__ */ BigInt(13), Uh = /* @__PURE__ */ BigInt(1) << /* @__PURE__ */ BigInt(14), Wh = /* @__PURE__ */ BigInt(1) << /* @__PURE__ */ BigInt(15), jh = /* @__PURE__ */ BigInt(1) << /* @__PURE__ */ BigInt(16), $h = /* @__PURE__ */ BigInt(1) << /* @__PURE__ */ BigInt(17), xh = /* @__PURE__ */ BigInt(1) << /* @__PURE__ */ BigInt(18), Hh = /* @__PURE__ */ BigInt(1) << /* @__PURE__ */ BigInt(19), zh = /* @__PURE__ */ BigInt(1) << /* @__PURE__ */ BigInt(20), Vh = /* @__PURE__ */ BigInt(1) << /* @__PURE__ */ BigInt(21), Gh = /* @__PURE__ */ BigInt(1) << /* @__PURE__ */ BigInt(22), Kh = /* @__PURE__ */ BigInt(1) << /* @__PURE__ */ BigInt(23), Yh = /* @__PURE__ */ BigInt(1) << /* @__PURE__ */ BigInt(24), qh = /* @__PURE__ */ BigInt(1) << /* @__PURE__ */ BigInt(25), Jh = /* @__PURE__ */ BigInt(1) << /* @__PURE__ */ BigInt(26), Xh = /* @__PURE__ */ BigInt(1) << /* @__PURE__ */ BigInt(27), Zh = /* @__PURE__ */ BigInt(1) << /* @__PURE__ */ BigInt(28), Qh = /* @__PURE__ */ BigInt(1) << /* @__PURE__ */ BigInt(29), C = {
  FD_DATASYNC: Ah,
  FD_READ: Th,
  FD_SEEK: Rh,
  FD_FDSTAT_SET_FLAGS: Ih,
  FD_SYNC: Fh,
  FD_TELL: Nh,
  FD_WRITE: Oh,
  FD_ADVISE: Dh,
  FD_ALLOCATE: Bh,
  PATH_CREATE_DIRECTORY: Ph,
  PATH_CREATE_FILE: kh,
  PATH_LINK_SOURCE: Mh,
  PATH_LINK_TARGET: Ch,
  PATH_OPEN: Lh,
  FD_READDIR: Uh,
  PATH_READLINK: Wh,
  PATH_RENAME_SOURCE: jh,
  PATH_RENAME_TARGET: $h,
  PATH_FILESTAT_GET: xh,
  PATH_FILESTAT_SET_SIZE: Hh,
  PATH_FILESTAT_SET_TIMES: zh,
  FD_FILESTAT_GET: Vh,
  FD_FILESTAT_SET_SIZE: Gh,
  FD_FILESTAT_SET_TIMES: Kh,
  PATH_SYMLINK: Yh,
  PATH_REMOVE_DIRECTORY: qh,
  PATH_UNLINK_FILE: Jh,
  POLL_FD_READWRITE: Xh,
  SOCK_SHUTDOWN: Zh,
  SOCK_ACCEPT: Qh
};
function ey(e) {
  switch (e) {
    case 0:
      return "Success";
    case 1:
      return "Argument list too long";
    case 2:
      return "Permission denied";
    case 3:
      return "Address in use";
    case 4:
      return "Address not available";
    case 5:
      return "Address family not supported by protocol";
    case 6:
      return "Resource temporarily unavailable";
    case 7:
      return "Operation already in progress";
    case 8:
      return "Bad file descriptor";
    case 9:
      return "Bad message";
    case 10:
      return "Resource busy";
    case 11:
      return "Operation canceled";
    case 12:
      return "No child process";
    case 13:
      return "Connection aborted";
    case 14:
      return "Connection refused";
    case 15:
      return "Connection reset by peer";
    case 16:
      return "Resource deadlock would occur";
    case 17:
      return "Destination address required";
    case 18:
      return "Domain error";
    case 19:
      return "Quota exceeded";
    case 20:
      return "File exists";
    case 21:
      return "Bad address";
    case 22:
      return "File too large";
    case 23:
      return "Host is unreachable";
    case 24:
      return "Identifier removed";
    case 25:
      return "Illegal byte sequence";
    case 26:
      return "Operation in progress";
    case 27:
      return "Interrupted system call";
    case 28:
      return "Invalid argument";
    case 29:
      return "I/O error";
    case 30:
      return "Socket is connected";
    case 31:
      return "Is a directory";
    case 32:
      return "Symbolic link loop";
    case 33:
      return "No file descriptors available";
    case 34:
      return "Too many links";
    case 35:
      return "Message too large";
    case 36:
      return "Multihop attempted";
    case 37:
      return "Filename too long";
    case 38:
      return "Network is down";
    case 39:
      return "Connection reset by network";
    case 40:
      return "Network unreachable";
    case 41:
      return "Too many files open in system";
    case 42:
      return "No buffer space available";
    case 43:
      return "No such device";
    case 44:
      return "No such file or directory";
    case 45:
      return "Exec format error";
    case 46:
      return "No locks available";
    case 47:
      return "Link has been severed";
    case 48:
      return "Out of memory";
    case 49:
      return "No message of the desired type";
    case 50:
      return "Protocol not available";
    case 51:
      return "No space left on device";
    case 52:
      return "Function not implemented";
    case 53:
      return "Socket not connected";
    case 54:
      return "Not a directory";
    case 55:
      return "Directory not empty";
    case 56:
      return "State not recoverable";
    case 57:
      return "Not a socket";
    case 58:
      return "Not supported";
    case 59:
      return "Not a tty";
    case 60:
      return "No such device or address";
    case 61:
      return "Value too large for data type";
    case 62:
      return "Previous owner died";
    case 63:
      return "Operation not permitted";
    case 64:
      return "Broken pipe";
    case 65:
      return "Protocol error";
    case 66:
      return "Protocol not supported";
    case 67:
      return "Protocol wrong type for socket";
    case 68:
      return "Result not representable";
    case 69:
      return "Read-only file system";
    case 70:
      return "Invalid seek";
    case 71:
      return "No such process";
    case 72:
      return "Stale file handle";
    case 73:
      return "Operation timed out";
    case 74:
      return "Text file busy";
    case 75:
      return "Cross-device link";
    case 76:
      return "Capabilities insufficient";
    default:
      return "Unknown error";
  }
}
class xe extends Error {
  constructor(t, r) {
    super(t), this.errno = r;
  }
  getErrorMessage() {
    return ey(this.errno);
  }
}
Object.defineProperty(xe.prototype, "name", {
  configurable: !0,
  writable: !0,
  value: "WasiError"
});
const zr = C.FD_DATASYNC | C.FD_READ | C.FD_SEEK | C.FD_FDSTAT_SET_FLAGS | C.FD_SYNC | C.FD_TELL | C.FD_WRITE | C.FD_ADVISE | C.FD_ALLOCATE | C.PATH_CREATE_DIRECTORY | C.PATH_CREATE_FILE | C.PATH_LINK_SOURCE | C.PATH_LINK_TARGET | C.PATH_OPEN | C.FD_READDIR | C.PATH_READLINK | C.PATH_RENAME_SOURCE | C.PATH_RENAME_TARGET | C.PATH_FILESTAT_GET | C.PATH_FILESTAT_SET_SIZE | C.PATH_FILESTAT_SET_TIMES | C.FD_FILESTAT_GET | C.FD_FILESTAT_SET_TIMES | C.FD_FILESTAT_SET_SIZE | C.PATH_SYMLINK | C.PATH_UNLINK_FILE | C.PATH_REMOVE_DIRECTORY | C.POLL_FD_READWRITE | C.SOCK_SHUTDOWN | C.SOCK_ACCEPT, ty = zr, ry = zr, ny = zr, iy = zr, qa = C.FD_DATASYNC | C.FD_READ | C.FD_SEEK | C.FD_FDSTAT_SET_FLAGS | C.FD_SYNC | C.FD_TELL | C.FD_WRITE | C.FD_ADVISE | C.FD_ALLOCATE | C.FD_FILESTAT_GET | C.FD_FILESTAT_SET_SIZE | C.FD_FILESTAT_SET_TIMES | C.POLL_FD_READWRITE, sy = /* @__PURE__ */ BigInt(0), Ja = C.FD_FDSTAT_SET_FLAGS | C.FD_SYNC | C.FD_ADVISE | C.PATH_CREATE_DIRECTORY | C.PATH_CREATE_FILE | C.PATH_LINK_SOURCE | C.PATH_LINK_TARGET | C.PATH_OPEN | C.FD_READDIR | C.PATH_READLINK | C.PATH_RENAME_SOURCE | C.PATH_RENAME_TARGET | C.PATH_FILESTAT_GET | C.PATH_FILESTAT_SET_SIZE | C.PATH_FILESTAT_SET_TIMES | C.FD_FILESTAT_GET | C.FD_FILESTAT_SET_TIMES | C.PATH_SYMLINK | C.PATH_UNLINK_FILE | C.PATH_REMOVE_DIRECTORY | C.POLL_FD_READWRITE, oy = Ja | qa, ay = C.FD_READ | C.FD_FDSTAT_SET_FLAGS | C.FD_WRITE | C.FD_FILESTAT_GET | C.POLL_FD_READWRITE | C.SOCK_SHUTDOWN, ly = zr, fy = C.FD_READ | C.FD_FDSTAT_SET_FLAGS | C.FD_WRITE | C.FD_FILESTAT_GET | C.POLL_FD_READWRITE, uy = /* @__PURE__ */ BigInt(0);
function Cr(e, t, r, i) {
  const o = {
    base: BigInt(0),
    inheriting: BigInt(0)
  };
  if (i === 0)
    throw new xe(
      "Unknown file type",
      28
      /* WasiErrno.EINVAL */
    );
  switch (i) {
    case 4:
      o.base = qa, o.inheriting = sy;
      break;
    case 3:
      o.base = Ja, o.inheriting = oy;
      break;
    case 6:
    case 5:
      o.base = ay, o.inheriting = ly;
      break;
    case 2:
      e.indexOf(t) !== -1 ? (o.base = fy, o.inheriting = uy) : (o.base = ny, o.inheriting = iy);
      break;
    case 1:
      o.base = ty, o.inheriting = ry;
      break;
    default:
      o.base = BigInt(0), o.inheriting = BigInt(0);
  }
  const c = r & 3;
  return c === 0 ? o.base &= ~C.FD_WRITE : c === 1 && (o.base &= ~C.FD_READ), o;
}
function Dr(e, t) {
  let r = 0;
  for (let c = 0; c < e.length; c++) {
    const n = e[c];
    r += n.length;
  }
  let i = 0;
  const o = new Uint8Array(r);
  for (let c = 0; c < e.length; c++) {
    const n = e[c];
    o.set(n, i), i += n.length;
  }
  return o;
}
class Xa {
  constructor(t, r, i, o, c, n, u, _) {
    this.id = t, this.fd = r, this.path = i, this.realPath = o, this.type = c, this.rightsBase = n, this.rightsInheriting = u, this.preopen = _, this.pos = BigInt(0), this.size = BigInt(0);
  }
  seek(t, r) {
    if (r === 0)
      this.pos = BigInt(t);
    else if (r === 1)
      this.pos += BigInt(t);
    else if (r === 2)
      this.pos = BigInt(this.size) - BigInt(t);
    else
      throw new xe(
        "Unknown whence",
        29
        /* WasiErrno.EIO */
      );
    return this.pos;
  }
}
class Ro extends Xa {
  constructor(t, r, i, o, c, n, u, _, F) {
    super(r, i, o, c, n, u, _, F), this._log = t, this._buf = null;
  }
  write(t) {
    const r = t;
    if (this._buf && (t = Dr([this._buf, t]), this._buf = null), t.indexOf(10) === -1)
      return this._buf = t, r.byteLength;
    let i = 0, o = 0, c;
    for (; (c = t.indexOf(10, i)) !== -1; ) {
      const n = new TextDecoder().decode(t.subarray(o, c));
      this._log(n), i += c - o + 1, o = c + 1;
    }
    return i < t.length && (this._buf = t.slice(i)), r.byteLength;
  }
}
function hs(e) {
  return e.isBlockDevice() ? 1 : e.isCharacterDevice() ? 2 : e.isDirectory() ? 3 : e.isSocket() ? 6 : e.isFile() ? 4 : e.isSymbolicLink() ? 7 : 0;
}
function sn(e, t, r) {
  e.setBigUint64(t, r.dev, !0), e.setBigUint64(t + 8, r.ino, !0), e.setBigUint64(t + 16, BigInt(hs(r)), !0), e.setBigUint64(t + 24, r.nlink, !0), e.setBigUint64(t + 32, r.size, !0), e.setBigUint64(t + 40, r.atimeMs * BigInt(1e6), !0), e.setBigUint64(t + 48, r.mtimeMs * BigInt(1e6), !0), e.setBigUint64(t + 56, r.ctimeMs * BigInt(1e6), !0);
}
class Za {
  constructor(t) {
    this.used = 0, this.size = t.size, this.fds = Array(t.size), this.stdio = [t.in, t.out, t.err], this.print = t.print, this.printErr = t.printErr, this.insertStdio(t.in, 0, "<stdin>"), this.insertStdio(t.out, 1, "<stdout>"), this.insertStdio(t.err, 2, "<stderr>");
  }
  insertStdio(t, r, i) {
    const { base: c, inheriting: n } = Cr(this.stdio, t, 2, 2), u = this.insert(t, i, i, 2, c, n, 0);
    if (u.id !== r)
      throw new xe(
        `id: ${u.id} !== expected: ${r}`,
        8
        /* WasiErrno.EBADF */
      );
    return u;
  }
  insert(t, r, i, o, c, n, u) {
    var _, F;
    let d = -1;
    if (this.used >= this.size) {
      const l = this.size * 2;
      this.fds.length = l, d = this.size, this.size = l;
    } else
      for (let l = 0; l < this.size; ++l)
        if (this.fds[l] == null) {
          d = l;
          break;
        }
    let s;
    return r === "<stdout>" ? s = new Ro((_ = this.print) !== null && _ !== void 0 ? _ : console.log, d, t, r, i, o, c, n, u) : r === "<stderr>" ? s = new Ro((F = this.printErr) !== null && F !== void 0 ? F : console.error, d, t, r, i, o, c, n, u) : s = new Xa(d, t, r, i, o, c, n, u), this.fds[d] = s, this.used++, s;
  }
  get(t, r, i) {
    if (t >= this.size)
      throw new xe(
        "Invalid fd",
        8
        /* WasiErrno.EBADF */
      );
    const o = this.fds[t];
    if (!o || o.id !== t)
      throw new xe(
        "Bad file descriptor",
        8
        /* WasiErrno.EBADF */
      );
    if ((~o.rightsBase & r) !== BigInt(0) || (~o.rightsInheriting & i) !== BigInt(0))
      throw new xe(
        "Capabilities insufficient",
        76
        /* WasiErrno.ENOTCAPABLE */
      );
    return o;
  }
  remove(t) {
    if (t >= this.size)
      throw new xe(
        "Invalid fd",
        8
        /* WasiErrno.EBADF */
      );
    const r = this.fds[t];
    if (!r || r.id !== t)
      throw new xe(
        "Bad file descriptor",
        8
        /* WasiErrno.EBADF */
      );
    this.fds[t] = void 0, this.used--;
  }
}
class cy extends Za {
  constructor(t) {
    super(t), this.fs = t.fs;
  }
  getFileTypeByFd(t) {
    const r = this.fs.fstatSync(t, { bigint: !0 });
    return hs(r);
  }
  insertPreopen(t, r, i) {
    const o = this.getFileTypeByFd(t);
    if (o !== 3)
      throw new xe(
        `Preopen not dir: ["${r}", "${i}"]`,
        54
        /* WasiErrno.ENOTDIR */
      );
    const c = Cr(this.stdio, t, 0, o);
    return this.insert(t, r, i, o, c.base, c.inheriting, 1);
  }
  renumber(t, r) {
    if (t === r)
      return;
    if (t >= this.size || r >= this.size)
      throw new xe(
        "Invalid fd",
        8
        /* WasiErrno.EBADF */
      );
    const i = this.fds[t], o = this.fds[r];
    if (!i || !o || i.id !== t || o.id !== r)
      throw new xe(
        "Invalid fd",
        8
        /* WasiErrno.EBADF */
      );
    this.fs.closeSync(i.fd), this.fds[t] = this.fds[r], this.fds[t].id = t, this.fds[r] = void 0, this.used--;
  }
}
class dy extends Za {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor(t) {
    super(t);
  }
  async getFileTypeByFd(t) {
    const r = await t.stat({ bigint: !0 });
    return hs(r);
  }
  async insertPreopen(t, r, i) {
    const o = await this.getFileTypeByFd(t);
    if (o !== 3)
      throw new xe(
        `Preopen not dir: ["${r}", "${i}"]`,
        54
        /* WasiErrno.ENOTDIR */
      );
    const c = Cr(this.stdio, t.fd, 0, o);
    return this.insert(t, r, i, o, c.base, c.inheriting, 1);
  }
  async renumber(t, r) {
    if (t === r)
      return;
    if (t >= this.size || r >= this.size)
      throw new xe(
        "Invalid fd",
        8
        /* WasiErrno.EBADF */
      );
    const i = this.fds[t], o = this.fds[r];
    if (!i || !o || i.id !== t || o.id !== r)
      throw new xe(
        "Invalid fd",
        8
        /* WasiErrno.EBADF */
      );
    await i.fd.close(), this.fds[t] = this.fds[r], this.fds[t].id = t, this.fds[r] = void 0, this.used--;
  }
}
const hy = /* @__PURE__ */ function() {
  return Hr.Memory;
}();
class yy extends hy {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor(t) {
    super(t);
  }
  get HEAP8() {
    return new Int8Array(super.buffer);
  }
  get HEAPU8() {
    return new Uint8Array(super.buffer);
  }
  get HEAP16() {
    return new Int16Array(super.buffer);
  }
  get HEAPU16() {
    return new Uint16Array(super.buffer);
  }
  get HEAP32() {
    return new Int32Array(super.buffer);
  }
  get HEAPU32() {
    return new Uint32Array(super.buffer);
  }
  get HEAP64() {
    return new BigInt64Array(super.buffer);
  }
  get HEAPU64() {
    return new BigUint64Array(super.buffer);
  }
  get HEAPF32() {
    return new Float32Array(super.buffer);
  }
  get HEAPF64() {
    return new Float64Array(super.buffer);
  }
  get view() {
    return new DataView(super.buffer);
  }
}
function py(e) {
  return Object.getPrototypeOf(e) === Hr.Memory.prototype && Object.setPrototypeOf(e, yy.prototype), e;
}
function gy() {
  const e = Hr.Function;
  if (typeof e != "function")
    throw new Error('WebAssembly.Function is not supported in this environment. If you are using V8 based browser like Chrome, try to specify --js-flags="--wasm-staging --experimental-wasm-stack-switching"');
  return e;
}
function my(e, t, r) {
  const i = gy();
  if (typeof e != "function")
    throw new TypeError("Function required");
  const o = t.slice(0);
  return o.unshift("externref"), new i({ parameters: o, results: r }, e, { suspending: "first" });
}
function Qt(e, t) {
  if (e.length === 0 || t.length === 0)
    return 0;
  let r = 0, i = t.length - r;
  for (let o = 0; o < e.length; ++o) {
    const c = e[o];
    if (i < c.length)
      return c.set(t.subarray(r, r + i), 0), r += i, i = 0, r;
    c.set(t.subarray(r, r + c.length), 0), r += c.length, i -= c.length;
  }
  return r;
}
const Qa = /* @__PURE__ */ new WeakMap(), se = /* @__PURE__ */ new WeakMap(), el = /* @__PURE__ */ new WeakMap();
function ce(e) {
  return Qa.get(e);
}
function Ae(e) {
  const t = el.get(e);
  if (!t)
    throw new Error("filesystem is unavailable");
  return t;
}
function Io(e) {
  if (e instanceof xe)
    return console.warn(e), e.errno;
  switch (e.code) {
    case "ENOENT":
      return 44;
    case "EBADF":
      return 8;
    case "EINVAL":
      return 28;
    case "EPERM":
      return 63;
    case "EPROTO":
      return 65;
    case "EEXIST":
      return 20;
    case "ENOTDIR":
      return 54;
    case "EMFILE":
      return 33;
    case "EACCES":
      return 2;
    case "EISDIR":
      return 31;
    case "ENOTEMPTY":
      return 55;
    case "ENOSYS":
      return 52;
  }
  throw e;
}
function by(e, t) {
  return Object.defineProperty(t, "name", { value: e }), t;
}
function Ie(e, t, r) {
  return by(t, function() {
    let i;
    try {
      i = r.apply(e, arguments);
    } catch (o) {
      return Io(o);
    }
    return Sh(i) ? i.then((o) => o, Io) : i;
  });
}
function wi(e, t, r, i) {
  let o = Pe(t.realPath, r);
  if ((i & 1) === 1)
    try {
      o = e.readlinkSync(o);
    } catch (c) {
      if (c.code !== "EINVAL" && c.code !== "ENOENT")
        throw c;
    }
  return o;
}
async function _i(e, t, r, i) {
  let o = Pe(t.realPath, r);
  if ((i & 1) === 1)
    try {
      o = await e.promises.readlink(o);
    } catch (c) {
      if (c.code !== "EINVAL" && c.code !== "ENOENT")
        throw c;
    }
  return o;
}
const ft = /* @__PURE__ */ new TextEncoder(), Oe = /* @__PURE__ */ new TextDecoder(), on = (BigInt(1) << BigInt(63)) - BigInt(1);
function Fo() {
  const e = window.prompt();
  return e === null ? new Uint8Array() : new TextEncoder().encode(e + `
`);
}
function an(e) {
  return !!(e & -16) || (e & 3) === 3 || (e & 12) === 12;
}
class ur {
  constructor(t, r, i, o, c, n) {
    this.args_get = Ie(this, "args_get", function(s, l) {
      if (s = Number(s), l = Number(l), s === 0 || l === 0)
        return 28;
      const { HEAPU8: h, view: b } = ce(this), S = se.get(this).args;
      for (let E = 0; E < S.length; ++E) {
        const v = S[E];
        b.setInt32(s, l, !0), s += 4;
        const m = ft.encode(v + "\0");
        h.set(m, l), l += m.length;
      }
      return 0;
    }), this.args_sizes_get = Ie(this, "args_sizes_get", function(s, l) {
      if (s = Number(s), l = Number(l), s === 0 || l === 0)
        return 28;
      const { view: h } = ce(this), p = se.get(this).args;
      return h.setUint32(s, p.length, !0), h.setUint32(l, ft.encode(p.join("\0") + "\0").length, !0), 0;
    }), this.environ_get = Ie(this, "environ_get", function(s, l) {
      if (s = Number(s), l = Number(l), s === 0 || l === 0)
        return 28;
      const { HEAPU8: h, view: b } = ce(this), S = se.get(this).env;
      for (let E = 0; E < S.length; ++E) {
        const v = S[E];
        b.setInt32(s, l, !0), s += 4;
        const m = ft.encode(v + "\0");
        h.set(m, l), l += m.length;
      }
      return 0;
    }), this.environ_sizes_get = Ie(this, "environ_sizes_get", function(s, l) {
      if (s = Number(s), l = Number(l), s === 0 || l === 0)
        return 28;
      const { view: h } = ce(this), b = se.get(this);
      return h.setUint32(s, b.env.length, !0), h.setUint32(l, ft.encode(b.env.join("\0") + "\0").length, !0), 0;
    }), this.clock_res_get = Ie(this, "clock_res_get", function(s, l) {
      if (l = Number(l), l === 0)
        return 28;
      const { view: h } = ce(this);
      switch (s) {
        case 0:
          return h.setBigUint64(l, BigInt(1e6), !0), 0;
        case 1:
        case 2:
        case 3:
          return h.setBigUint64(l, BigInt(1e3), !0), 0;
        default:
          return 28;
      }
    }), this.clock_time_get = Ie(this, "clock_time_get", function(s, l, h) {
      if (h = Number(h), h === 0)
        return 28;
      const { view: b } = ce(this);
      switch (s) {
        case 0:
          return b.setBigUint64(h, BigInt(Date.now()) * BigInt(1e6), !0), 0;
        case 1:
        case 2:
        case 3: {
          const p = performance.now(), S = Math.trunc(p), E = Math.floor((p - S) * 1e3), v = BigInt(S) * BigInt(1e9) + BigInt(E) * BigInt(1e6);
          return b.setBigUint64(h, v, !0), 0;
        }
        default:
          return 28;
      }
    }), this.fd_advise = Ie(this, "fd_advise", function(s, l, h, b) {
      return 52;
    }), this.fd_fdstat_get = Ie(this, "fd_fdstat_get", function(s, l) {
      if (l = Number(l), l === 0)
        return 28;
      const b = se.get(this).fds.get(s, BigInt(0), BigInt(0)), { view: p } = ce(this);
      return p.setUint16(l, b.type, !0), p.setUint16(l + 2, 0, !0), p.setBigUint64(l + 8, b.rightsBase, !0), p.setBigUint64(l + 16, b.rightsInheriting, !0), 0;
    }), this.fd_fdstat_set_flags = Ie(this, "fd_fdstat_set_flags", function(s, l) {
      return 52;
    }), this.fd_fdstat_set_rights = Ie(this, "fd_fdstat_set_rights", function(s, l, h) {
      const p = se.get(this).fds.get(s, BigInt(0), BigInt(0));
      return (l | p.rightsBase) > p.rightsBase || (h | p.rightsInheriting) > p.rightsInheriting ? 76 : (p.rightsBase = l, p.rightsInheriting = h, 0);
    }), this.fd_prestat_get = Ie(this, "fd_prestat_get", function(s, l) {
      if (l = Number(l), l === 0)
        return 28;
      const h = se.get(this);
      let b;
      try {
        b = h.fds.get(s, BigInt(0), BigInt(0));
      } catch (S) {
        if (S instanceof xe)
          return S.errno;
        throw S;
      }
      if (b.preopen !== 1)
        return 28;
      const { view: p } = ce(this);
      return p.setUint32(l, 0, !0), p.setUint32(l + 4, ft.encode(b.path).length, !0), 0;
    }), this.fd_prestat_dir_name = Ie(this, "fd_prestat_dir_name", function(s, l, h) {
      if (l = Number(l), h = Number(h), l === 0)
        return 28;
      const p = se.get(this).fds.get(s, BigInt(0), BigInt(0));
      if (p.preopen !== 1)
        return 8;
      const S = ft.encode(p.path);
      if (S.length > h)
        return 42;
      const { HEAPU8: v } = ce(this);
      return v.set(S, l), 0;
    }), this.fd_seek = Ie(this, "fd_seek", function(s, l, h, b) {
      if (b = Number(b), b === 0)
        return 28;
      if (s === 0 || s === 1 || s === 2)
        return 0;
      const E = se.get(this).fds.get(s, C.FD_SEEK, BigInt(0)).seek(l, h), { view: v } = ce(this);
      return v.setBigUint64(b, E, !0), 0;
    }), this.fd_tell = Ie(this, "fd_tell", function(s, l) {
      const b = se.get(this).fds.get(s, C.FD_TELL, BigInt(0)), p = BigInt(b.pos), { view: S } = ce(this);
      return S.setBigUint64(Number(l), p, !0), 0;
    }), this.poll_oneoff = Ie(this, "poll_oneoff", function(s, l, h, b) {
      if (s = Number(s), l = Number(l), b = Number(b), h = Number(h), h = h >>> 0, s === 0 || l === 0 || h === 0 || b === 0)
        return 28;
      const { view: p } = ce(this);
      p.setUint32(b, 0, !0);
      let S = 0, E = BigInt(0), v = BigInt(0), m = 0, N = BigInt(0), I;
      const M = Array(h);
      for (S = 0; S < h; S++) {
        I = s + S * 48;
        const x = p.getBigUint64(I, !0), Y = p.getUint8(I + 8), X = p.getUint32(I + 16, !0), oe = p.getBigUint64(I + 24, !0), Z = p.getBigUint64(I + 32, !0), W = p.getUint16(I + 40, !0);
        M[S] = {
          userdata: x,
          type: Y,
          u: {
            clock: {
              clock_id: X,
              timeout: oe,
              precision: Z,
              flags: W
            },
            fd_readwrite: {
              fd: X
            }
          }
        };
      }
      const H = [];
      for (S = 0; S < h; S++)
        switch (I = M[S], I.type) {
          case 0: {
            if (I.u.clock.flags === 1) {
              const x = BigInt(Date.now()) * BigInt(1e6);
              v = I.u.clock.timeout - x;
            } else
              v = I.u.clock.timeout;
            (m === 0 || v < N) && (N = v, E = I.userdata, m = 1);
            break;
          }
          case 1:
          case 2:
            H.push(I);
            break;
          default:
            return 28;
        }
      if (H.length > 0) {
        for (S = 0; S < H.length; S++) {
          const x = H[S], Y = l + 32 * S;
          p.setBigUint64(Y, x.userdata, !0), p.setUint32(Y + 8, 52, !0), p.setUint32(Y + 12, x.type, !0), p.setBigUint64(Y + 16, BigInt(0), !0), p.setUint16(Y + 24, 0, !0), p.setUint32(b, 1, !0);
        }
        return p.setUint32(b, H.length, !0), 0;
      }
      if (m) {
        Number(N / BigInt(1e6));
        const x = l;
        p.setBigUint64(x, E, !0), p.setUint32(x + 8, 0, !0), p.setUint32(x + 12, 0, !0), p.setUint32(b, 1, !0);
      }
      return 0;
    }), this.proc_exit = Ie(this, "proc_exit", function(s) {
      return typeof process == "object" && process !== null && typeof process.exit == "function" && process.exit(s), 0;
    }), this.proc_raise = Ie(this, "proc_raise", function(s) {
      return 52;
    }), this.sched_yield = Ie(this, "sched_yield", function() {
      return 0;
    }), this.random_get = typeof crypto < "u" && typeof crypto.getRandomValues == "function" ? Ie(this, "random_get", function(s, l) {
      if (s = Number(s), s === 0)
        return 28;
      l = Number(l);
      const { HEAPU8: h, view: b } = ce(this);
      if (typeof SharedArrayBuffer == "function" && h.buffer instanceof SharedArrayBuffer || Object.prototype.toString.call(h.buffer) === "[object SharedArrayBuffer]") {
        for (let E = s; E < s + l; ++E)
          b.setUint8(E, Math.floor(Math.random() * 256));
        return 0;
      }
      let p;
      const S = 65536;
      for (p = 0; p + S < l; p += S)
        crypto.getRandomValues(h.subarray(s + p, s + p + S));
      return crypto.getRandomValues(h.subarray(s + p, s + l)), 0;
    }) : Ie(this, "random_get", function(s, l) {
      if (s = Number(s), s === 0)
        return 28;
      l = Number(l);
      const { view: h } = ce(this);
      for (let b = s; b < s + l; ++b)
        h.setUint8(b, Math.floor(Math.random() * 256));
      return 0;
    }), this.sock_recv = Ie(this, "sock_recv", function() {
      return 58;
    }), this.sock_send = Ie(this, "sock_send", function() {
      return 58;
    }), this.sock_shutdown = Ie(this, "sock_shutdown", function() {
      return 58;
    }), this.sock_accept = Ie(this, "sock_accept", function() {
      return 58;
    }), se.set(this, {
      fds: i,
      args: t,
      env: r
    }), c && el.set(this, c);
    const u = this;
    function _(s, l, h, b, p) {
      o ? n ? u[s] = n.wrapImportFunction(Ie(u, s, h)) : u[s] = my(Ie(u, s, h), b, p) : u[s] = Ie(u, s, l);
    }
    _("fd_allocate", function(l, h, b) {
      const p = se.get(this), S = Ae(this), E = p.fds.get(l, C.FD_ALLOCATE, BigInt(0));
      return S.fstatSync(E.fd, { bigint: !0 }).size < h + b && S.ftruncateSync(E.fd, Number(h + b)), 0;
    }, async function(l, h, b) {
      const E = se.get(this).fds.get(l, C.FD_ALLOCATE, BigInt(0)).fd;
      return (await E.stat({ bigint: !0 })).size < h + b && await E.truncate(Number(h + b)), 0;
    }, ["i32", "i64", "f64"], ["i32"]), _("fd_close", function(l) {
      const h = se.get(this), b = h.fds.get(l, BigInt(0), BigInt(0));
      return Ae(this).closeSync(b.fd), h.fds.remove(l), 0;
    }, async function(l) {
      const h = se.get(this);
      return await h.fds.get(l, BigInt(0), BigInt(0)).fd.close(), h.fds.remove(l), 0;
    }, ["i32"], ["i32"]), _("fd_datasync", function(l) {
      const b = se.get(this).fds.get(l, C.FD_DATASYNC, BigInt(0));
      return Ae(this).fdatasyncSync(b.fd), 0;
    }, async function(l) {
      return await se.get(this).fds.get(l, C.FD_DATASYNC, BigInt(0)).fd.datasync(), 0;
    }, ["i32"], ["i32"]), _("fd_filestat_get", function(l, h) {
      if (h = Number(h), h === 0)
        return 28;
      const p = se.get(this).fds.get(l, C.FD_FILESTAT_GET, BigInt(0)), E = Ae(this).fstatSync(p.fd, { bigint: !0 }), { view: v } = ce(this);
      return sn(v, h, E), 0;
    }, async function(l, h) {
      if (h = Number(h), h === 0)
        return 28;
      const E = await se.get(this).fds.get(l, C.FD_FILESTAT_GET, BigInt(0)).fd.stat({ bigint: !0 }), { view: v } = ce(this);
      return sn(v, h, E), 0;
    }, ["i32", "i32"], ["i32"]), _("fd_filestat_set_size", function(l, h) {
      const p = se.get(this).fds.get(l, C.FD_FILESTAT_SET_SIZE, BigInt(0));
      return Ae(this).ftruncateSync(p.fd, Number(h)), 0;
    }, async function(l, h) {
      return await se.get(this).fds.get(l, C.FD_FILESTAT_SET_SIZE, BigInt(0)).fd.truncate(Number(h)), 0;
    }, ["i32", "i64"], ["i32"]);
    function F(s, l, h, b) {
      const S = se.get(this).fds.get(s, C.FD_FILESTAT_SET_TIMES, BigInt(0));
      return (b & 2) === 2 && (l = BigInt(Date.now() * 1e6)), (b & 8) === 8 && (h = BigInt(Date.now() * 1e6)), { fileDescriptor: S, atim: l, mtim: h };
    }
    _("fd_filestat_set_times", function(l, h, b, p) {
      if (an(p))
        return 28;
      const { fileDescriptor: S, atim: E, mtim: v } = F.call(this, l, h, b, p);
      return Ae(this).futimesSync(S.fd, Number(E), Number(v)), 0;
    }, async function(l, h, b, p) {
      if (an(p))
        return 28;
      const { fileDescriptor: S, atim: E, mtim: v } = F.call(this, l, h, b, p);
      return await S.fd.utimes(Number(E), Number(v)), 0;
    }, ["i32", "i64", "i64", "i32"], ["i32"]), _("fd_pread", function(l, h, b, p, S) {
      if (h = Number(h), S = Number(S), h === 0 && b || S === 0 || p > on)
        return 28;
      const { HEAPU8: E, view: v } = ce(this), N = se.get(this).fds.get(l, C.FD_READ | C.FD_SEEK, BigInt(0));
      if (!b)
        return v.setUint32(S, 0, !0), 0;
      let I = 0;
      const M = Array.from({ length: Number(b) }, (oe, Z) => {
        const W = h + Z * 8, ae = v.getInt32(W, !0), ie = v.getUint32(W + 4, !0);
        return I += ie, E.subarray(ae, ae + ie);
      });
      let H = 0;
      const x = (() => {
        try {
          return new Uint8Array(new SharedArrayBuffer(I));
        } catch {
          return new Uint8Array(I);
        }
      })();
      x._isBuffer = !0;
      const X = Ae(this).readSync(N.fd, x, 0, x.length, Number(p));
      return H = x ? Qt(M, x.subarray(0, X)) : 0, v.setUint32(S, H, !0), 0;
    }, async function(s, l, h, b, p) {
      if (l = Number(l), p = Number(p), l === 0 && h || p === 0 || b > on)
        return 28;
      const { HEAPU8: S, view: E } = ce(this), m = se.get(this).fds.get(s, C.FD_READ | C.FD_SEEK, BigInt(0));
      if (!h)
        return E.setUint32(p, 0, !0), 0;
      let N = 0;
      const I = Array.from({ length: Number(h) }, (Y, X) => {
        const oe = l + X * 8, Z = E.getInt32(oe, !0), W = E.getUint32(oe + 4, !0);
        return N += W, S.subarray(Z, Z + W);
      });
      let M = 0;
      const H = new Uint8Array(N);
      H._isBuffer = !0;
      const { bytesRead: x } = await m.fd.read(H, 0, H.length, Number(b));
      return M = H ? Qt(I, H.subarray(0, x)) : 0, E.setUint32(p, M, !0), 0;
    }, ["i32", "i32", "i32", "i64", "i32"], ["i32"]), _("fd_pwrite", function(l, h, b, p, S) {
      if (h = Number(h), S = Number(S), h === 0 && b || S === 0 || p > on)
        return 28;
      const { HEAPU8: E, view: v } = ce(this), N = se.get(this).fds.get(l, C.FD_WRITE | C.FD_SEEK, BigInt(0));
      if (!b)
        return v.setUint32(S, 0, !0), 0;
      const I = Dr(Array.from({ length: Number(b) }, (x, Y) => {
        const X = h + Y * 8, oe = v.getInt32(X, !0), Z = v.getUint32(X + 4, !0);
        return E.subarray(oe, oe + Z);
      })), H = Ae(this).writeSync(N.fd, I, 0, I.length, Number(p));
      return v.setUint32(S, H, !0), 0;
    }, async function(l, h, b, p, S) {
      if (h = Number(h), S = Number(S), h === 0 && b || S === 0 || p > on)
        return 28;
      const { HEAPU8: E, view: v } = ce(this), N = se.get(this).fds.get(l, C.FD_WRITE | C.FD_SEEK, BigInt(0));
      if (!b)
        return v.setUint32(S, 0, !0), 0;
      const I = Dr(Array.from({ length: Number(b) }, (H, x) => {
        const Y = h + x * 8, X = v.getInt32(Y, !0), oe = v.getUint32(Y + 4, !0);
        return E.subarray(X, X + oe);
      })), { bytesWritten: M } = await N.fd.write(I, 0, I.length, Number(p));
      return v.setUint32(S, M, !0), 0;
    }, ["i32", "i32", "i32", "i64", "i32"], ["i32"]), _("fd_read", function(l, h, b, p) {
      if (h = Number(h), p = Number(p), h === 0 && b || p === 0)
        return 28;
      const { HEAPU8: S, view: E } = ce(this), m = se.get(this).fds.get(l, C.FD_READ, BigInt(0));
      if (!b)
        return E.setUint32(p, 0, !0), 0;
      let N = 0;
      const I = Array.from({ length: Number(b) }, (x, Y) => {
        const X = h + Y * 8, oe = E.getInt32(X, !0), Z = E.getUint32(X + 4, !0);
        return N += Z, S.subarray(oe, oe + Z);
      });
      let M, H = 0;
      if (l === 0) {
        if (typeof window > "u" || typeof window.prompt != "function")
          return 58;
        M = Fo(), H = M ? Qt(I, M) : 0;
      } else {
        M = (() => {
          try {
            return new Uint8Array(new SharedArrayBuffer(N));
          } catch {
            return new Uint8Array(N);
          }
        })(), M._isBuffer = !0;
        const Y = Ae(this).readSync(m.fd, M, 0, M.length, Number(m.pos));
        H = M ? Qt(I, M.subarray(0, Y)) : 0, m.pos += BigInt(H);
      }
      return E.setUint32(p, H, !0), 0;
    }, async function(l, h, b, p) {
      if (h = Number(h), p = Number(p), h === 0 && b || p === 0)
        return 28;
      const { HEAPU8: S, view: E } = ce(this), m = se.get(this).fds.get(l, C.FD_READ, BigInt(0));
      if (!b)
        return E.setUint32(p, 0, !0), 0;
      let N = 0;
      const I = Array.from({ length: Number(b) }, (x, Y) => {
        const X = h + Y * 8, oe = E.getInt32(X, !0), Z = E.getUint32(X + 4, !0);
        return N += Z, S.subarray(oe, oe + Z);
      });
      let M, H = 0;
      if (l === 0) {
        if (typeof window > "u" || typeof window.prompt != "function")
          return 58;
        M = Fo(), H = M ? Qt(I, M) : 0;
      } else {
        M = new Uint8Array(N), M._isBuffer = !0;
        const { bytesRead: x } = await m.fd.read(M, 0, M.length, Number(m.pos));
        H = M ? Qt(I, M.subarray(0, x)) : 0, m.pos += BigInt(H);
      }
      return E.setUint32(p, H, !0), 0;
    }, ["i32", "i32", "i32", "i32"], ["i32"]), _("fd_readdir", function(l, h, b, p, S) {
      if (h = Number(h), b = Number(b), S = Number(S), h === 0 || S === 0)
        return 0;
      const v = se.get(this).fds.get(l, C.FD_READDIR, BigInt(0)), m = Ae(this), N = m.readdirSync(v.realPath, { withFileTypes: !0 }), { HEAPU8: I, view: M } = ce(this);
      let H = 0;
      for (let x = Number(p); x < N.length; x++) {
        const Y = ft.encode(N[x].name), X = m.statSync(Pe(v.realPath, N[x].name), { bigint: !0 }), oe = new Uint8Array(24 + Y.byteLength), Z = new DataView(oe.buffer);
        Z.setBigUint64(0, BigInt(x + 1), !0), Z.setBigUint64(8, BigInt(X.ino ? X.ino : 0), !0), Z.setUint32(16, Y.byteLength, !0);
        let W;
        N[x].isFile() ? W = 4 : N[x].isDirectory() ? W = 3 : N[x].isSymbolicLink() ? W = 7 : N[x].isCharacterDevice() ? W = 2 : N[x].isBlockDevice() ? W = 1 : N[x].isSocket() ? W = 6 : W = 0, Z.setUint8(20, W), oe.set(Y, 24);
        const ae = oe.slice(0, Math.min(oe.length, b - H));
        I.set(ae, h + H), H += ae.byteLength;
      }
      return M.setUint32(S, H, !0), 0;
    }, async function(l, h, b, p, S) {
      if (h = Number(h), b = Number(b), S = Number(S), h === 0 || S === 0)
        return 0;
      const v = se.get(this).fds.get(l, C.FD_READDIR, BigInt(0)), m = Ae(this), N = await m.promises.readdir(v.realPath, { withFileTypes: !0 }), { HEAPU8: I, view: M } = ce(this);
      let H = 0;
      for (let x = Number(p); x < N.length; x++) {
        const Y = ft.encode(N[x].name), X = await m.promises.stat(Pe(v.realPath, N[x].name), { bigint: !0 }), oe = new Uint8Array(24 + Y.byteLength), Z = new DataView(oe.buffer);
        Z.setBigUint64(0, BigInt(x + 1), !0), Z.setBigUint64(8, BigInt(X.ino ? X.ino : 0), !0), Z.setUint32(16, Y.byteLength, !0);
        let W;
        N[x].isFile() ? W = 4 : N[x].isDirectory() ? W = 3 : N[x].isSymbolicLink() ? W = 7 : N[x].isCharacterDevice() ? W = 2 : N[x].isBlockDevice() ? W = 1 : N[x].isSocket() ? W = 6 : W = 0, Z.setUint8(20, W), oe.set(Y, 24);
        const ae = oe.slice(0, Math.min(oe.length, b - H));
        I.set(ae, h + H), H += ae.byteLength;
      }
      return M.setUint32(S, H, !0), 0;
    }, ["i32", "i32", "i32", "i64", "i32"], ["i32"]), _("fd_renumber", function(l, h) {
      return se.get(this).fds.renumber(h, l), 0;
    }, async function(l, h) {
      return await se.get(this).fds.renumber(h, l), 0;
    }, ["i32", "i32"], ["i32"]), _("fd_sync", function(l) {
      const b = se.get(this).fds.get(l, C.FD_SYNC, BigInt(0));
      return Ae(this).fsyncSync(b.fd), 0;
    }, async function(l) {
      return await se.get(this).fds.get(l, C.FD_SYNC, BigInt(0)).fd.sync(), 0;
    }, ["i32"], ["i32"]), _("fd_write", function(l, h, b, p) {
      if (h = Number(h), p = Number(p), h === 0 && b || p === 0)
        return 28;
      const { HEAPU8: S, view: E } = ce(this), m = se.get(this).fds.get(l, C.FD_WRITE, BigInt(0));
      if (!b)
        return E.setUint32(p, 0, !0), 0;
      const N = Dr(Array.from({ length: Number(b) }, (M, H) => {
        const x = h + H * 8, Y = E.getInt32(x, !0), X = E.getUint32(x + 4, !0);
        return S.subarray(Y, Y + X);
      }));
      let I;
      return l === 1 || l === 2 ? I = m.write(N) : (I = Ae(this).writeSync(m.fd, N, 0, N.length, Number(m.pos)), m.pos += BigInt(I)), E.setUint32(p, I, !0), 0;
    }, async function(l, h, b, p) {
      if (h = Number(h), p = Number(p), h === 0 && b || p === 0)
        return 28;
      const { HEAPU8: S, view: E } = ce(this), m = se.get(this).fds.get(l, C.FD_WRITE, BigInt(0));
      if (!b)
        return E.setUint32(p, 0, !0), 0;
      const N = Dr(Array.from({ length: Number(b) }, (M, H) => {
        const x = h + H * 8, Y = E.getInt32(x, !0), X = E.getUint32(x + 4, !0);
        return S.subarray(Y, Y + X);
      }));
      let I;
      return l === 1 || l === 2 ? I = m.write(N) : (I = await (await m.fd.write(N, 0, N.length, Number(m.pos))).bytesWritten, m.pos += BigInt(I)), E.setUint32(p, I, !0), 0;
    }, ["i32", "i32", "i32", "i32"], ["i32"]), _("path_create_directory", function(l, h, b) {
      if (h = Number(h), b = Number(b), h === 0)
        return 28;
      const { HEAPU8: p } = ce(this), E = se.get(this).fds.get(l, C.PATH_CREATE_DIRECTORY, BigInt(0));
      let v = Oe.decode(Ne(p, h, h + b));
      return v = Pe(E.realPath, v), Ae(this).mkdirSync(v), 0;
    }, async function(l, h, b) {
      if (h = Number(h), b = Number(b), h === 0)
        return 28;
      const { HEAPU8: p } = ce(this), E = se.get(this).fds.get(l, C.PATH_CREATE_DIRECTORY, BigInt(0));
      let v = Oe.decode(Ne(p, h, h + b));
      return v = Pe(E.realPath, v), await Ae(this).promises.mkdir(v), 0;
    }, ["i32", "i32", "i32"], ["i32"]), _("path_filestat_get", function(l, h, b, p, S) {
      if (b = Number(b), p = Number(p), S = Number(S), b === 0 || S === 0)
        return 28;
      const { HEAPU8: E, view: v } = ce(this), N = se.get(this).fds.get(l, C.PATH_FILESTAT_GET, BigInt(0));
      let I = Oe.decode(Ne(E, b, b + p));
      const M = Ae(this);
      I = Pe(N.realPath, I);
      let H;
      return (h & 1) === 1 ? H = M.statSync(I, { bigint: !0 }) : H = M.lstatSync(I, { bigint: !0 }), sn(v, S, H), 0;
    }, async function(l, h, b, p, S) {
      if (b = Number(b), p = Number(p), S = Number(S), b === 0 || S === 0)
        return 28;
      const { HEAPU8: E, view: v } = ce(this), N = se.get(this).fds.get(l, C.PATH_FILESTAT_GET, BigInt(0));
      let I = Oe.decode(Ne(E, b, b + p));
      const M = Ae(this);
      I = Pe(N.realPath, I);
      let H;
      return (h & 1) === 1 ? H = await M.promises.stat(I, { bigint: !0 }) : H = await M.promises.lstat(I, { bigint: !0 }), sn(v, S, H), 0;
    }, ["i32", "i32", "i32", "i32", "i32"], ["i32"]), _("path_filestat_set_times", function(l, h, b, p, S, E, v) {
      if (b = Number(b), p = Number(p), b === 0)
        return 28;
      const { HEAPU8: m } = ce(this), I = se.get(this).fds.get(l, C.PATH_FILESTAT_SET_TIMES, BigInt(0));
      if (an(v))
        return 28;
      const M = Ae(this), H = wi(M, I, Oe.decode(Ne(m, b, b + p)), h);
      return (v & 2) === 2 && (S = BigInt(Date.now() * 1e6)), (v & 8) === 8 && (E = BigInt(Date.now() * 1e6)), M.utimesSync(H, Number(S), Number(E)), 0;
    }, async function(l, h, b, p, S, E, v) {
      if (b = Number(b), p = Number(p), b === 0)
        return 28;
      const { HEAPU8: m } = ce(this), I = se.get(this).fds.get(l, C.PATH_FILESTAT_SET_TIMES, BigInt(0));
      if (an(v))
        return 28;
      const M = Ae(this), H = await _i(M, I, Oe.decode(Ne(m, b, b + p)), h);
      return (v & 2) === 2 && (S = BigInt(Date.now() * 1e6)), (v & 8) === 8 && (E = BigInt(Date.now() * 1e6)), await M.promises.utimes(H, Number(S), Number(E)), 0;
    }, ["i32", "i32", "i32", "i32", "i64", "i64", "i32"], ["i32"]), _("path_link", function(l, h, b, p, S, E, v) {
      if (b = Number(b), p = Number(p), E = Number(E), v = Number(v), b === 0 || E === 0)
        return 28;
      const m = se.get(this);
      let N, I;
      l === S ? N = I = m.fds.get(l, C.PATH_LINK_SOURCE | C.PATH_LINK_TARGET, BigInt(0)) : (N = m.fds.get(l, C.PATH_LINK_SOURCE, BigInt(0)), I = m.fds.get(S, C.PATH_LINK_TARGET, BigInt(0)));
      const { HEAPU8: M } = ce(this), H = Ae(this), x = wi(H, N, Oe.decode(Ne(M, b, b + p)), h), Y = Pe(I.realPath, Oe.decode(Ne(M, E, E + v)));
      return H.linkSync(x, Y), 0;
    }, async function(l, h, b, p, S, E, v) {
      if (b = Number(b), p = Number(p), E = Number(E), v = Number(v), b === 0 || E === 0)
        return 28;
      const m = se.get(this);
      let N, I;
      l === S ? N = I = m.fds.get(l, C.PATH_LINK_SOURCE | C.PATH_LINK_TARGET, BigInt(0)) : (N = m.fds.get(l, C.PATH_LINK_SOURCE, BigInt(0)), I = m.fds.get(S, C.PATH_LINK_TARGET, BigInt(0)));
      const { HEAPU8: M } = ce(this), H = Ae(this), x = await _i(H, N, Oe.decode(Ne(M, b, b + p)), h), Y = Pe(I.realPath, Oe.decode(Ne(M, E, E + v)));
      return await H.promises.link(x, Y), 0;
    }, ["i32", "i32", "i32", "i32", "i32", "i32", "i32"], ["i32"]);
    function d(s, l, h, b) {
      const p = (l & (C.FD_READ | C.FD_READDIR)) !== BigInt(0), S = (l & (C.FD_DATASYNC | C.FD_WRITE | C.FD_ALLOCATE | C.FD_FILESTAT_SET_SIZE)) !== BigInt(0);
      let E = S ? p ? 2 : 1 : 0, v = C.PATH_OPEN, m = l | h;
      return (s & 1) !== 0 && (E |= 64, v |= C.PATH_CREATE_FILE), (s & 2) !== 0 && (E |= 65536), (s & 4) !== 0 && (E |= 128), (s & 8) !== 0 && (E |= 512, v |= C.PATH_FILESTAT_SET_SIZE), (b & 1) !== 0 && (E |= 1024), (b & 2) !== 0 && (m |= C.FD_DATASYNC), (b & 4) !== 0 && (E |= 2048), (b & 8) !== 0 && (E |= 1052672, m |= C.FD_SYNC), (b & 16) !== 0 && (E |= 1052672, m |= C.FD_SYNC), S && (E & 1536) === 0 && (m |= C.FD_SEEK), { flags: E, needed_base: v, needed_inheriting: m };
    }
    _("path_open", function(l, h, b, p, S, E, v, m, N) {
      if (b = Number(b), N = Number(N), b === 0 || N === 0)
        return 28;
      p = Number(p), E = BigInt(E), v = BigInt(v);
      const { flags: I, needed_base: M, needed_inheriting: H } = d(S, E, v, m), x = se.get(this), Y = x.fds.get(l, M, H), X = ce(this), oe = X.HEAPU8, Z = Oe.decode(Ne(oe, b, b + p)), W = Ae(this), ae = wi(W, Y, Z, h), ie = W.openSync(ae, I, 438), ne = x.fds.getFileTypeByFd(ie);
      if ((S & 2) !== 0 && ne !== 3)
        return 54;
      const { base: we, inheriting: me } = Cr(x.fds.stdio, ie, I, ne), _e = x.fds.insert(ie, ae, ae, ne, E & we, v & me, 0), pe = W.fstatSync(ie, { bigint: !0 });
      return pe.isFile() && (_e.size = pe.size, (I & 1024) !== 0 && (_e.pos = pe.size)), X.view.setInt32(N, _e.id, !0), 0;
    }, async function(l, h, b, p, S, E, v, m, N) {
      if (b = Number(b), N = Number(N), b === 0 || N === 0)
        return 28;
      p = Number(p), E = BigInt(E), v = BigInt(v);
      const { flags: I, needed_base: M, needed_inheriting: H } = d(S, E, v, m), x = se.get(this), Y = x.fds.get(l, M, H), X = ce(this), oe = X.HEAPU8, Z = Oe.decode(Ne(oe, b, b + p)), W = Ae(this), ae = await _i(W, Y, Z, h), ie = await W.promises.open(ae, I, 438), ne = await x.fds.getFileTypeByFd(ie);
      if ((S & 2) !== 0 && ne !== 3)
        return 54;
      const { base: we, inheriting: me } = Cr(x.fds.stdio, ie.fd, I, ne), _e = x.fds.insert(ie, ae, ae, ne, E & we, v & me, 0), pe = await ie.stat({ bigint: !0 });
      return pe.isFile() && (_e.size = pe.size, (I & 1024) !== 0 && (_e.pos = pe.size)), X.view.setInt32(N, _e.id, !0), 0;
    }, ["i32", "i32", "i32", "i32", "i32", "i64", "i64", "i32", "i32"], ["i32"]), _("path_readlink", function(l, h, b, p, S, E) {
      if (h = Number(h), b = Number(b), p = Number(p), S = Number(S), E = Number(E), h === 0 || p === 0 || E === 0)
        return 28;
      const { HEAPU8: v, view: m } = ce(this), I = se.get(this).fds.get(l, C.PATH_READLINK, BigInt(0));
      let M = Oe.decode(Ne(v, h, h + b));
      M = Pe(I.realPath, M);
      const x = Ae(this).readlinkSync(M), Y = ft.encode(x), X = Math.min(Y.length, S);
      return X >= S ? 42 : (v.set(Y.subarray(0, X), p), v[p + X] = 0, m.setUint32(E, X, !0), 0);
    }, async function(l, h, b, p, S, E) {
      if (h = Number(h), b = Number(b), p = Number(p), S = Number(S), E = Number(E), h === 0 || p === 0 || E === 0)
        return 28;
      const { HEAPU8: v, view: m } = ce(this), I = se.get(this).fds.get(l, C.PATH_READLINK, BigInt(0));
      let M = Oe.decode(Ne(v, h, h + b));
      M = Pe(I.realPath, M);
      const x = await Ae(this).promises.readlink(M), Y = ft.encode(x), X = Math.min(Y.length, S);
      return X >= S ? 42 : (v.set(Y.subarray(0, X), p), v[p + X] = 0, m.setUint32(E, X, !0), 0);
    }, ["i32", "i32", "i32", "i32", "i32", "i32"], ["i32"]), _("path_remove_directory", function(l, h, b) {
      if (h = Number(h), b = Number(b), h === 0)
        return 28;
      const { HEAPU8: p } = ce(this), E = se.get(this).fds.get(l, C.PATH_REMOVE_DIRECTORY, BigInt(0));
      let v = Oe.decode(Ne(p, h, h + b));
      return v = Pe(E.realPath, v), Ae(this).rmdirSync(v), 0;
    }, async function(l, h, b) {
      if (h = Number(h), b = Number(b), h === 0)
        return 28;
      const { HEAPU8: p } = ce(this), E = se.get(this).fds.get(l, C.PATH_REMOVE_DIRECTORY, BigInt(0));
      let v = Oe.decode(Ne(p, h, h + b));
      return v = Pe(E.realPath, v), await Ae(this).promises.rmdir(v), 0;
    }, ["i32", "i32", "i32"], ["i32"]), _("path_rename", function(l, h, b, p, S, E) {
      if (h = Number(h), b = Number(b), S = Number(S), E = Number(E), h === 0 || S === 0)
        return 28;
      const v = se.get(this);
      let m, N;
      l === p ? m = N = v.fds.get(l, C.PATH_RENAME_SOURCE | C.PATH_RENAME_TARGET, BigInt(0)) : (m = v.fds.get(l, C.PATH_RENAME_SOURCE, BigInt(0)), N = v.fds.get(p, C.PATH_RENAME_TARGET, BigInt(0)));
      const { HEAPU8: I } = ce(this), M = Pe(m.realPath, Oe.decode(Ne(I, h, h + b))), H = Pe(N.realPath, Oe.decode(Ne(I, S, S + E)));
      return Ae(this).renameSync(M, H), 0;
    }, async function(l, h, b, p, S, E) {
      if (h = Number(h), b = Number(b), S = Number(S), E = Number(E), h === 0 || S === 0)
        return 28;
      const v = se.get(this);
      let m, N;
      l === p ? m = N = v.fds.get(l, C.PATH_RENAME_SOURCE | C.PATH_RENAME_TARGET, BigInt(0)) : (m = v.fds.get(l, C.PATH_RENAME_SOURCE, BigInt(0)), N = v.fds.get(p, C.PATH_RENAME_TARGET, BigInt(0)));
      const { HEAPU8: I } = ce(this), M = Pe(m.realPath, Oe.decode(Ne(I, h, h + b))), H = Pe(N.realPath, Oe.decode(Ne(I, S, S + E)));
      return await Ae(this).promises.rename(M, H), 0;
    }, ["i32", "i32", "i32", "i32", "i32", "i32"], ["i32"]), _("path_symlink", function(l, h, b, p, S) {
      if (l = Number(l), h = Number(h), p = Number(p), S = Number(S), l === 0 || p === 0)
        return 28;
      const { HEAPU8: E } = ce(this), m = se.get(this).fds.get(b, C.PATH_SYMLINK, BigInt(0)), N = Oe.decode(Ne(E, l, l + h));
      let I = Oe.decode(Ne(E, p, p + S));
      return I = Pe(m.realPath, I), Ae(this).symlinkSync(N, I), 0;
    }, async function(l, h, b, p, S) {
      if (l = Number(l), h = Number(h), p = Number(p), S = Number(S), l === 0 || p === 0)
        return 28;
      const { HEAPU8: E } = ce(this), m = se.get(this).fds.get(b, C.PATH_SYMLINK, BigInt(0)), N = Oe.decode(Ne(E, l, l + h));
      let I = Oe.decode(Ne(E, p, p + S));
      return I = Pe(m.realPath, I), await Ae(this).promises.symlink(N, I), 0;
    }, ["i32", "i32", "i32", "i32", "i32"], ["i32"]), _("path_unlink_file", function(l, h, b) {
      if (h = Number(h), b = Number(b), h === 0)
        return 28;
      const { HEAPU8: p } = ce(this), E = se.get(this).fds.get(l, C.PATH_UNLINK_FILE, BigInt(0));
      let v = Oe.decode(Ne(p, h, h + b));
      return v = Pe(E.realPath, v), Ae(this).unlinkSync(v), 0;
    }, async function(l, h, b) {
      if (h = Number(h), b = Number(b), h === 0)
        return 28;
      const { HEAPU8: p } = ce(this), E = se.get(this).fds.get(l, C.PATH_UNLINK_FILE, BigInt(0));
      let v = Oe.decode(Ne(p, h, h + b));
      return v = Pe(E.realPath, v), await Ae(this).promises.unlink(v), 0;
    }, ["i32", "i32", "i32"], ["i32"]), this._setMemory = function(l) {
      if (!(l instanceof Hr.Memory))
        throw new TypeError('"instance.exports.memory" property must be a WebAssembly.Memory');
      Qa.set(u, py(l));
    };
  }
  static createSync(t, r, i, o, c, n, u) {
    const _ = new cy({
      size: 3,
      in: o[0],
      out: o[1],
      err: o[2],
      fs: c,
      print: n,
      printErr: u
    }), F = new ur(t, r, _, !1, c);
    if (i.length > 0)
      for (let d = 0; d < i.length; ++d) {
        const s = c.realpathSync(i[d].realPath, "utf8"), l = c.openSync(s, "r", 438);
        _.insertPreopen(l, i[d].mappedPath, s);
      }
    return F;
  }
  static async createAsync(t, r, i, o, c, n, u, _) {
    const F = new dy({
      size: 3,
      in: o[0],
      out: o[1],
      err: o[2],
      print: n,
      printErr: u
    }), d = new ur(t, r, F, !0, c, _);
    if (i.length > 0)
      for (let s = 0; s < i.length; ++s) {
        const l = i[s], h = await c.promises.realpath(l.realPath), b = await c.promises.open(h, "r", 438);
        await F.insertPreopen(b, l.mappedPath, h);
      }
    return d;
  }
}
const wy = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.create(null)), Tt = Symbol("kExitCode"), tl = Symbol("kSetMemory"), Br = Symbol("kStarted"), An = Symbol("kInstance"), pn = Symbol("kBindingName");
function No(e, t) {
  ir(t, "instance"), ir(t.exports, "instance.exports"), e[An] = t, e[tl](t.exports.memory);
}
function _y(e) {
  var t;
  ir(e, "options");
  let r;
  if (e.version !== void 0)
    switch (Ya(e.version, "options.version"), e.version) {
      case "unstable":
        r = ur, this[pn] = "wasi_unstable";
        break;
      case "preview1":
        r = ur, this[pn] = "wasi_snapshot_preview1";
        break;
      default:
        throw new TypeError(`unsupported WASI version "${e.version}"`);
    }
  else
    r = ur, this[pn] = "wasi_snapshot_preview1";
  e.args !== void 0 && wh(e.args, "options.args");
  const i = ((t = e.args) !== null && t !== void 0 ? t : []).map(String), o = [];
  e.env !== void 0 && (ir(e.env, "options.env"), Object.entries(e.env).forEach(({ 0: u, 1: _ }) => {
    _ !== void 0 && o.push(`${u}=${_}`);
  }));
  const c = [];
  if (e.preopens !== void 0 && (ir(e.preopens, "options.preopens"), Object.entries(e.preopens).forEach(({ 0: u, 1: _ }) => c.push({ mappedPath: String(u), realPath: String(_) }))), c.length > 0) {
    if (e.fs === void 0)
      throw new Error("filesystem is disabled, can not preopen directory");
    try {
      ir(e.fs, "options.fs");
    } catch {
      throw new TypeError("Node.js fs like implementation is not provided");
    }
  }
  return e.print !== void 0 && En(e.print, "options.print"), e.printErr !== void 0 && En(e.printErr, "options.printErr"), e.returnOnExit !== void 0 && _h(e.returnOnExit, "options.returnOnExit"), {
    args: i,
    env: o,
    preopens: c,
    stdio: [0, 1, 2],
    _WASI: r
  };
}
function Sy(e, t) {
  this[tl] = e, this.wasiImport = t, this[Br] = !1, this[Tt] = 0, this[An] = void 0;
}
class vy {
  constructor(t = wy) {
    const { args: r, env: i, preopens: o, stdio: c, _WASI: n } = _y.call(this, t), u = n.createSync(r, i, o, c, t.fs, t.print, t.printErr), _ = u._setMemory;
    delete u._setMemory, Sy.call(this, _, u), t.returnOnExit && (u.proc_exit = Ey.bind(this));
  }
  // Must not export _initialize, must export _start
  start(t) {
    if (this[Br])
      throw new Error("WASI instance has already started");
    this[Br] = !0, No(this, t);
    const { _start: r, _initialize: i } = this[An].exports;
    En(r, "instance.exports._start"), To(i, "instance.exports._initialize");
    let o;
    try {
      o = r();
    } catch (c) {
      if (c !== Tt)
        throw c;
    }
    return o instanceof Promise ? o.then(() => this[Tt], (c) => {
      if (c !== Tt)
        throw c;
      return this[Tt];
    }) : this[Tt];
  }
  // Must not export _start, may optionally export _initialize
  initialize(t) {
    if (this[Br])
      throw new Error("WASI instance has already started");
    this[Br] = !0, No(this, t);
    const { _start: r, _initialize: i } = this[An].exports;
    if (To(r, "instance.exports._start"), i !== void 0)
      return En(i, "instance.exports._initialize"), i();
  }
  getImportObject() {
    return { [this[pn]]: this.wasiImport };
  }
}
function Ey(e) {
  throw this[Tt] = e, Tt;
}
const gg = (e) => Rt.OutputReport.deserialize(e), Ay = async (e) => {
  const t = {};
  return typeof e.input == "string" ? t.input = await globalThis.fs.readFile(e.input) : t.input = e.input, Array.isArray(e.subsets) && (t.subsets = e.subsets.map(
    (r) => new Uint8Array(new Uint32Array(r).buffer)
  )), { ...e, ...t };
}, mg = (e, t, r) => async function(o) {
  const c = await Ay(o), n = Rt.InputTemplate.fromObject(c);
  if (!n.outDir) throw new Error("cn-font-split need outDir");
  const u = Math.random().toString().slice(2, 5);
  console.time("cn-font-split " + u);
  let _ = [];
  return new Promise((F) => {
    const d = n.serialize(), s = (l) => {
      let h = Rt.EventMessage.deserialize(l);
      switch (h.event) {
        case Rt.EventName.END:
          F();
          break;
        case Rt.EventName.OUTPUT_DATA:
          !o.silent && console.log(h.message);
          let b = (o.outputFile || globalThis.fs.outputFile)(
            ol.join(n.outDir, h.message),
            h.data
          );
          _.push(b);
          break;
      }
    };
    e(d, d.length, t(s));
  }).then(async (F) => (await Promise.all(_), F)).finally(() => {
    console.timeEnd("cn-font-split " + u), r?.();
  });
};
class Ty {
  constructor(t = Math.random().toString().replace(".", "")) {
    this.key = t;
  }
  fs;
  async init(t = bh(new mh())) {
    await t.promises.mkdir("/tmp/fonts", { recursive: !0 }), await t.promises.mkdir("/tmp/" + this.key), this.fs = t;
  }
  async setConfig(t) {
    const r = t instanceof ArrayBuffer ? new Uint8Array(t) : Rt.InputTemplate.fromObject(
      t
    ).serialize();
    await this.fs.promises.writeFile("/tmp/fonts/" + this.key, r);
  }
  async callback() {
    const t = await this.fs.promises.readdir(
      "/tmp/" + this.key
    );
    return Promise.all(
      t.filter((r) => typeof r == "string").map(async (r) => {
        if (r) {
          const i = "/tmp/" + this.key + "/" + r, o = await this.fs.promises.readFile(
            i
          );
          return await this.fs.promises.unlink(i), {
            name: r,
            data: o
          };
        }
      })
    ).finally(async () => {
      await this.fs.promises.unlink("/tmp/fonts/" + this.key);
    });
  }
}
async function bg(e, t, r) {
  const i = new Ty(r?.key);
  await i.init(), await i.setConfig(e);
  const { imports: o, wasi: c } = Ry(i, r), n = await t(o), { instance: u } = n;
  return console.time("wasm"), await c.start(u), console.timeEnd("wasm"), i.callback();
}
function Ry(e, t) {
  const r = new vy({
    args: [e.key],
    env: {
      WASI_SDK_PATH: "/opt/wasi-sdk",
      RUST_LOG: "debug"
    },
    preopens: {
      "/": "/"
    },
    // @ts-ignore
    fs: e.fs,
    print(o) {
      t?.logger(o, "log");
    },
    printErr(o) {
      t?.logger(o, "error");
    }
  });
  return { imports: {
    wasi_snapshot_preview1: r.wasiImport,
    env: {
      pthread_mutex_init: () => (console.log("Initializing mutex"), 0),
      pthread_mutex_lock: () => (console.log("Locking mutex"), 0),
      pthread_mutex_unlock: () => (console.log("Unlocking mutex"), 0),
      pthread_mutex_destroy: () => (console.log("Destroying mutex"), 0)
    }
  }, wasi: r };
}
class wg {
  wasmBuffer;
  url = "";
  constructor(t) {
    typeof t == "string" ? this.wasmBuffer = fetch(t).then((r) => r.arrayBuffer()) : this.wasmBuffer = Promise.resolve(t.buffer);
  }
  WasiHandle = async (t) => WebAssembly.instantiate(
    new Uint8Array((await this.wasmBuffer).slice(0)),
    // './target/wasm32-wasip1/release/wasm_edge.Oz.wasm',
    t
  );
}
export {
  Ty as APIInterface,
  wg as StaticWasm,
  mg as createAPI,
  Ry as createWasi,
  gg as decodeReporter,
  bg as fontSplit,
  Rt as proto
};
//# sourceMappingURL=index.mjs.map
