'use strict';

Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

const protobuf = require('protobufjs');
const fs = require('fs');

const genCommanderCode = (filePath, messageName) => {
  const buf = fs.readFileSync(filePath, "utf-8");
  const proto = protobuf.parse(buf, {
    alternateCommentMode: true
  });
  const defaultCommandName = "run";
  const template = proto.root.lookup(messageName);
  const { fields, nested } = template.toJSON({ keepComments: true });
  const importHeader = `/* automatically generated by proto-to-cli */
import { toInt, toFloat, toFile, toBoolean, HandleRepeated } from "proto-to-cli/dist/parser.js";
import { Command } from 'commander';
const run = new Command("${defaultCommandName}");
`;
  const shortCode = /* @__PURE__ */ new Set();
  const params = `run` + createFlatDefine(fields).join("\n    ");
  function createFlatDefine(fields2, parentKey = "") {
    return Object.entries(fields2).flatMap(([key, value]) => {
      let isOption = value.options?.proto3_optional ?? false;
      if (parentKey) isOption = true;
      const comment = value.comment ?? "";
      if (nested && Object.keys(nested).includes(value.type)) {
        return createFlatDefine(
          nested[value.type].fields,
          key + "."
        );
      }
      let parser;
      let placeholder = ` <${value.type}>`;
      if (value.type.startsWith("int")) {
        parser = "toInt";
      } else if (value.type.startsWith("float")) {
        parser = "toFloat";
      } else if (value.type.startsWith("bytes")) {
        parser = "toFile";
      } else if (value.type === "bool") {
        parser = "toBoolean";
      }
      if (value.rule === "repeated" && parser) {
        parser = `HandleRepeated(${parser})`;
        isOption = true;
      }
      const longName = parentKey + key;
      let mayShortName = "";
      if (!parentKey && !shortCode.has(longName[0])) {
        mayShortName = "-" + longName[0] + ",";
        shortCode.add(longName[0]);
      }
      return [
        `.${isOption ? "option" : "requiredOption"}('${mayShortName}--${longName}${placeholder}',"${comment}"${parser ? "," + parser : ""}${""})`
      ];
    });
  }
  return importHeader + params + `
export const getCliParams = (argv: string[], extraFn?: (cm: Command, run: Command) => void) => {
    const program = new Command();
    program.addCommand(run, { isDefault: true });
    extraFn && extraFn(program, run);
    return program.parse(argv);
};`;
};

exports.genCommanderCode = genCommanderCode;
//# sourceMappingURL=genCommanderCode.js.map
