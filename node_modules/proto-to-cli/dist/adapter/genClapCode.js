'use strict';

Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

const protobuf = require('protobufjs');
const fs = require('fs');
const index = require('../node_modules/.pnpm/change-case@5.4.4/node_modules/change-case/dist/index.js');

const genClapCode = (filePath, messageName) => {
  const buf = fs.readFileSync(filePath, "utf-8");
  const proto = protobuf.parse(buf, {
    alternateCommentMode: true
  });
  const template = proto.root.lookup(messageName);
  const { fields, nested } = template.toJSON({ keepComments: true });
  const importHeader = `/* automatically generated by proto-to-cli */
use clap::Parser;
use std::path::PathBuf;
#[derive(Parser, Debug)]
#[command(version, about, long_about = None)]
#[clap(name = "${messageName}")]
pub struct ${messageName} {
`;
  const shortCode = /* @__PURE__ */ new Set();
  const params = createFlatDefine(fields).join("\n");
  function createFlatDefine(fields2, parentKey = "") {
    return Object.entries(fields2).flatMap(([key, value]) => {
      let isOption = value.options?.proto3_optional ?? false;
      if (parentKey) isOption = true;
      const comment = value.comment ?? "";
      if (nested && Object.keys(nested).includes(value.type)) {
        return createFlatDefine(
          nested[value.type].fields,
          key + "."
        );
      }
      const typeMap = {
        // proto 类型: Rust 类型
        bytes: "PathBuf",
        string: "String",
        int32: "i32",
        int64: "i64",
        uint32: "u32",
        uint64: "u64",
        sint32: "i32",
        sint64: "i64",
        fixed32: "u32",
        fixed64: "u64",
        sfixed32: "i32",
        sfixed64: "i64",
        bool: "bool",
        float: "f32",
        double: "f64"
        // 对于枚举类型，可以使用自定义枚举名
        // enum: 'CustomEnum',
      };
      const toRepeated = (val) => value.rule === "repeated" ? `Vec<${val}>` : val;
      let placeholder = toRepeated(
        `${typeMap[value.type] ?? value.type}`
      );
      const longName = parentKey + key;
      let mayShortName = "";
      if (!parentKey && !shortCode.has(longName[0])) {
        mayShortName = longName[0];
        shortCode.add(longName[0]);
      }
      return [
        `    #[arg(${[
          `long = "${longName}"`,
          mayShortName ? `short = '${mayShortName}'` : "",
          `help = "${comment}"`,
          ""
          // value.type === 'bytes' ? `value_parser = parse_bytes` : '',
        ].filter(Boolean).map((i) => "\n        " + i).join(",")}
    )]
    pub ${index.snakeCase(capitalizeAfterDot(longName))}: ${isOption ? `Option<${placeholder}>` : placeholder},
`
      ];
    });
  }
  return importHeader + params + `
}`;
};
function capitalizeAfterDot(input) {
  return input.replace(/(\.)([a-z])/g, (match, p1, p2) => {
    return p2.toUpperCase();
  });
}

exports.genClapCode = genClapCode;
//# sourceMappingURL=genClapCode.js.map
